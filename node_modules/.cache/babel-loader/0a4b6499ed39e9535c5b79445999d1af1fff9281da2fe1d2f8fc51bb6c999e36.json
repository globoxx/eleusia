{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport var MicrophoneIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(MicrophoneIterator, _LazyIterator);\n  var _super = _createSuper(MicrophoneIterator);\n  function MicrophoneIterator(microphoneConfig) {\n    var _this;\n    _classCallCheck(this, MicrophoneIterator);\n    _this = _super.call(this);\n    _this.microphoneConfig = microphoneConfig;\n    _this.isClosed = false;\n    _this.fftSize = microphoneConfig.fftSize || 1024;\n    var fftSizeLog2 = Math.log2(_this.fftSize);\n    if (_this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(\"Invalid fftSize: it must be a power of 2 between \" + \"2 to 4 and 2 to 14, but got \".concat(_this.fftSize));\n    }\n    _this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    _this.sampleRateHz = microphoneConfig.sampleRateHz;\n    _this.columnTruncateLength = microphoneConfig.columnTruncateLength || _this.fftSize;\n    _this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    _this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    _this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    _this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n    if (!_this.includeSpectrogram && !_this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n    return _this;\n  }\n  _createClass(MicrophoneIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"microphone\";\n    }\n    // Construct a MicrophoneIterator and start the audio stream.\n  }, {\n    key: \"start\",\n    value: // Start the audio stream and FFT.\n    function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var ctxConstructor, streamSource;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return navigator.mediaDevices.getUserMedia({\n                audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,\n                video: false\n              });\n            case 3:\n              this.stream = _context.sent;\n              _context.next = 9;\n              break;\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](0);\n              throw new Error(\"Error thrown while initializing video stream: \".concat(_context.t0.message));\n            case 9:\n              if (this.stream) {\n                _context.next = 11;\n                break;\n              }\n              throw new Error('Could not obtain audio from microphone.');\n            case 11:\n              ctxConstructor =\n              // tslint:disable-next-line:no-any\n              window.AudioContext || window.webkitAudioContext;\n              this.audioContext = new ctxConstructor();\n              if (this.sampleRateHz) {\n                _context.next = 17;\n                break;\n              }\n              // If sample rate is not provided, use the available sample rate on\n              // device.\n              this.sampleRateHz = this.audioContext.sampleRate;\n              _context.next = 19;\n              break;\n            case 17:\n              if (!(this.audioContext.sampleRate !== this.sampleRateHz)) {\n                _context.next = 19;\n                break;\n              }\n              throw new Error(\"Mismatch in sampling rate: \" + \"Expected: \".concat(this.sampleRateHz, \"; \") + \"Actual: \".concat(this.audioContext.sampleRate));\n            case 19:\n              streamSource = this.audioContext.createMediaStreamSource(this.stream);\n              this.analyser = this.audioContext.createAnalyser();\n              this.analyser.fftSize = this.fftSize * 2;\n              this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n              streamSource.connect(this.analyser);\n              this.freqData = new Float32Array(this.fftSize);\n              this.timeData = new Float32Array(this.fftSize);\n              return _context.abrupt(\"return\");\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var spectrogramTensor, waveformTensor, audioDataQueue, freqData, timeData;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!this.isClosed) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 2:\n              _context2.next = 4;\n              return this.getAudioData();\n            case 4:\n              audioDataQueue = _context2.sent;\n              if (this.includeSpectrogram) {\n                freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n                spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n              }\n              if (this.includeWaveform) {\n                timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n                waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n              }\n              return _context2.abrupt(\"return\", {\n                value: {\n                  'spectrogram': spectrogramTensor,\n                  'waveform': waveformTensor\n                },\n                done: false\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function next() {\n        return _next.apply(this, arguments);\n      }\n      return next;\n    }() // Capture one result from the audio stream, and extract the value from\n    // iterator.next() result.\n  }, {\n    key: \"capture\",\n    value: function () {\n      var _capture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.next();\n            case 2:\n              return _context3.abrupt(\"return\", _context3.sent.value);\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function capture() {\n        return _capture.apply(this, arguments);\n      }\n      return capture;\n    }()\n  }, {\n    key: \"getAudioData\",\n    value: function () {\n      var _getAudioData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n        var freqDataQueue, timeDataQueue, currentFrames;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              freqDataQueue = [];\n              timeDataQueue = [];\n              currentFrames = 0;\n              return _context4.abrupt(\"return\", new Promise(function (resolve) {\n                var intervalID = setInterval(function () {\n                  if (_this2.includeSpectrogram) {\n                    _this2.analyser.getFloatFrequencyData(_this2.freqData);\n                    // If the audio stream is initializing, return empty queue.\n                    if (_this2.freqData[0] === -Infinity) {\n                      resolve({\n                        freqDataQueue: freqDataQueue,\n                        timeDataQueue: timeDataQueue\n                      });\n                    }\n                    freqDataQueue.push(_this2.freqData.slice(0, _this2.columnTruncateLength));\n                  }\n                  if (_this2.includeWaveform) {\n                    _this2.analyser.getFloatTimeDomainData(_this2.timeData);\n                    timeDataQueue.push(_this2.timeData.slice());\n                  }\n                  // Clean interval and return when all frames have been collected\n                  if (++currentFrames === _this2.numFrames) {\n                    clearInterval(intervalID);\n                    resolve({\n                      freqDataQueue: freqDataQueue,\n                      timeDataQueue: timeDataQueue\n                    });\n                  }\n                }, _this2.fftSize / _this2.sampleRateHz * 1e3);\n              }));\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function getAudioData() {\n        return _getAudioData.apply(this, arguments);\n      }\n      return getAudioData;\n    }() // Stop the audio stream and pause the iterator.\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.isClosed) {\n        this.isClosed = true;\n        this.analyser.disconnect();\n        this.audioContext.close();\n        if (this.stream != null && this.stream.getTracks().length > 0) {\n          this.stream.getTracks()[0].stop();\n        }\n      }\n    }\n    // Override toArray() function to prevent collecting.\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      throw new Error('Can not convert infinite audio stream to array.');\n    }\n    // Return audio sampling rate in Hz\n  }, {\n    key: \"getSampleRate\",\n    value: function getSampleRate() {\n      return this.sampleRateHz;\n    }\n  }, {\n    key: \"flattenQueue\",\n    value: function flattenQueue(queue) {\n      var frameSize = queue[0].length;\n      var freqData = new Float32Array(queue.length * frameSize);\n      queue.forEach(function (data, i) {\n        return freqData.set(data, i * frameSize);\n      });\n      return freqData;\n    }\n  }, {\n    key: \"getTensorFromAudioDataArray\",\n    value: function getTensorFromAudioDataArray(freqData, shape) {\n      var vals = new Float32Array(util.sizeFromShape(shape));\n      // If the data is less than the output shape, the rest is padded with zeros.\n      vals.set(freqData, vals.length - freqData.length);\n      return tensor(vals, shape);\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var microphoneConfig,\n          microphoneIterator,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              microphoneConfig = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n              if (env().get('IS_BROWSER')) {\n                _context5.next = 3;\n                break;\n              }\n              throw new Error('microphone API is only supported in browser environment.');\n            case 3:\n              microphoneIterator = new MicrophoneIterator(microphoneConfig); // Call async function start() to initialize the audio stream.\n              _context5.next = 6;\n              return microphoneIterator.start();\n            case 6:\n              return _context5.abrupt(\"return\", microphoneIterator);\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      function create() {\n        return _create.apply(this, arguments);\n      }\n      return create;\n    }()\n  }]);\n  return MicrophoneIterator;\n}(LazyIterator);","map":{"version":3,"names":["env","tensor","util","LazyIterator","MicrophoneIterator","_LazyIterator","_inherits","_super","_createSuper","microphoneConfig","_this","_classCallCheck","call","isClosed","fftSize","fftSizeLog2","Math","log2","Number","isInteger","Error","concat","numFrames","numFramesPerSpectrogram","sampleRateHz","columnTruncateLength","audioTrackConstraints","smoothingTimeConstant","includeSpectrogram","includeWaveform","_createClass","key","value","summary","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","ctxConstructor","streamSource","wrap","_callee$","_context","prev","next","navigator","mediaDevices","getUserMedia","audio","video","stream","sent","t0","message","window","AudioContext","webkitAudioContext","audioContext","sampleRate","createMediaStreamSource","analyser","createAnalyser","connect","freqData","Float32Array","timeData","abrupt","stop","start","apply","arguments","_next","_callee2","spectrogramTensor","waveformTensor","audioDataQueue","_callee2$","_context2","done","getAudioData","flattenQueue","freqDataQueue","getTensorFromAudioDataArray","timeDataQueue","_capture","_callee3","_callee3$","_context3","capture","_getAudioData","_callee4","_this2","currentFrames","_callee4$","_context4","Promise","resolve","intervalID","setInterval","getFloatFrequencyData","Infinity","push","slice","getFloatTimeDomainData","clearInterval","disconnect","close","getTracks","length","toArray","getSampleRate","queue","frameSize","forEach","data","i","set","shape","vals","sizeFromShape","_create","_callee5","microphoneIterator","_args5","_callee5$","_context5","undefined","get","create"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-data\\src\\iterators\\microphone_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {env, Tensor, tensor, Tensor2D, Tensor3D, TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {MicrophoneConfig} from '../types';\nimport {LazyIterator} from './lazy_iterator';\n\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator<TensorContainer> {\n  private isClosed = false;\n  private stream: MediaStream;\n  private readonly fftSize: number;\n  private readonly columnTruncateLength: number;\n  private freqData: Float32Array;\n  private timeData: Float32Array;\n  private readonly numFrames: number;\n  private analyser: AnalyserNode;\n  private audioContext: AudioContext;\n  private sampleRateHz: number;\n  private readonly audioTrackConstraints: MediaTrackConstraints;\n  private readonly smoothingTimeConstant: number;\n  private readonly includeSpectrogram: boolean;\n  private readonly includeWaveform: boolean;\n\n  private constructor(protected readonly microphoneConfig: MicrophoneConfig) {\n    super();\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n        !Number.isInteger(fftSizeLog2)) {\n      throw new Error(\n          `Invalid fftSize: it must be a power of 2 between ` +\n          `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength =\n        microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n\n    this.includeSpectrogram =\n        microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform =\n        microphoneConfig.includeWaveform === true ? true : false;\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error(\n          'Both includeSpectrogram and includeWaveform are false. ' +\n          'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  }\n\n  // Construct a MicrophoneIterator and start the audio stream.\n  static async create(microphoneConfig: MicrophoneConfig = {}) {\n    if (!env().get('IS_BROWSER')) {\n      throw new Error(\n          'microphone API is only supported in browser environment.');\n    }\n\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n\n    // Call async function start() to initialize the audio stream.\n    await microphoneIterator.start();\n\n    return microphoneIterator;\n  }\n\n  // Start the audio stream and FFT.\n  async start(): Promise<void> {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true :\n                                                    this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(\n          `Error thrown while initializing video stream: ${e.message}`);\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n\n    const ctxConstructor =\n        // tslint:disable-next-line:no-any\n        (window as any).AudioContext || (window as any).webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(\n          `Mismatch in sampling rate: ` +\n          `Expected: ${this.sampleRateHz}; ` +\n          `Actual: ${this.audioContext.sampleRate}`);\n    }\n\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n\n  async next(): Promise<IteratorResult<TensorContainer>> {\n    if (this.isClosed) {\n      return {value: null, done: true};\n    }\n\n    let spectrogramTensor: Tensor;\n    let waveformTensor: Tensor;\n\n    const audioDataQueue = await this.getAudioData();\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(\n          freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(\n          timeData, [this.numFrames * this.fftSize, 1]);\n    }\n\n    return {\n      value: {'spectrogram': spectrogramTensor, 'waveform': waveformTensor},\n      done: false\n    };\n  }\n\n  // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n  async capture(): Promise<{spectrogram: Tensor3D, waveform: Tensor2D}> {\n    return (await this.next()).value as\n        {spectrogram: Tensor3D, waveform: Tensor2D};\n  }\n\n  private async getAudioData():\n      Promise<{freqDataQueue: Float32Array[], timeDataQueue: Float32Array[]}> {\n    const freqDataQueue: Float32Array[] = [];\n    const timeDataQueue: Float32Array[] = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData);\n          // If the audio stream is initializing, return empty queue.\n          if (this.freqData[0] === -Infinity) {\n            resolve({freqDataQueue, timeDataQueue});\n          }\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        }\n\n        // Clean interval and return when all frames have been collected\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({freqDataQueue, timeDataQueue});\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  }\n\n  // Stop the audio stream and pause the iterator.\n  stop(): void {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  }\n\n  // Override toArray() function to prevent collecting.\n  override toArray(): Promise<Tensor[]> {\n    throw new Error('Can not convert infinite audio stream to array.');\n  }\n\n  // Return audio sampling rate in Hz\n  getSampleRate(): number {\n    return this.sampleRateHz;\n  }\n\n  private flattenQueue(queue: Float32Array[]): Float32Array {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  private getTensorFromAudioDataArray(freqData: Float32Array, shape: number[]):\n      Tensor {\n    const vals = new Float32Array(util.sizeFromShape(shape));\n    // If the data is less than the output shape, the rest is padded with zeros.\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}