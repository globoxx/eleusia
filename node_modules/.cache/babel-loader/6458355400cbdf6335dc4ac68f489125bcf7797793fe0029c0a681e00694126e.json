{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { FromPixels } from '@tensorflow/tfjs-core';\nimport { TextureUsage } from '../tex_util';\nimport { FromPixelsProgram } from './FromPixels_utils/from_pixels_gpu';\nimport { FromPixelsPackedProgram } from './FromPixels_utils/from_pixels_packed_gpu';\nexport var fromPixelsConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels\n};\nvar fromPixels2DContext;\nvar willReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\nfunction fromPixels(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var pixels = inputs.pixels;\n  var numChannels = attrs.numChannels;\n  var isVideo = typeof HTMLVideoElement !== 'undefined' && pixels instanceof HTMLVideoElement;\n  var isImage = typeof HTMLImageElement !== 'undefined' && pixels instanceof HTMLImageElement;\n  var _ref = isVideo ? [pixels.videoWidth, pixels.videoHeight] : [pixels.width, pixels.height],\n    _ref2 = _slicedToArray(_ref, 2),\n    width = _ref2[0],\n    height = _ref2[1];\n  var texShape = [height, width];\n  var outShape = [height, width, numChannels];\n  if (isImage || isVideo) {\n    var newWillReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n    if (fromPixels2DContext == null || newWillReadFrequently !== willReadFrequently) {\n      willReadFrequently = newWillReadFrequently;\n      fromPixels2DContext = document.createElement('canvas').getContext('2d', {\n        willReadFrequently: willReadFrequently\n      });\n    }\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(pixels, 0, 0, width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n  var tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n  // This is a byte texture with pixels.\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);\n  var program = env().getBool('WEBGL_PACK') ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);\n  var res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}","map":{"version":3,"names":["env","FromPixels","TextureUsage","FromPixelsProgram","FromPixelsPackedProgram","fromPixelsConfig","kernelName","backendName","kernelFunc","fromPixels","fromPixels2DContext","willReadFrequently","getBool","args","inputs","backend","attrs","pixels","numChannels","isVideo","HTMLVideoElement","isImage","HTMLImageElement","_ref","videoWidth","videoHeight","width","height","_ref2","_slicedToArray","texShape","outShape","newWillReadFrequently","document","createElement","getContext","canvas","drawImage","tempPixelHandle","makeTensorInfo","texData","get","dataId","usage","PIXELS","gpgpu","uploadPixelDataToTexture","getTexture","program","res","runWebGLProgram","disposeData"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\kernels\\FromPixels.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TextureUsage} from '../tex_util';\n\nimport {FromPixelsProgram} from './FromPixels_utils/from_pixels_gpu';\nimport {FromPixelsPackedProgram} from './FromPixels_utils/from_pixels_packed_gpu';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels as unknown as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\nlet willReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n\nfunction fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: MathBackendWebGL,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n\n  const texShape: [number, number] = [height, width];\n  const outShape = [height, width, numChannels];\n\n  if (isImage || isVideo) {\n    const newWillReadFrequently =\n        env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n    if (fromPixels2DContext == null ||\n        newWillReadFrequently !== willReadFrequently) {\n      willReadFrequently = newWillReadFrequently;\n      fromPixels2DContext =\n          document.createElement('canvas').getContext(\n              '2d', {willReadFrequently});\n    }\n\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement | HTMLImageElement | ImageBitmap, 0, 0,\n        width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n  // This is a byte texture with pixels.\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(\n      backend.getTexture(tempPixelHandle.dataId), pixels as ImageData);\n  const program = env().getBool('WEBGL_PACK') ?\n      new FromPixelsPackedProgram(outShape) :\n      new FromPixelsProgram(outShape);\n  const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}