{"ast":null,"code":"import _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nvar FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nvar FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nvar FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  var strides = computeStrides(shape);\n  var padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  var rank = shape.length;\n  var valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  var lines = ['Tensor'];\n  if (verbose) {\n    lines.push(\"  dtype: \".concat(dtype));\n    lines.push(\"  rank: \".concat(rank));\n    lines.push(\"  shape: [\".concat(shape, \"]\"));\n    lines.push(\"  values:\");\n  }\n  lines.push(valsLines.map(function (l) {\n    return '    ' + l;\n  }).join('\\n'));\n  return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  var n = sizeFromShape(shape);\n  var numCols = strides[strides.length - 1];\n  var padPerCol = new Array(numCols).fill(0);\n  var rank = shape.length;\n  var valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n  if (rank > 1) {\n    for (var row = 0; row < n / numCols; row++) {\n      var offset = row * numCols;\n      for (var j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n  return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n  var valStr;\n  if (Array.isArray(val)) {\n    valStr = \"\".concat(parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS)), \" + \") + \"\".concat(parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS)), \"j\");\n  } else if (isString(val)) {\n    valStr = \"'\".concat(val, \"'\");\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n  return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol) {\n  var isLast = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var storagePerElement = dtype === 'complex64' ? 2 : 1;\n  var size = shape[0];\n  var rank = shape.length;\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      var complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n    return [vals[0].toString()];\n  }\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      var firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      var firstVals = Array.from(vals.slice(0, firstValsSize));\n      var lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n      return ['[' + firstVals.map(function (x, i) {\n        return valToString(x, padPerCol[i], dtype);\n      }).join(', ') + ', ..., ' + lastVals.map(function (x, i) {\n        return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype);\n      }).join(', ') + ']'];\n    }\n    var displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map(function (x, i) {\n      return valToString(x, padPerCol[i], dtype);\n    }).join(', ') + ']'];\n  }\n  // The array is rank 2 or more.\n  var subshape = shape.slice(1);\n  var substrides = strides.slice(1);\n  var stride = strides[0] * storagePerElement;\n  var lines = [];\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      var start = i * stride;\n      var end = start + stride;\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */)));\n    }\n\n    lines.push('...');\n    for (var _i = size - FORMAT_NUM_FIRST_LAST_VALS; _i < size; _i++) {\n      var _start = _i * stride;\n      var _end = _start + stride;\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(_start, _end), subshape, dtype, substrides, padPerCol, _i === size - 1 /* isLast */)));\n    }\n  } else {\n    for (var _i2 = 0; _i2 < size; _i2++) {\n      var _start2 = _i2 * stride;\n      var _end2 = _start2 + stride;\n      lines.push.apply(lines, _toConsumableArray(subTensorToString(vals.slice(_start2, _end2), subshape, dtype, substrides, padPerCol, _i2 === size - 1 /* isLast */)));\n    }\n  }\n\n  var sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + (size > 0 ? lines[0] + sep : '');\n  for (var _i3 = 1; _i3 < lines.length - 1; _i3++) {\n    lines[_i3] = ' ' + lines[_i3] + sep;\n  }\n  var newLineSep = ',\\n';\n  for (var _i4 = 2; _i4 < rank; _i4++) {\n    newLineSep += '\\n';\n  }\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\nfunction createComplexTuples(vals) {\n  var complexTuples = [];\n  for (var i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n  return complexTuples;\n}","map":{"version":3,"names":["computeStrides","isString","rightPad","sizeFromShape","FORMAT_LIMIT_NUM_VALS","FORMAT_NUM_FIRST_LAST_VALS","FORMAT_NUM_SIG_DIGITS","tensorToString","vals","shape","dtype","verbose","strides","padPerCol","computeMaxSizePerColumn","rank","length","valsLines","subTensorToString","lines","push","concat","map","l","join","n","numCols","Array","fill","valuesOrTuples","createComplexTuples","row","offset","j","Math","max","valToString","val","pad","valStr","isArray","parseFloat","toFixed","boolNumToString","toString","v","isLast","arguments","undefined","storagePerElement","size","complexTuple","firstValsSize","firstVals","from","slice","lastVals","x","i","displayVals","subshape","substrides","stride","start","end","apply","_toConsumableArray","sep","newLineSep","complexTuples"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\tensor_format.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray} from './types';\nimport {computeStrides, isString, rightPad, sizeFromShape} from './util';\n\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\n\nexport function tensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    verbose: boolean) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[]): number[] {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples =\n      dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(\n            padPerCol[j],\n            valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n  return padPerCol;\n}\n\nfunction valToString(\n    val: number|string|[number, number], pad: number, dtype: DataType) {\n  let valStr: string;\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n        `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v: number): string {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[], padPerCol: number[], isLast = true): string[] {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n\n  const size = shape[0];\n  const rank = shape.length;\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0] as number)];\n    }\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n\n      let firstVals = Array.from<number|string|[number, number]>(\n          vals.slice(0, firstValsSize));\n      let lastVals = Array.from<number|string|[number, number]>(vals.slice(\n          (size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement,\n          size * storagePerElement));\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n      return [\n        '[' +\n        firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n            .join(', ') +\n        ', ..., ' +\n        lastVals\n            .map(\n                (x, i) => valToString(\n                    x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n            .join(', ') +\n        ']'\n      ];\n    }\n    const displayVals: Array<number|string|[number, number]> =\n        dtype === 'complex64' ? createComplexTuples(vals) :\n                                Array.from<number|string>(vals);\n\n    return [\n      '[' +\n      displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n          .join(', ') +\n      ']'\n    ];\n  }\n\n  // The array is rank 2 or more.\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines: string[] = [];\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          false /* isLast */));\n    }\n    lines.push('...');\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  }\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + (size > 0 ? lines[0] + sep : '');\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n  let newLineSep = ',\\n';\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n  lines[lines.length - 1] =\n      ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals: Array<{}>|\n                             TypedArray): Array<[number, number]> {\n  const complexTuples: Array<[number, number]> = [];\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]] as [number, number]);\n  }\n  return complexTuples;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}