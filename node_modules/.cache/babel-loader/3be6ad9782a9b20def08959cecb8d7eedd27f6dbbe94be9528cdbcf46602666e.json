{"ast":null,"code":"import _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\r\n * @license\r\n * Copyright 2023 CodeSmith LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\nimport { image, serialization, tidy } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor, getExactlyOneShape } from '../../utils/types_utils';\nimport { ValueError } from '../../errors';\nimport { BaseRandomLayer } from '../../engine/base_random_layer';\nimport { randomUniform } from '@tensorflow/tfjs-core';\nvar INTERPOLATION_KEYS = ['bilinear', 'nearest'];\nexport var INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\n/**\r\n * Preprocessing Layer with randomly varies image during training\r\n *\r\n * This layer randomly adjusts the width of a batch of images of a\r\n * batch of images by a random factor.\r\n *\r\n * The input should be a 3D (unbatched) or\r\n * 4D (batched) tensor in the `\"channels_last\"` image data format. Input pixel\r\n * values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and of interger\r\n * or floating point dtype. By default, the layer will output floats.\r\n *\r\n * tf methods implemented in tfjs: 'bilinear', 'nearest',\r\n * tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\r\n *                                   'gaussian', 'mitchellcubic'\r\n *\r\n */\nexport var RandomWidth = /*#__PURE__*/function (_BaseRandomLayer) {\n  _inherits(RandomWidth, _BaseRandomLayer);\n  var _super = _createSuper(RandomWidth);\n  function RandomWidth(args) {\n    var _this;\n    _classCallCheck(this, RandomWidth);\n    _this = _super.call(this, args);\n    var factor = args.factor,\n      _args$interpolation = args.interpolation,\n      interpolation = _args$interpolation === void 0 ? 'bilinear' : _args$interpolation;\n    _this.factor = factor;\n    if (Array.isArray(_this.factor) && _this.factor.length === 2) {\n      _this.widthLower = _this.factor[0];\n      _this.widthUpper = _this.factor[1];\n    } else if (!Array.isArray(_this.factor) && _this.factor > 0) {\n      _this.widthLower = -_this.factor;\n      _this.widthUpper = _this.factor;\n    } else {\n      throw new ValueError(\"Invalid factor: \".concat(_this.factor, \". Must be positive number or tuple of 2 numbers\"));\n    }\n    if (_this.widthLower < -1.0 || _this.widthUpper < -1.0) {\n      throw new ValueError(\"factor must have values larger than -1. Got: \".concat(_this.factor));\n    }\n    if (_this.widthUpper < _this.widthLower) {\n      throw new ValueError(\"factor cannot have upper bound less than lower bound.\\n        Got upper bound: \".concat(_this.widthUpper, \".\\n        Got lower bound: \").concat(_this.widthLower, \"\\n      \"));\n    }\n    if (interpolation) {\n      if (INTERPOLATION_METHODS.has(interpolation)) {\n        _this.interpolation = interpolation;\n      } else {\n        throw new ValueError(\"Invalid interpolation parameter: \".concat(interpolation, \" is not implemented\"));\n      }\n    }\n    return _this;\n  }\n  _createClass(RandomWidth, [{\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        'factor': this.factor,\n        'interpolation': this.interpolation\n      };\n      var baseConfig = _get(_getPrototypeOf(RandomWidth.prototype), \"getConfig\", this).call(this);\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }, {\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var numChannels = inputShape[2];\n      return [this.imgHeight, -1, numChannels];\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this2 = this;\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        _this2.imgHeight = input.shape[input.shape.length - 3];\n        var imgWidth = input.shape[input.shape.length - 2];\n        _this2.widthFactor = randomUniform([1], 1.0 + _this2.widthLower, 1.0 + _this2.widthUpper, 'float32', _this2.randomGenerator.next());\n        var adjustedWidth = _this2.widthFactor.dataSync()[0] * imgWidth;\n        adjustedWidth = Math.round(adjustedWidth);\n        var size = [_this2.imgHeight, adjustedWidth];\n        switch (_this2.interpolation) {\n          case 'bilinear':\n            return image.resizeBilinear(inputs, size);\n          case 'nearest':\n            return image.resizeNearestNeighbor(inputs, size);\n          default:\n            throw new Error(\"Interpolation is \".concat(_this2.interpolation, \"\\n          but only \").concat(_toConsumableArray(INTERPOLATION_METHODS), \" are supported\"));\n        }\n      });\n    }\n  }]);\n  return RandomWidth;\n}(BaseRandomLayer);\n/** @nocollapse */\nRandomWidth.className = 'RandomWidth';\nserialization.registerClass(RandomWidth);","map":{"version":3,"names":["image","serialization","tidy","getExactlyOneTensor","getExactlyOneShape","ValueError","BaseRandomLayer","randomUniform","INTERPOLATION_KEYS","INTERPOLATION_METHODS","Set","RandomWidth","_BaseRandomLayer","_inherits","_super","_createSuper","args","_this","_classCallCheck","call","factor","_args$interpolation","interpolation","Array","isArray","length","widthLower","widthUpper","concat","has","_createClass","key","value","getConfig","config","baseConfig","_get","_getPrototypeOf","prototype","Object","assign","computeOutputShape","inputShape","numChannels","imgHeight","inputs","kwargs","_this2","input","shape","imgWidth","widthFactor","randomGenerator","next","adjustedWidth","dataSync","Math","round","size","resizeBilinear","resizeNearestNeighbor","Error","_toConsumableArray","className","registerClass"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-layers\\src\\layers\\preprocessing\\random_width.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport { image, Rank, serialization, Tensor, tidy } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor, getExactlyOneShape } from '../../utils/types_utils';\nimport { Shape } from '../../keras_format/common';\nimport { Kwargs } from '../../types';\nimport { ValueError } from '../../errors';\nimport { BaseRandomLayerArgs, BaseRandomLayer } from '../../engine/base_random_layer';\nimport { randomUniform } from '@tensorflow/tfjs-core';\n\nexport declare interface RandomWidthArgs extends BaseRandomLayerArgs {\n   factor: number | [number, number];\n   interpolation?: InterpolationType; // default = 'bilinear';\n   seed?: number; // default = null;\n   autoVectorize?: boolean;\n}\n\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'] as const;\nexport const INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\ntype InterpolationType = typeof INTERPOLATION_KEYS[number];\n\n/**\n * Preprocessing Layer with randomly varies image during training\n *\n * This layer randomly adjusts the width of a batch of images of a\n * batch of images by a random factor.\n *\n * The input should be a 3D (unbatched) or\n * 4D (batched) tensor in the `\"channels_last\"` image data format. Input pixel\n * values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and of interger\n * or floating point dtype. By default, the layer will output floats.\n *\n * tf methods implemented in tfjs: 'bilinear', 'nearest',\n * tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n *                                   'gaussian', 'mitchellcubic'\n *\n */\n\nexport class RandomWidth extends BaseRandomLayer {\n  /** @nocollapse */\n  static override className = 'RandomWidth';\n  private readonly factor: number | [number, number];\n  private readonly interpolation?: InterpolationType;  // defualt = 'bilinear\n  private widthLower: number;\n  private widthUpper: number;\n  private imgHeight: number;\n  private widthFactor: Tensor<Rank.R1>;\n\n  constructor(args: RandomWidthArgs) {\n    super(args);\n    const {factor, interpolation = 'bilinear'} = args;\n\n    this.factor = factor;\n\n    if (Array.isArray(this.factor) && this.factor.length === 2) {\n      this.widthLower = this.factor[0];\n      this.widthUpper = this.factor[1];\n    } else if (!Array.isArray(this.factor) && this.factor > 0){\n      this.widthLower = -this.factor;\n      this.widthUpper = this.factor;\n    } else {\n      throw new ValueError(\n        `Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`\n      );\n    }\n    if (this.widthLower < -1.0 || this.widthUpper < -1.0) {\n      throw new ValueError(\n        `factor must have values larger than -1. Got: ${this.factor}`\n      );\n    }\n\n    if (this.widthUpper < this.widthLower) {\n      throw new ValueError(\n        `factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);\n    }\n\n    if (interpolation) {\n      if (INTERPOLATION_METHODS.has(interpolation)) {\n        this.interpolation = interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${\n            interpolation} is not implemented`);\n      }\n    } \n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'factor': this.factor,\n      'interpolation': this.interpolation,\n    };\n\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.imgHeight, -1, numChannels];\n  }\n\n  override call(inputs: Tensor<Rank.R3>|Tensor<Rank.R4>,\n    kwargs: Kwargs): Tensor[]|Tensor {\n\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      this.imgHeight = input.shape[input.shape.length - 3];\n      const imgWidth = input.shape[input.shape.length - 2];\n\n      this.widthFactor = randomUniform([1],\n        (1.0 + this.widthLower), (1.0 + this.widthUpper),\n        'float32', this.randomGenerator.next()\n      );\n\n      let adjustedWidth = this.widthFactor.dataSync()[0] * imgWidth;\n      adjustedWidth = Math.round(adjustedWidth);\n\n      const size:[number, number] = [this.imgHeight, adjustedWidth];\n\n      switch (this.interpolation) {\n        case 'bilinear':\n          return image.resizeBilinear(inputs, size);\n        case 'nearest':\n          return image.resizeNearestNeighbor(inputs, size);\n        default:\n          throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n\nserialization.registerClass(RandomWidth);\n"],"mappings":";;;;;;;AAAA;;;;;;;;;AAUA,SAASA,KAAK,EAAQC,aAAa,EAAUC,IAAI,QAAQ,uBAAuB;AAChF,SAASC,mBAAmB,EAAEC,kBAAkB,QAAQ,yBAAyB;AAGjF,SAASC,UAAU,QAAQ,cAAc;AACzC,SAA8BC,eAAe,QAAQ,gCAAgC;AACrF,SAASC,aAAa,QAAQ,uBAAuB;AASrD,IAAMC,kBAAkB,GAAG,CAAC,UAAU,EAAE,SAAS,CAAU;AAC3D,OAAO,IAAMC,qBAAqB,GAAG,IAAIC,GAAG,CAACF,kBAAkB,CAAC;AAGhE;;;;;;;;;;;;;;;;AAiBA,WAAaG,WAAY,0BAAAC,gBAAA;EAAAC,SAAA,CAAAF,WAAA,EAAAC,gBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,WAAA;EAUvB,SAAAA,YAAYK,IAAqB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,WAAA;IAC/BM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAMH,IAAI;IACV,IAAOI,MAAM,GAAgCJ,IAAI,CAA1CI,MAAM;MAAAC,mBAAA,GAAgCL,IAAI,CAAlCM,aAAa;MAAbA,aAAa,GAAAD,mBAAA,cAAG,UAAU,GAAAA,mBAAA;IAEzCJ,KAAA,CAAKG,MAAM,GAAGA,MAAM;IAEpB,IAAIG,KAAK,CAACC,OAAO,CAACP,KAAA,CAAKG,MAAM,CAAC,IAAIH,KAAA,CAAKG,MAAM,CAACK,MAAM,KAAK,CAAC,EAAE;MAC1DR,KAAA,CAAKS,UAAU,GAAGT,KAAA,CAAKG,MAAM,CAAC,CAAC,CAAC;MAChCH,KAAA,CAAKU,UAAU,GAAGV,KAAA,CAAKG,MAAM,CAAC,CAAC,CAAC;KACjC,MAAM,IAAI,CAACG,KAAK,CAACC,OAAO,CAACP,KAAA,CAAKG,MAAM,CAAC,IAAIH,KAAA,CAAKG,MAAM,GAAG,CAAC,EAAC;MACxDH,KAAA,CAAKS,UAAU,GAAG,CAACT,KAAA,CAAKG,MAAM;MAC9BH,KAAA,CAAKU,UAAU,GAAGV,KAAA,CAAKG,MAAM;KAC9B,MAAM;MACL,MAAM,IAAIf,UAAU,oBAAAuB,MAAA,CACCX,KAAA,CAAKG,MAAM,qDAC/B;;IAEH,IAAIH,KAAA,CAAKS,UAAU,GAAG,CAAC,GAAG,IAAIT,KAAA,CAAKU,UAAU,GAAG,CAAC,GAAG,EAAE;MACpD,MAAM,IAAItB,UAAU,iDAAAuB,MAAA,CAC8BX,KAAA,CAAKG,MAAM,EAC5D;;IAGH,IAAIH,KAAA,CAAKU,UAAU,GAAGV,KAAA,CAAKS,UAAU,EAAE;MACrC,MAAM,IAAIrB,UAAU,oFAAAuB,MAAA,CAECX,KAAA,CAAKU,UAAU,kCAAAC,MAAA,CACfX,KAAA,CAAKS,UAAU,cAClC;;IAGJ,IAAIJ,aAAa,EAAE;MACjB,IAAIb,qBAAqB,CAACoB,GAAG,CAACP,aAAa,CAAC,EAAE;QAC5CL,KAAA,CAAKK,aAAa,GAAGA,aAAa;OACnC,MAAM;QACL,MAAM,IAAIjB,UAAU,qCAAAuB,MAAA,CAChBN,aAAa,yBAAsB;;;IAE1C,OAAAL,KAAA;EACH;EAACa,YAAA,CAAAnB,WAAA;IAAAoB,GAAA;IAAAC,KAAA,EAEQ,SAAAC,UAAA,EAAS;MAChB,IAAMC,MAAM,GAA6B;QACvC,QAAQ,EAAE,IAAI,CAACd,MAAM;QACrB,eAAe,EAAE,IAAI,CAACE;OACvB;MAED,IAAMa,UAAU,GAAAC,IAAA,CAAAC,eAAA,CAAA1B,WAAA,CAAA2B,SAAA,sBAAAnB,IAAA,MAAoB;MACpCoB,MAAM,CAACC,MAAM,CAACN,MAAM,EAAEC,UAAU,CAAC;MACjC,OAAOD,MAAM;IACf;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAEQ,SAAAS,mBAAmBC,UAAyB;MACnDA,UAAU,GAAGtC,kBAAkB,CAACsC,UAAU,CAAC;MAC3C,IAAMC,WAAW,GAAGD,UAAU,CAAC,CAAC,CAAC;MACjC,OAAO,CAAC,IAAI,CAACE,SAAS,EAAE,CAAC,CAAC,EAAED,WAAW,CAAC;IAC1C;EAAC;IAAAZ,GAAA;IAAAC,KAAA,EAEQ,SAAAb,KAAK0B,MAAuC,EACnDC,MAAc;MAAA,IAAAC,MAAA;MAEd,OAAO7C,IAAI,CAAC,YAAK;QACf,IAAM8C,KAAK,GAAG7C,mBAAmB,CAAC0C,MAAM,CAAC;QACzCE,MAAI,CAACH,SAAS,GAAGI,KAAK,CAACC,KAAK,CAACD,KAAK,CAACC,KAAK,CAACxB,MAAM,GAAG,CAAC,CAAC;QACpD,IAAMyB,QAAQ,GAAGF,KAAK,CAACC,KAAK,CAACD,KAAK,CAACC,KAAK,CAACxB,MAAM,GAAG,CAAC,CAAC;QAEpDsB,MAAI,CAACI,WAAW,GAAG5C,aAAa,CAAC,CAAC,CAAC,CAAC,EACjC,GAAG,GAAGwC,MAAI,CAACrB,UAAU,EAAI,GAAG,GAAGqB,MAAI,CAACpB,UAAU,EAC/C,SAAS,EAAEoB,MAAI,CAACK,eAAe,CAACC,IAAI,EAAE,CACvC;QAED,IAAIC,aAAa,GAAGP,MAAI,CAACI,WAAW,CAACI,QAAQ,EAAE,CAAC,CAAC,CAAC,GAAGL,QAAQ;QAC7DI,aAAa,GAAGE,IAAI,CAACC,KAAK,CAACH,aAAa,CAAC;QAEzC,IAAMI,IAAI,GAAoB,CAACX,MAAI,CAACH,SAAS,EAAEU,aAAa,CAAC;QAE7D,QAAQP,MAAI,CAACzB,aAAa;UACxB,KAAK,UAAU;YACb,OAAOtB,KAAK,CAAC2D,cAAc,CAACd,MAAM,EAAEa,IAAI,CAAC;UAC3C,KAAK,SAAS;YACZ,OAAO1D,KAAK,CAAC4D,qBAAqB,CAACf,MAAM,EAAEa,IAAI,CAAC;UAClD;YACE,MAAM,IAAIG,KAAK,qBAAAjC,MAAA,CAAqBmB,MAAI,CAACzB,aAAa,2BAAAM,MAAA,CAAAkC,kBAAA,CACvCrD,qBAAqB,qBAAkB;QAAC;MAE7D,CAAC,CAAC;IACJ;EAAC;EAAA,OAAAE,WAAA;AAAA,EAhG8BL,eAAe;AAC9C;AACgBK,WAAA,CAAAoD,SAAS,GAAG,aAAa;AAiG3C9D,aAAa,CAAC+D,aAAa,CAACrD,WAAW,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}