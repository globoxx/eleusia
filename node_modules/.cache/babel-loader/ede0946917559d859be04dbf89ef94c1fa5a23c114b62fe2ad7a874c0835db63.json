{"ast":null,"code":"import _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  var usedNodes = new Set();\n  var missingInputs = [];\n  var dynamicNode = null;\n  var syncInputs = null;\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  var seen = new Set();\n  var inputNodeNames = new Set(Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  }));\n  initNodes = initNodes || [];\n  var initNodeNames = new Set(initNodes.map(function (node) {\n    return parseNodeName(node.name)[0];\n  }));\n  var frontier = _toConsumableArray(outputs);\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(function (child) {\n          return child.name;\n        }).filter(function (name) {\n          return usedNodes.has(name);\n        });\n      }\n    }\n    usedNodes.add(node.name);\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(function (input) {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {\n    inputs: inputs,\n    outputs: outputs,\n    usedNodes: usedNodes,\n    missingInputs: missingInputs,\n    dynamicNode: dynamicNode,\n    syncInputs: syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, executionInfo) {\n  var usedNodes = executionInfo.usedNodes,\n    inputs = executionInfo.inputs;\n  var inputNodes = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  }).map(function (name) {\n    return graph.nodes[name];\n  });\n  var initNodes = graph.initNodes || [];\n  var isUsed = function isUsed(node) {\n    return usedNodes.has(typeof node === 'string' ? node : node.name);\n  };\n  function unique(nodes) {\n    return _toConsumableArray(new Map(nodes.map(function (node) {\n      return [node.name, node];\n    })).values());\n  }\n  var predefinedNodes = unique([].concat(_toConsumableArray(inputNodes), _toConsumableArray(graph.weights), _toConsumableArray(initNodes))).filter(isUsed);\n  var allNodes = unique([].concat(_toConsumableArray(predefinedNodes), _toConsumableArray(Object.values(graph.nodes)))).filter(isUsed);\n  var nameToNode = new Map(allNodes.map(function (node) {\n    return [node.name, node];\n  }));\n  var inCounts = {};\n  var _iterator = _createForOfIteratorHelper(allNodes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _node = _step.value;\n      inCounts[_node.name] = inCounts[_node.name] || 0;\n      var _iterator3 = _createForOfIteratorHelper(_node.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _child = _step3.value;\n          // When the child is unused, set in counts to infinity so that it will\n          // never be decreased to 0 and added to the execution list.\n          if (!isUsed(_child)) {\n            inCounts[_child.name] = Number.POSITIVE_INFINITY;\n          }\n          inCounts[_child.name] = (inCounts[_child.name] || 0) + 1;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    // Build execution order for all used nodes regardless whether they are\n    // predefined or not.\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var frontier = Object.entries(inCounts).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      inCount = _ref2[1];\n    return inCount === 0;\n  }).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n      name = _ref4[0];\n    return name;\n  });\n  var orderedNodeNames = _toConsumableArray(frontier);\n  while (frontier.length > 0) {\n    var nodeName = frontier.pop();\n    var node = nameToNode.get(nodeName);\n    var _iterator2 = _createForOfIteratorHelper(node.children.filter(isUsed)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var child = _step2.value;\n        if (--inCounts[child.name] === 0) {\n          orderedNodeNames.push(child.name);\n          frontier.push(child.name);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  var orderedNodes = orderedNodeNames.map(function (name) {\n    return nameToNode.get(name);\n  });\n  var filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n  return filteredOrderedNodes;\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {\n  var nameToNode = new Map(orderedNodes.map(function (node) {\n    return [node.name, node];\n  }));\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  var stack = predefinedNodes.map(function (node) {\n    return node.name;\n  });\n  var predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    var nodeName = stack.pop();\n    var node = nameToNode.get(nodeName);\n    var _iterator4 = _createForOfIteratorHelper(node.children),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var child = _step4.value;\n        if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {\n          continue;\n        }\n        predefinedReachableNodeNames.add(child.name);\n        stack.push(child.name);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  // Filter out unreachable nodes and build the ordered node list.\n  var filteredOrderedNodes = orderedNodes.filter(function (node) {\n    return predefinedReachableNodeNames.has(node.name);\n  });\n  return filteredOrderedNodes;\n}\nvar NodesExecutionOrderError = /*#__PURE__*/function (_Error) {\n  _inherits(NodesExecutionOrderError, _Error);\n  var _super = _createSuper(NodesExecutionOrderError);\n  function NodesExecutionOrderError(message) {\n    _classCallCheck(this, NodesExecutionOrderError);\n    return _super.call(this, \"NodesExecutionOrderError: \".concat(message));\n  }\n  return _createClass(NodesExecutionOrderError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(orderedNodes, predefinedNodes) {\n  var nodeNameToOrder = new Map(orderedNodes.map(function (node, order) {\n    return [node.name, order];\n  }));\n  var predefinedNodeNames = new Set(predefinedNodes.map(function (node) {\n    return node.name;\n  }));\n  var isPredefined = function isPredefined(node) {\n    return predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  };\n  var willBeExecutedNodeNames = new Set(orderedNodes.map(function (node) {\n    return node.name;\n  }));\n  var willBeExecuted = function willBeExecuted(node) {\n    return willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n  };\n  var _iterator5 = _createForOfIteratorHelper(orderedNodes),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var node = _step5.value;\n      var _iterator6 = _createForOfIteratorHelper(node.children.filter(willBeExecuted)),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var child = _step6.value;\n          if (!nodeNameToOrder.has(child.name)) {\n            throw new NodesExecutionOrderError(\"Child \".concat(child.name, \" of node \").concat(node.name, \" is unreachable.\"));\n          }\n          if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n            throw new NodesExecutionOrderError(\"Node \".concat(node.name, \" is scheduled to run after its child \").concat(child.name, \".\"));\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      if (!isPredefined(node)) {\n        var _iterator7 = _createForOfIteratorHelper(node.inputs),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var input = _step7.value;\n            if (!nodeNameToOrder.has(input.name)) {\n              throw new NodesExecutionOrderError(\"Input \".concat(input.name, \" of node \").concat(node.name, \" is unreachable.\"));\n            }\n            if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n              throw new NodesExecutionOrderError(\"Node \".concat(node.name, \" is scheduled to run before its input \").concat(input.name, \".\"));\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n}\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes) {\n  var nodeNameToOrder = new Map(orderedNodes.map(function (node, order) {\n    return [node.name, order];\n  }));\n  var INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  var selfLifespans = orderedNodes.map(function (node, nodeOrder) {\n    return isControlFlow(node) ? INF_LIFE : nodeOrder;\n  });\n  var getSelfLifeSpan = function getSelfLifeSpan(node) {\n    var selfLife = selfLifespans[nodeNameToOrder.get(node.name)];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  var liveUntilOrders = orderedNodes.map(function (node, nodeOrder) {\n    return node.children.map(getSelfLifeSpan).reduce(function (a, b) {\n      return Math.max(a, b);\n    }, selfLifespans[nodeOrder]);\n  });\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  var liveUntilMap = new Map();\n  for (var nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    var liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    var node = orderedNodes[nodeOrder];\n    var liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name).push(node);\n  }\n  return liveUntilMap;\n}\nvar CONTROL_FLOW_OPS = new Set(['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While']);\nvar DYNAMIC_SHAPE_OPS = new Set(['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where']);\nvar HASH_TABLE_OPS = new Set(['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2']);\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.has(node.op);\n}","map":{"version":3,"names":["parseNodeName","getExecutionSubgraph","inputs","outputs","weightMap","initNodes","usedNodes","Set","missingInputs","dynamicNode","syncInputs","seen","inputNodeNames","Object","keys","map","name","initNodeNames","node","frontier","_toConsumableArray","length","pop","isControlFlow","isDynamicShape","isHashTable","children","child","filter","has","add","push","forEach","input","getNodesInTopologicalOrder","graph","executionInfo","inputNodes","nodes","isUsed","unique","Map","values","predefinedNodes","concat","weights","allNodes","nameToNode","inCounts","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","_iterator3","_step3","Number","POSITIVE_INFINITY","err","e","f","entries","_ref","_ref2","_slicedToArray","inCount","_ref3","_ref4","orderedNodeNames","nodeName","get","_iterator2","_step2","orderedNodes","filteredOrderedNodes","filterPredefinedReachableNodes","validateNodesExecutionOrder","stack","predefinedReachableNodeNames","_iterator4","_step4","NodesExecutionOrderError","_Error","_inherits","_super","_createSuper","message","_classCallCheck","call","_createClass","_wrapNativeSuper","Error","nodeNameToOrder","order","predefinedNodeNames","isPredefined","willBeExecutedNodeNames","willBeExecuted","_iterator5","_step5","_iterator6","_step6","_iterator7","_step7","getNodeLiveUntilMap","INF_LIFE","MAX_SAFE_INTEGER","selfLifespans","nodeOrder","getSelfLifeSpan","selfLife","liveUntilOrders","reduce","a","b","Math","max","liveUntilMap","liveUntilOrder","liveUntilNode","set","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","HASH_TABLE_OPS","op"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\executor\\model_analysis.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NamedTensorMap} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../data/types';\nimport {parseNodeName} from '../operations/executors/utils';\nimport {Graph, Node} from '../operations/types';\n\nexport interface ExecutionInfo {\n  inputs: NamedTensorMap;\n  outputs: Node[];\n  usedNodes: Set<string>;\n  missingInputs: string[];\n  dynamicNode: Node;\n  syncInputs: string[];\n}\n\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(\n    inputs: NamedTensorMap, outputs: Node[], weightMap: NamedTensorsMap,\n    initNodes?: Node[]): ExecutionInfo {\n  const usedNodes = new Set<string>();\n  const missingInputs: string[] = [];\n  let dynamicNode: Node = null;\n  let syncInputs: string[] = null;\n\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set<string>();\n  const inputNodeNames =\n      new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));\n\n  initNodes = initNodes || [];\n  const initNodeNames =\n      new Set(initNodes.map((node) => parseNodeName(node.name)[0]));\n\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name)\n                         .filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};\n}\n\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(\n    graph: Graph, executionInfo: ExecutionInfo): Node[] {\n  const {usedNodes, inputs} = executionInfo;\n  const inputNodes = Object.keys(inputs)\n                         .map(name => parseNodeName(name)[0])\n                         .map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes || [];\n\n  const isUsed = (node: Node|string) =>\n      usedNodes.has(typeof node === 'string' ? node : node.name);\n\n  function unique(nodes: Node[]): Node[] {\n    return [...new Map(nodes.map((node) => [node.name, node])).values()];\n  }\n  const predefinedNodes = unique([\n                            ...inputNodes,\n                            ...graph.weights,\n                            ...initNodes,\n                          ]).filter(isUsed);\n  const allNodes = unique([\n                     ...predefinedNodes,\n                     ...Object.values(graph.nodes),\n                   ]).filter(isUsed);\n  const nameToNode =\n      new Map<string, Node>(allNodes.map((node) => [node.name, node]));\n\n  const inCounts: Record<string, number> = {};\n  for (const node of allNodes) {\n    inCounts[node.name] = inCounts[node.name] || 0;\n    for (const child of node.children) {\n      // When the child is unused, set in counts to infinity so that it will\n      // never be decreased to 0 and added to the execution list.\n      if (!isUsed(child)) {\n        inCounts[child.name] = Number.POSITIVE_INFINITY;\n      }\n      inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n    }\n  }\n\n  // Build execution order for all used nodes regardless whether they are\n  // predefined or not.\n  const frontier = Object.entries(inCounts)\n                       .filter(([, inCount]) => inCount === 0)\n                       .map(([name]) => name);\n  const orderedNodeNames = [...frontier];\n  while (frontier.length > 0) {\n    const nodeName = frontier.pop();\n    const node = nameToNode.get(nodeName)!;\n    for (const child of node.children.filter(isUsed)) {\n      if (--inCounts[child.name] === 0) {\n        orderedNodeNames.push(child.name);\n        frontier.push(child.name);\n      }\n    }\n  }\n\n  const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));\n  const filteredOrderedNodes =\n      filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n\n  return filteredOrderedNodes;\n}\n\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(\n    orderedNodes: Node[], predefinedNodes: Node[]) {\n  const nameToNode =\n      new Map<string, Node>(orderedNodes.map((node) => [node.name, node]));\n\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  const stack = predefinedNodes.map((node) => node.name);\n  const predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    const nodeName = stack.pop();\n    const node = nameToNode.get(nodeName)!;\n    for (const child of node.children) {\n      if (!nameToNode.has(child.name) ||\n          predefinedReachableNodeNames.has(child.name)) {\n        continue;\n      }\n      predefinedReachableNodeNames.add(child.name);\n      stack.push(child.name);\n    }\n  }\n\n  // Filter out unreachable nodes and build the ordered node list.\n  const filteredOrderedNodes = orderedNodes.filter(\n      (node) => predefinedReachableNodeNames.has(node.name));\n\n  return filteredOrderedNodes;\n}\n\nclass NodesExecutionOrderError extends Error {\n  constructor(message: string) {\n    super(`NodesExecutionOrderError: ${message}`);\n  }\n}\n\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(\n    orderedNodes: Node[], predefinedNodes: Node[]) {\n  const nodeNameToOrder = new Map<string, number>(\n      orderedNodes.map((node, order) => [node.name, order]));\n  const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));\n  const isPredefined = (node: Node|string) =>\n      predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  const willBeExecutedNodeNames =\n      new Set(orderedNodes.map((node) => node.name));\n  const willBeExecuted = (node: Node|string) =>\n      willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n\n  for (const node of orderedNodes) {\n    for (const child of node.children.filter(willBeExecuted)) {\n      if (!nodeNameToOrder.has(child.name)) {\n        throw new NodesExecutionOrderError(\n            `Child ${child.name} of node ${node.name} is unreachable.`);\n      }\n      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n        throw new NodesExecutionOrderError(`Node ${\n            node.name} is scheduled to run after its child ${child.name}.`);\n      }\n    }\n    if (!isPredefined(node)) {\n      for (const input of node.inputs) {\n        if (!nodeNameToOrder.has(input.name)) {\n          throw new NodesExecutionOrderError(\n              `Input ${input.name} of node ${node.name} is unreachable.`);\n        }\n        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n          throw new NodesExecutionOrderError(`Node ${\n              node.name} is scheduled to run before its input ${input.name}.`);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes: Node[]): Map<string, Node[]> {\n  const nodeNameToOrder = new Map<string, number>(\n      orderedNodes.map((node, order) => [node.name, order]));\n\n  const INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  const selfLifespans = orderedNodes.map(\n      (node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n  const getSelfLifeSpan = (node: Node) => {\n    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)!];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n    return node.children.map(getSelfLifeSpan)\n        .reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n  });\n\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  const liveUntilMap = new Map<string, Node[]>();\n  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    const liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    const node = orderedNodes[nodeOrder];\n    const liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name)!.push(node);\n  }\n  return liveUntilMap;\n}\n\nconst CONTROL_FLOW_OPS = new Set([\n  'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n  'StatelessWhile', 'if', 'While'\n]);\nconst DYNAMIC_SHAPE_OPS = new Set([\n  'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n]);\nconst HASH_TABLE_OPS = new Set([\n  'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n  'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n]);\n\nexport function isControlFlow(node: Node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\n\nexport function isDynamicShape(node: Node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\n\nexport function isHashTable(node: Node) {\n  return HASH_TABLE_OPS.has(node.op);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}