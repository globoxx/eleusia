{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer';\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems(items) {\n  return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start) {\n  var i = start;\n  return iteratorFromFunction(function () {\n    return {\n      value: i++,\n      done: false\n    };\n  });\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction(func) {\n  return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n  return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped(iterators) {\n  var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n  return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport var LazyIterator = /*#__PURE__*/function () {\n  function LazyIterator() {\n    _classCallCheck(this, LazyIterator);\n  }\n  _createClass(LazyIterator, [{\n    key: \"toArray\",\n    value:\n    /**\n     * Collect all remaining elements of a bounded stream into an array.\n     * Obviously this will succeed only for small streams that fit in memory.\n     * Useful for testing.\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    function () {\n      var _toArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var result, x;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              result = [];\n              _context.next = 3;\n              return this.next();\n            case 3:\n              x = _context.sent;\n            case 4:\n              if (x.done) {\n                _context.next = 11;\n                break;\n              }\n              result.push(x.value);\n              _context.next = 8;\n              return this.next();\n            case 8:\n              x = _context.sent;\n              _context.next = 4;\n              break;\n            case 11:\n              return _context.abrupt(\"return\", result);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function toArray() {\n        return _toArray.apply(this, arguments);\n      }\n      return toArray;\n    }()\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n  }, {\n    key: \"toArrayForTest\",\n    value: function () {\n      var _toArrayForTest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var stream, result, x;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              stream = this.prefetch(100);\n              result = [];\n              _context2.next = 4;\n              return stream.next();\n            case 4:\n              x = _context2.sent;\n            case 5:\n              if (x.done) {\n                _context2.next = 12;\n                break;\n              }\n              result.push(x.value);\n              _context2.next = 9;\n              return stream.next();\n            case 9:\n              x = _context2.sent;\n              _context2.next = 5;\n              break;\n            case 12:\n              return _context2.abrupt(\"return\", result);\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function toArrayForTest() {\n        return _toArrayForTest.apply(this, arguments);\n      }\n      return toArrayForTest;\n    }()\n    /**\n     * Draw items from the stream until it is exhausted.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n  }, {\n    key: \"resolveFully\",\n    value: function () {\n      var _resolveFully = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var x;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.next();\n            case 2:\n              x = _context3.sent;\n            case 3:\n              if (x.done) {\n                _context3.next = 9;\n                break;\n              }\n              _context3.next = 6;\n              return this.next();\n            case 6:\n              x = _context3.sent;\n              _context3.next = 3;\n              break;\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function resolveFully() {\n        return _resolveFully.apply(this, arguments);\n      }\n      return resolveFully;\n    }()\n    /**\n     * Draw items from the stream until it is exhausted, or a predicate fails.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n  }, {\n    key: \"resolveWhile\",\n    value: function () {\n      var _resolveWhile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(predicate) {\n        var x, shouldContinue;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.next();\n            case 2:\n              x = _context4.sent;\n              shouldContinue = predicate(x.value);\n            case 4:\n              if (!(!x.done && shouldContinue)) {\n                _context4.next = 11;\n                break;\n              }\n              _context4.next = 7;\n              return this.next();\n            case 7:\n              x = _context4.sent;\n              shouldContinue = predicate(x.value);\n              _context4.next = 4;\n              break;\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function resolveWhile(_x) {\n        return _resolveWhile.apply(this, arguments);\n      }\n      return resolveWhile;\n    }()\n    /**\n     * Handles errors thrown on this stream using a provided handler function.\n     *\n     * @param handler A function that handles any `Error` thrown during a `next()`\n     *   call and returns true if the stream should continue (dropping the failed\n     *   call) or false if the stream should quietly terminate.  If the handler\n     *   itself throws (or rethrows) an `Error`, that will be propagated.\n     *\n     * @returns A `LazyIterator` of elements passed through from upstream,\n     *   possibly filtering or terminating on upstream `next()` calls that\n     *   throw an `Error`.\n     */\n  }, {\n    key: \"handleErrors\",\n    value: function handleErrors(handler) {\n      return new ErrorHandlingLazyIterator(this, handler);\n    }\n    // TODO(soergel): Implement reduce() etc.\n    /**\n     * Filters this stream according to `predicate`.\n     *\n     * @param predicate A function mapping a stream element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `LazyIterator` of elements for which the predicate was true.\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(predicate) {\n      return new FilterIterator(this, predicate);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n  }, {\n    key: \"map\",\n    value: function map(transform) {\n      return new MapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through an async 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a `Promise` for a\n     *   transformed stream element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n  }, {\n    key: \"mapAsync\",\n    value: function mapAsync(transform) {\n      return new AsyncMapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform, forcing serial execution.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n  }, {\n    key: \"serialMapAsync\",\n    value: function serialMapAsync(transform) {\n      return new AsyncMapIterator(this, transform).serial();\n    }\n    /**\n     * Maps this stream through a 1-to-many transform.\n     *\n     * @param transform A function mapping a stream element to an array of\n     *   transformed elements.\n     *\n     * @returns A `DataStream` of transformed elements.\n     */\n  }, {\n    key: \"flatmap\",\n    value: function flatmap(transform) {\n      return new FlatmapIterator(this, transform);\n    }\n    /**\n     * Apply a function to every element of the stream.\n     *\n     * @param f A function to apply to each stream element.\n     */\n  }, {\n    key: \"forEachAsync\",\n    value: function () {\n      var _forEachAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(f) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", this.map(f).resolveFully());\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function forEachAsync(_x2) {\n        return _forEachAsync.apply(this, arguments);\n      }\n      return forEachAsync;\n    }()\n    /**\n     * Apply a function to every element of the stream, forcing serial execution.\n     *\n     * @param f A function to apply to each stream element.  Should return 'true'\n     *   to indicate that the stream should continue, or 'false' to cause it to\n     *   terminate.\n     */\n  }, {\n    key: \"serialForEach\",\n    value: function () {\n      var _serialForEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(f) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.serialMapAsync(f).resolveWhile(function (x) {\n                return x === true;\n              }));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function serialForEach(_x3) {\n        return _serialForEach.apply(this, arguments);\n      }\n      return serialForEach;\n    }()\n    /**\n     * Groups elements into batches, represented as arrays of elements.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n     * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n     * form, which is needed for vectorized computation.\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `LazyIterator` of batches of elements, represented as arrays\n     *   of the original element type.\n     */\n  }, {\n    key: \"rowMajorBatch\",\n    value: function rowMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n    /**\n     * Groups elements into batches, represented in column-major form.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"column-major\" means that the resulting batch is a (potentially\n     * nested) structure representing the columns.  Each column entry, then,\n     * contains a collection of the values found in that column for a range of\n     * input elements.  This representation allows for vectorized computation, in\n     * contrast to the row-major form.\n     *\n     * The inputs should all have the same nested structure (i.e., of arrays and\n     * dicts).  The result is a single object with the same nested structure,\n     * where the leaves are arrays collecting the values of the inputs at that\n     * location (or, optionally, the result of a custom function applied to those\n     * arrays).\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @param zipFn: (optional) A function that expects an array of elements at a\n     *   single node of the object tree, and returns a `DeepMapResult`.  The\n     *   `DeepMapResult` either provides a result value for that node (i.e.,\n     *   representing the subtree), or indicates that the node should be processed\n     *   recursively.  The default zipFn recurses as far as possible and places\n     *   arrays at the leaves.\n     * @returns A `LazyIterator` of batches of elements, represented as an object\n     *   with collections at the leaves.\n     */\n  }, {\n    key: \"columnMajorBatch\",\n    value: function columnMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var zipFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : zipToList;\n      // First collect the desired number of input elements as a row-major batch.\n      var rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n      // Now 'rotate' or 'pivot' the data, collecting all values from each column\n      // in the batch (i.e., for each key within the elements) into an array.\n      return rowBatches.map(function (x) {\n        return deepZip(x, zipFn);\n      });\n    }\n    /**\n     * Concatenate this `LazyIterator` with another.\n     *\n     * @param iterator A `LazyIterator` to be concatenated onto this one.\n     * @param baseErrorHandler An optional function that can intercept `Error`s\n     *   raised during a `next()` call on the base stream.  This function can\n     *   decide whether the error should be propagated, whether the error should\n     *   be ignored, or whether the base stream should be terminated.\n     * @returns A `LazyIterator`.\n     */\n  }, {\n    key: \"concatenate\",\n    value: function concatenate(iterator, baseErrorHandler) {\n      return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n    /**\n     * Limits this stream to return at most `count` items.\n     *\n     * @param count The maximum number of items to provide from the stream. If\n     * a negative or undefined value is given, the entire stream is returned\n     *   unaltered.\n     */\n  }, {\n    key: \"take\",\n    value: function take(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n      return new TakeIterator(this, count);\n    }\n    /**\n     * Skips the first `count` items in this stream.\n     *\n     * @param count The number of items to skip.  If a negative or undefined\n     * value is given, the entire stream is returned unaltered.\n     */\n  }, {\n    key: \"skip\",\n    value: function skip(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n      return new SkipIterator(this, count);\n    }\n    /**\n     * Prefetch the first `bufferSize` items in this stream.\n     *\n     * Note this prefetches Promises, but makes no guarantees about when those\n     * Promises resolve.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     */\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(bufferSize) {\n      return new PrefetchIterator(this, bufferSize);\n    }\n    // TODO(soergel): deep sharded shuffle, where supported\n    /**\n     * Randomly shuffles the elements of this stream.\n     *\n     * @param bufferSize: An integer specifying the number of elements from\n     * this stream from which the new stream will sample.\n     * @param seed: (Optional.) An integer specifying the random seed that\n     * will be used to create the distribution.\n     */\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(windowSize, seed) {\n      return new ShuffleIterator(this, windowSize, seed);\n    }\n    /**\n     * Force an iterator to execute serially: each next() call will await the\n     * prior one, so that they cannot execute concurrently.\n     */\n  }, {\n    key: \"serial\",\n    value: function serial() {\n      return new SerialIterator(this);\n    }\n  }]);\n  return LazyIterator;\n}();\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\nvar ArrayIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(ArrayIterator, _LazyIterator);\n  var _super = _createSuper(ArrayIterator);\n  function ArrayIterator(items) {\n    var _this;\n    _classCallCheck(this, ArrayIterator);\n    _this = _super.call(this);\n    _this.items = items;\n    _this.trav = 0;\n    return _this;\n  }\n  _createClass(ArrayIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Array of \".concat(this.items.length, \" items\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var item;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(this.trav >= this.items.length)) {\n                _context7.next = 2;\n                break;\n              }\n              return _context7.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 2:\n              item = this.items[this.trav];\n              this.trav++;\n              return _context7.abrupt(\"return\", {\n                value: deepClone(item),\n                done: false\n              });\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function next() {\n        return _next.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return ArrayIterator;\n}(LazyIterator);\nvar FunctionCallIterator = /*#__PURE__*/function (_LazyIterator2) {\n  _inherits(FunctionCallIterator, _LazyIterator2);\n  var _super2 = _createSuper(FunctionCallIterator);\n  function FunctionCallIterator(nextFn) {\n    var _this2;\n    _classCallCheck(this, FunctionCallIterator);\n    _this2 = _super2.call(this);\n    _this2.nextFn = nextFn;\n    return _this2;\n  }\n  _createClass(FunctionCallIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Function call\";\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              return _context8.abrupt(\"return\", this.nextFn());\n            case 4:\n              _context8.prev = 4;\n              _context8.t0 = _context8[\"catch\"](0);\n              // Modify the error message but leave the stack trace intact\n              _context8.t0.message = \"Error thrown while iterating through a dataset: \".concat(_context8.t0.message);\n              throw _context8.t0;\n            case 8:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[0, 4]]);\n      }));\n      function next() {\n        return _next2.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return FunctionCallIterator;\n}(LazyIterator);\nvar SerialIterator = /*#__PURE__*/function (_LazyIterator3) {\n  _inherits(SerialIterator, _LazyIterator3);\n  var _super3 = _createSuper(SerialIterator);\n  function SerialIterator(upstream) {\n    var _this3;\n    _classCallCheck(this, SerialIterator);\n    _this3 = _super3.call(this);\n    _this3.upstream = upstream;\n    _this3.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this3;\n  }\n  _createClass(SerialIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Serial\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _this4 = this;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this4.serialNext();\n              });\n              return _context9.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function next() {\n        return _next3.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", this.upstream.next());\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function serialNext() {\n        return _serialNext.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return SerialIterator;\n}(LazyIterator);\nvar SkipIterator = /*#__PURE__*/function (_LazyIterator4) {\n  _inherits(SkipIterator, _LazyIterator4);\n  var _super4 = _createSuper(SkipIterator);\n  function SkipIterator(upstream, maxCount) {\n    var _this5;\n    _classCallCheck(this, SkipIterator);\n    _this5 = _super4.call(this);\n    _this5.upstream = upstream;\n    _this5.maxCount = maxCount;\n    // Local state that should not be clobbered by out-of-order execution.\n    _this5.count = 0;\n    _this5.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this5;\n  }\n  _createClass(SkipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Skip\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _this6 = this;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this6.serialNext();\n              });\n              return _context11.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function next() {\n        return _next4.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var skipped;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(this.count++ < this.maxCount)) {\n                _context12.next = 9;\n                break;\n              }\n              _context12.next = 3;\n              return this.upstream.next();\n            case 3:\n              skipped = _context12.sent;\n              if (!skipped.done) {\n                _context12.next = 6;\n                break;\n              }\n              return _context12.abrupt(\"return\", skipped);\n            case 6:\n              tf.dispose(skipped.value);\n              _context12.next = 0;\n              break;\n            case 9:\n              return _context12.abrupt(\"return\", this.upstream.next());\n            case 10:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function serialNext() {\n        return _serialNext2.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return SkipIterator;\n}(LazyIterator);\nvar TakeIterator = /*#__PURE__*/function (_LazyIterator5) {\n  _inherits(TakeIterator, _LazyIterator5);\n  var _super5 = _createSuper(TakeIterator);\n  function TakeIterator(upstream, maxCount) {\n    var _this7;\n    _classCallCheck(this, TakeIterator);\n    _this7 = _super5.call(this);\n    _this7.upstream = upstream;\n    _this7.maxCount = maxCount;\n    _this7.count = 0;\n    return _this7;\n  }\n  _createClass(TakeIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Take\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!(this.count++ >= this.maxCount)) {\n                _context13.next = 2;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 2:\n              return _context13.abrupt(\"return\", this.upstream.next());\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function next() {\n        return _next5.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return TakeIterator;\n}(LazyIterator); // Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nvar RowMajorBatchIterator = /*#__PURE__*/function (_LazyIterator6) {\n  _inherits(RowMajorBatchIterator, _LazyIterator6);\n  var _super6 = _createSuper(RowMajorBatchIterator);\n  function RowMajorBatchIterator(upstream, batchSize) {\n    var _this8;\n    var enableSmallLastBatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    _classCallCheck(this, RowMajorBatchIterator);\n    _this8 = _super6.call(this);\n    _this8.upstream = upstream;\n    _this8.batchSize = batchSize;\n    _this8.enableSmallLastBatch = enableSmallLastBatch;\n    _this8.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this8;\n  }\n  _createClass(RowMajorBatchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> RowMajorBatch\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _this9 = this;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this9.serialNext();\n              });\n              return _context14.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function next() {\n        return _next6.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var batch, item;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              batch = [];\n            case 1:\n              if (!(batch.length < this.batchSize)) {\n                _context15.next = 12;\n                break;\n              }\n              _context15.next = 4;\n              return this.upstream.next();\n            case 4:\n              item = _context15.sent;\n              if (!item.done) {\n                _context15.next = 9;\n                break;\n              }\n              if (!(this.enableSmallLastBatch && batch.length > 0)) {\n                _context15.next = 8;\n                break;\n              }\n              return _context15.abrupt(\"return\", {\n                value: batch,\n                done: false\n              });\n            case 8:\n              return _context15.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 9:\n              batch.push(item.value);\n              _context15.next = 1;\n              break;\n            case 12:\n              return _context15.abrupt(\"return\", {\n                value: batch,\n                done: false\n              });\n            case 13:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function serialNext() {\n        return _serialNext3.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return RowMajorBatchIterator;\n}(LazyIterator);\nvar FilterIterator = /*#__PURE__*/function (_LazyIterator7) {\n  _inherits(FilterIterator, _LazyIterator7);\n  var _super7 = _createSuper(FilterIterator);\n  function FilterIterator(upstream, predicate) {\n    var _this10;\n    _classCallCheck(this, FilterIterator);\n    _this10 = _super7.call(this);\n    _this10.upstream = upstream;\n    _this10.predicate = predicate;\n    _this10.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this10;\n  }\n  _createClass(FilterIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Filter\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this11 = this;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this11.serialNext();\n              });\n              return _context16.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function next() {\n        return _next7.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var item;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!true) {\n                _context17.next = 9;\n                break;\n              }\n              _context17.next = 3;\n              return this.upstream.next();\n            case 3:\n              item = _context17.sent;\n              if (!(item.done || this.predicate(item.value))) {\n                _context17.next = 6;\n                break;\n              }\n              return _context17.abrupt(\"return\", item);\n            case 6:\n              tf.dispose(item.value);\n              _context17.next = 0;\n              break;\n            case 9:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function serialNext() {\n        return _serialNext4.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return FilterIterator;\n}(LazyIterator);\nvar MapIterator = /*#__PURE__*/function (_LazyIterator8) {\n  _inherits(MapIterator, _LazyIterator8);\n  var _super8 = _createSuper(MapIterator);\n  function MapIterator(upstream, transform) {\n    var _this12;\n    _classCallCheck(this, MapIterator);\n    _this12 = _super8.call(this);\n    _this12.upstream = upstream;\n    _this12.transform = transform;\n    return _this12;\n  }\n  _createClass(MapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Map\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var item, inputTensors, mapped, outputTensors, _iterator, _step, t;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return this.upstream.next();\n            case 2:\n              item = _context18.sent;\n              if (!item.done) {\n                _context18.next = 5;\n                break;\n              }\n              return _context18.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n              // That's why we have to remember the input Tensors above, and then\n              // below dispose only those that were not passed through to the output.\n              // Note too that the transform function is responsible for tidying\n              // any intermediate Tensors.  Here we are concerned only about the\n              // inputs.\n              mapped = this.transform(item.value);\n              outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n              // TODO(soergel) move to tf.disposeExcept(in, out)?\n              _iterator = _createForOfIteratorHelper(inputTensors);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  t = _step.value;\n                  if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                    t.dispose();\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context18.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n            case 11:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function next() {\n        return _next8.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return MapIterator;\n}(LazyIterator);\nvar ErrorHandlingLazyIterator = /*#__PURE__*/function (_LazyIterator9) {\n  _inherits(ErrorHandlingLazyIterator, _LazyIterator9);\n  var _super9 = _createSuper(ErrorHandlingLazyIterator);\n  function ErrorHandlingLazyIterator(upstream, handler) {\n    var _this13;\n    _classCallCheck(this, ErrorHandlingLazyIterator);\n    _this13 = _super9.call(this);\n    _this13.upstream = upstream;\n    _this13.handler = handler;\n    _this13.count = 0;\n    _this13.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this13;\n  }\n  _createClass(ErrorHandlingLazyIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> handleErrors\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var _this14 = this;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this14.serialNext();\n              });\n              return _context19.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function next() {\n        return _next9.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              if (!true) {\n                _context20.next = 13;\n                break;\n              }\n              _context20.prev = 1;\n              _context20.next = 4;\n              return this.upstream.next();\n            case 4:\n              return _context20.abrupt(\"return\", _context20.sent);\n            case 7:\n              _context20.prev = 7;\n              _context20.t0 = _context20[\"catch\"](1);\n              if (this.handler(_context20.t0)) {\n                _context20.next = 11;\n                break;\n              }\n              return _context20.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 11:\n              _context20.next = 0;\n              break;\n            case 13:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this, [[1, 7]]);\n      }));\n      function serialNext() {\n        return _serialNext5.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return ErrorHandlingLazyIterator;\n}(LazyIterator);\nvar AsyncMapIterator = /*#__PURE__*/function (_LazyIterator10) {\n  _inherits(AsyncMapIterator, _LazyIterator10);\n  var _super10 = _createSuper(AsyncMapIterator);\n  function AsyncMapIterator(upstream, transform) {\n    var _this15;\n    _classCallCheck(this, AsyncMapIterator);\n    _this15 = _super10.call(this);\n    _this15.upstream = upstream;\n    _this15.transform = transform;\n    return _this15;\n  }\n  _createClass(AsyncMapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> AsyncMap\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var item, inputTensors, mapped, outputTensors, _iterator2, _step2, t;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this.upstream.next();\n            case 2:\n              item = _context21.sent;\n              if (!item.done) {\n                _context21.next = 5;\n                break;\n              }\n              return _context21.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n              // That's why we have to remember the input Tensors above, and then\n              // below dispose only those that were not passed through to the output.\n              // Note too that the transform function is responsible for tidying\n              // any intermediate Tensors.  Here we are concerned only about the\n              // inputs.\n              _context21.next = 8;\n              return this.transform(item.value);\n            case 8:\n              mapped = _context21.sent;\n              outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n              // TODO(soergel) move to tf.disposeExcept(in, out)?\n              _iterator2 = _createForOfIteratorHelper(inputTensors);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  t = _step2.value;\n                  if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                    t.dispose();\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              return _context21.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n            case 13:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function next() {\n        return _next10.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return AsyncMapIterator;\n}(LazyIterator); // Iterators that maintain a queue of pending items\n// ============================================================================\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport var OneToManyIterator = /*#__PURE__*/function (_LazyIterator11) {\n  _inherits(OneToManyIterator, _LazyIterator11);\n  var _super11 = _createSuper(OneToManyIterator);\n  function OneToManyIterator() {\n    var _this16;\n    _classCallCheck(this, OneToManyIterator);\n    _this16 = _super11.call(this);\n    _this16.outputQueue = new GrowingRingBuffer();\n    _this16.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this16;\n  }\n  _createClass(OneToManyIterator, [{\n    key: \"next\",\n    value: function () {\n      var _next11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var _this17 = this;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this17.serialNext();\n              });\n              return _context22.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function next() {\n        return _next11.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              if (!(this.outputQueue.length() === 0)) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 3;\n              return this.pump();\n            case 3:\n              if (_context23.sent) {\n                _context23.next = 5;\n                break;\n              }\n              return _context23.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 5:\n              _context23.next = 0;\n              break;\n            case 7:\n              return _context23.abrupt(\"return\", {\n                value: this.outputQueue.shift(),\n                done: false\n              });\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function serialNext() {\n        return _serialNext6.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return OneToManyIterator;\n}(LazyIterator);\nvar FlatmapIterator = /*#__PURE__*/function (_OneToManyIterator) {\n  _inherits(FlatmapIterator, _OneToManyIterator);\n  var _super12 = _createSuper(FlatmapIterator);\n  function FlatmapIterator(upstream, transform) {\n    var _this18;\n    _classCallCheck(this, FlatmapIterator);\n    _this18 = _super12.call(this);\n    _this18.upstream = upstream;\n    _this18.transform = transform;\n    return _this18;\n  }\n  _createClass(FlatmapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Flatmap\");\n    }\n  }, {\n    key: \"pump\",\n    value: function () {\n      var _pump = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var item, inputTensors, mappedArray, outputTensors, _iterator3, _step3, t;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.upstream.next();\n            case 2:\n              item = _context24.sent;\n              if (!item.done) {\n                _context24.next = 5;\n                break;\n              }\n              return _context24.abrupt(\"return\", false);\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n              // that's why we have to remember the input Tensors above, and then\n              // below dispose only those that were not passed through to the output.\n              // Note too that the transform function is responsible for tidying any\n              // intermediate Tensors.  Here we are concerned only about the inputs.\n              mappedArray = this.transform(item.value);\n              outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n              this.outputQueue.pushAll(mappedArray);\n              // TODO(soergel) faster intersection, and deduplicate outputTensors\n              // TODO(soergel) move to tf.disposeExcept(in, out)?\n              _iterator3 = _createForOfIteratorHelper(inputTensors);\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  t = _step3.value;\n                  if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                    t.dispose();\n                  }\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              return _context24.abrupt(\"return\", true);\n            case 12:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function pump() {\n        return _pump.apply(this, arguments);\n      }\n      return pump;\n    }()\n  }]);\n  return FlatmapIterator;\n}(OneToManyIterator);\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport var ChainedIterator = /*#__PURE__*/function (_LazyIterator12) {\n  _inherits(ChainedIterator, _LazyIterator12);\n  var _super13 = _createSuper(ChainedIterator);\n  function ChainedIterator(iterators, baseErrorHandler) {\n    var _this19;\n    _classCallCheck(this, ChainedIterator);\n    _this19 = _super13.call(this);\n    _this19.baseErrorHandler = baseErrorHandler;\n    // Strict Promise execution order:\n    // a next() call may not even begin until the previous one completes.\n    _this19.lastRead = null;\n    // Local state that should not be clobbered by out-of-order execution.\n    _this19.iterator = null;\n    _this19.moreIterators = iterators;\n    return _this19;\n  }\n  _createClass(ChainedIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n      return \"\".concat(upstreamSummaries, \" -> Chained\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              this.lastRead = this.readFromChain(this.lastRead);\n              return _context25.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function next() {\n        return _next12.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"readFromChain\",\n    value: function () {\n      var _readFromChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(lastRead) {\n        var iteratorResult, itemResult;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return lastRead;\n            case 2:\n              if (!(this.iterator == null)) {\n                _context26.next = 10;\n                break;\n              }\n              _context26.next = 5;\n              return this.moreIterators.next();\n            case 5:\n              iteratorResult = _context26.sent;\n              if (!iteratorResult.done) {\n                _context26.next = 8;\n                break;\n              }\n              return _context26.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 8:\n              this.iterator = iteratorResult.value;\n              if (this.baseErrorHandler != null) {\n                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n              }\n            case 10:\n              _context26.next = 12;\n              return this.iterator.next();\n            case 12:\n              itemResult = _context26.sent;\n              if (!itemResult.done) {\n                _context26.next = 16;\n                break;\n              }\n              this.iterator = null;\n              return _context26.abrupt(\"return\", this.readFromChain(lastRead));\n            case 16:\n              return _context26.abrupt(\"return\", itemResult);\n            case 17:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function readFromChain(_x4) {\n        return _readFromChain.apply(this, arguments);\n      }\n      return readFromChain;\n    }()\n  }]);\n  return ChainedIterator;\n}(LazyIterator);\nexport var ZipMismatchMode;\n(function (ZipMismatchMode) {\n  ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n  ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n  ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nvar ZipIterator = /*#__PURE__*/function (_LazyIterator13) {\n  _inherits(ZipIterator, _LazyIterator13);\n  var _super14 = _createSuper(ZipIterator);\n  function ZipIterator(iterators) {\n    var _this20;\n    var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n    _classCallCheck(this, ZipIterator);\n    _this20 = _super14.call(this);\n    _this20.iterators = iterators;\n    _this20.mismatchMode = mismatchMode;\n    _this20.count = 0;\n    _this20.currentPromise = null;\n    return _this20;\n  }\n  _createClass(ZipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n      return \"{\".concat(upstreamSummaries, \"} -> Zip\");\n    }\n  }, {\n    key: \"nextState\",\n    value: function () {\n      var _nextState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(afterState) {\n        var numIterators, iteratorsDone, getNext, mapped;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              getNext = function _getNext(container) {\n                if (container instanceof LazyIterator) {\n                  var result = container.next();\n                  return {\n                    value: result.then(function (x) {\n                      numIterators++;\n                      if (x.done) {\n                        iteratorsDone++;\n                      }\n                      return x.value;\n                    }),\n                    recurse: false\n                  };\n                } else {\n                  return {\n                    value: null,\n                    recurse: true\n                  };\n                }\n              };\n              _context27.next = 3;\n              return afterState;\n            case 3:\n              // Collect underlying iterator \"done\" signals as a side effect in\n              // getNext()\n              numIterators = 0;\n              iteratorsDone = 0;\n              _context27.next = 7;\n              return deepMapAndAwaitAll(this.iterators, getNext);\n            case 7:\n              mapped = _context27.sent;\n              if (!(numIterators === iteratorsDone)) {\n                _context27.next = 10;\n                break;\n              }\n              return _context27.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 10:\n              if (!(iteratorsDone > 0)) {\n                _context27.next = 16;\n                break;\n              }\n              _context27.t0 = this.mismatchMode;\n              _context27.next = _context27.t0 === ZipMismatchMode.FAIL ? 14 : _context27.t0 === ZipMismatchMode.SHORTEST ? 15 : _context27.t0 === ZipMismatchMode.LONGEST ? 16 : 16;\n              break;\n            case 14:\n              throw new Error('Zipped streams should have the same length. ' + \"Mismatched at element \".concat(this.count, \".\"));\n            case 15:\n              return _context27.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 16:\n              this.count++;\n              return _context27.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n            case 18:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function nextState(_x5) {\n        return _nextState.apply(this, arguments);\n      }\n      return nextState;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              this.currentPromise = this.nextState(this.currentPromise);\n              return _context28.abrupt(\"return\", this.currentPromise);\n            case 2:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n      function next() {\n        return _next13.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return ZipIterator;\n}(LazyIterator); // Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport var PrefetchIterator = /*#__PURE__*/function (_LazyIterator14) {\n  _inherits(PrefetchIterator, _LazyIterator14);\n  var _super15 = _createSuper(PrefetchIterator);\n  function PrefetchIterator(upstream, bufferSize) {\n    var _this21;\n    _classCallCheck(this, PrefetchIterator);\n    _this21 = _super15.call(this);\n    _this21.upstream = upstream;\n    _this21.bufferSize = bufferSize;\n    _this21.buffer = new RingBuffer(bufferSize);\n    return _this21;\n  }\n  _createClass(PrefetchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Prefetch\");\n    }\n    /**\n     * Refill the prefetch buffer.  Returns only after the buffer is full, or\n     * the upstream source is exhausted.\n     */\n  }, {\n    key: \"refill\",\n    value: function refill() {\n      while (!this.buffer.isFull()) {\n        var v = this.upstream.next();\n        this.buffer.push(v);\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.refill();\n      // This shift will never throw an error because the buffer is always\n      // full after a refill. If the stream is exhausted, the buffer will be\n      // full of Promises that will resolve to the end-of-stream signal.\n      return this.buffer.shift();\n    }\n  }]);\n  return PrefetchIterator;\n}(LazyIterator);\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport var ShuffleIterator = /*#__PURE__*/function (_PrefetchIterator) {\n  _inherits(ShuffleIterator, _PrefetchIterator);\n  var _super16 = _createSuper(ShuffleIterator);\n  function ShuffleIterator(upstream, windowSize, seed) {\n    var _this22;\n    _classCallCheck(this, ShuffleIterator);\n    _this22 = _super16.call(this, upstream, windowSize);\n    _this22.upstream = upstream;\n    _this22.windowSize = windowSize;\n    // Local state that should not be clobbered by out-of-order execution.\n    _this22.upstreamExhausted = false;\n    _this22.random = seedrandom.alea(seed || tf.util.now().toString());\n    _this22.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this22;\n  }\n  _createClass(ShuffleIterator, [{\n    key: \"next\",\n    value: function () {\n      var _next14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var _this23 = this;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this23.serialNext();\n              });\n              return _context29.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n      function next() {\n        return _next14.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"randomInt\",\n    value: function randomInt(max) {\n      return Math.floor(this.random() * max);\n    }\n  }, {\n    key: \"chooseIndex\",\n    value: function chooseIndex() {\n      return this.randomInt(this.buffer.length());\n    }\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        var chosenIndex, result;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              // TODO(soergel): consider performance\n              if (!this.upstreamExhausted) {\n                this.refill();\n              }\n            case 1:\n              if (this.buffer.isEmpty()) {\n                _context30.next = 14;\n                break;\n              }\n              chosenIndex = this.chooseIndex();\n              _context30.next = 5;\n              return this.buffer.shuffleExcise(chosenIndex);\n            case 5:\n              result = _context30.sent;\n              if (!result.done) {\n                _context30.next = 10;\n                break;\n              }\n              this.upstreamExhausted = true;\n              _context30.next = 12;\n              break;\n            case 10:\n              this.refill();\n              return _context30.abrupt(\"return\", result);\n            case 12:\n              _context30.next = 1;\n              break;\n            case 14:\n              return _context30.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 15:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n      function serialNext() {\n        return _serialNext7.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return ShuffleIterator;\n}(PrefetchIterator);","map":{"version":3,"names":["tf","seedrandom","deepClone","deepMapAndAwaitAll","deepZip","zipToList","GrowingRingBuffer","RingBuffer","iteratorFromItems","items","ArrayIterator","iteratorFromIncrementing","start","i","iteratorFromFunction","value","done","func","FunctionCallIterator","iteratorFromConcatenated","baseIterators","baseErrorHandler","ChainedIterator","iteratorFromConcatenatedFunction","iteratorFunc","count","take","iteratorFromZipped","iterators","mismatchMode","arguments","length","undefined","ZipMismatchMode","FAIL","ZipIterator","LazyIterator","_classCallCheck","_createClass","key","_toArray","_asyncToGenerator","_regeneratorRuntime","mark","_callee","result","x","wrap","_callee$","_context","prev","next","sent","push","abrupt","stop","toArray","apply","_toArrayForTest","_callee2","stream","_callee2$","_context2","prefetch","toArrayForTest","_resolveFully","_callee3","_callee3$","_context3","resolveFully","_resolveWhile","_callee4","predicate","shouldContinue","_callee4$","_context4","resolveWhile","_x","handleErrors","handler","ErrorHandlingLazyIterator","filter","FilterIterator","map","transform","MapIterator","mapAsync","AsyncMapIterator","serialMapAsync","serial","flatmap","FlatmapIterator","_forEachAsync","_callee5","f","_callee5$","_context5","forEachAsync","_x2","_serialForEach","_callee6","_callee6$","_context6","serialForEach","_x3","rowMajorBatch","batchSize","smallLastBatch","RowMajorBatchIterator","columnMajorBatch","zipFn","rowBatches","concatenate","iterator","TakeIterator","skip","SkipIterator","bufferSize","PrefetchIterator","shuffle","windowSize","seed","ShuffleIterator","SerialIterator","_LazyIterator","_inherits","_super","_createSuper","_this","call","trav","summary","concat","_next","_callee7","item","_callee7$","_context7","_LazyIterator2","_super2","nextFn","_this2","_next2","_callee8","_callee8$","_context8","t0","message","_LazyIterator3","_super3","upstream","_this3","lastRead","Promise","resolve","_next3","_callee9","_this4","_callee9$","_context9","then","serialNext","_serialNext","_callee10","_callee10$","_context10","_LazyIterator4","_super4","maxCount","_this5","_next4","_callee11","_this6","_callee11$","_context11","_serialNext2","_callee12","skipped","_callee12$","_context12","dispose","_LazyIterator5","_super5","_this7","_next5","_callee13","_callee13$","_context13","_LazyIterator6","_super6","_this8","enableSmallLastBatch","_next6","_callee14","_this9","_callee14$","_context14","_serialNext3","_callee15","batch","_callee15$","_context15","_LazyIterator7","_super7","_this10","_next7","_callee16","_this11","_callee16$","_context16","_serialNext4","_callee17","_callee17$","_context17","_LazyIterator8","_super8","_this12","_next8","_callee18","inputTensors","mapped","outputTensors","_iterator","_step","t","_callee18$","_context18","tensor_util","getTensorsInContainer","_createForOfIteratorHelper","s","n","isTensorInList","err","e","_LazyIterator9","_super9","_this13","_next9","_callee19","_this14","_callee19$","_context19","_serialNext5","_callee20","_callee20$","_context20","_LazyIterator10","_super10","_this15","_next10","_callee21","_iterator2","_step2","_callee21$","_context21","OneToManyIterator","_LazyIterator11","_super11","_this16","outputQueue","_next11","_callee22","_this17","_callee22$","_context22","_serialNext6","_callee23","_callee23$","_context23","pump","shift","_OneToManyIterator","_super12","_this18","_pump","_callee24","mappedArray","_iterator3","_step3","_callee24$","_context24","pushAll","_LazyIterator12","_super13","_this19","moreIterators","upstreamSummaries","_next12","_callee25","_callee25$","_context25","readFromChain","_readFromChain","_callee26","iteratorResult","itemResult","_callee26$","_context26","_x4","_LazyIterator13","_super14","_this20","currentPromise","_nextState","_callee27","afterState","numIterators","iteratorsDone","getNext","_callee27$","_context27","_getNext","container","recurse","SHORTEST","LONGEST","Error","nextState","_x5","_next13","_callee28","_callee28$","_context28","_LazyIterator14","_super15","_this21","buffer","refill","isFull","v","_PrefetchIterator","_super16","_this22","upstreamExhausted","random","alea","util","now","toString","_next14","_callee29","_this23","_callee29$","_context29","randomInt","max","Math","floor","chooseIndex","_serialNext7","_callee30","chosenIndex","_callee30$","_context30","isEmpty","shuffleExcise"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-data\\src\\iterators\\lazy_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\n\nimport {Container} from '../types';\nimport {deepClone} from '../util/deep_clone';\nimport {deepMapAndAwaitAll, DeepMapAsyncResult, DeepMapResult, deepZip, zipToList} from '../util/deep_map';\nimport {GrowingRingBuffer} from '../util/growing_ring_buffer';\nimport {RingBuffer} from '../util/ring_buffer';\n\n/**\n * A nested structure of LazyIterators, used as the input to zip().\n */\nexport type IteratorContainer = Container<LazyIterator<tf.TensorContainer>>;\n\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems<T>(items: T[]): LazyIterator<T> {\n  return new ArrayIterator(items);\n}\n\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start: number): LazyIterator<number> {\n  let i = start;\n  return iteratorFromFunction(() => ({value: i++, done: false}));\n}\n\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction<T>(\n    func: () =>\n        IteratorResult<T>| Promise<IteratorResult<T>>): LazyIterator<T> {\n  return new FunctionCallIterator(func);\n}\n\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated<T>(\n    baseIterators: LazyIterator<LazyIterator<T>>,\n    baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction<T>(\n    iteratorFunc: () => IteratorResult<LazyIterator<T>>, count: number,\n    baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n  return iteratorFromConcatenated(\n      iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped<O extends tf.TensorContainer>(\n    iterators: IteratorContainer,\n    mismatchMode: ZipMismatchMode = ZipMismatchMode.FAIL): LazyIterator<O> {\n  return new ZipIterator<O>(iterators, mismatchMode);\n}\n\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport abstract class LazyIterator<T> {\n  // This class implements AsyncIterator<T>, but we have not yet set the\n  // TypeScript --downlevelIteration flag to enable that.\n\n  abstract summary(): string;\n\n  /**\n   * Returns a `Promise` for the next element in the stream.\n   *\n   * When an item can be provided successfully, the return value is\n   * `{value:T, done:false}`.\n   *\n   * Calling next() on a closed stream returns `{value:null, done:true}`.\n   */\n  abstract next(): Promise<IteratorResult<T>>;\n\n  /**\n   * Collect all remaining elements of a bounded stream into an array.\n   * Obviously this will succeed only for small streams that fit in memory.\n   * Useful for testing.\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  async toArray(): Promise<T[]> {\n    const result: T[] = [];\n    let x = await this.next();\n    while (!x.done) {\n      result.push(x.value);\n      x = await this.next();\n    }\n    return result;\n  }\n\n  /**\n   * Collect all elements of this dataset into an array with prefetching 100\n   * elements. This is useful for testing, because the prefetch changes the\n   * order in which the Promises are resolved along the processing pipeline.\n   * This may help expose bugs where results are dependent on the order of\n   * Promise resolution rather than on the logical order of the stream (i.e.,\n   * due to hidden mutable state).\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  async toArrayForTest(): Promise<T[]> {\n    const stream = this.prefetch(100);\n    const result: T[] = [];\n    let x = await stream.next();\n    while (!x.done) {\n      result.push(x.value);\n      x = await stream.next();\n    }\n    return result;\n  }\n\n  /**\n   * Draw items from the stream until it is exhausted.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n  async resolveFully(): Promise<void> {\n    let x = await this.next();\n    while (!x.done) {\n      x = await this.next();\n    }\n  }\n\n  /**\n   * Draw items from the stream until it is exhausted, or a predicate fails.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n  async resolveWhile(predicate: (r: T) => boolean): Promise<void> {\n    let x = await this.next();\n    let shouldContinue = predicate(x.value);\n    while ((!x.done) && shouldContinue) {\n      x = await this.next();\n      shouldContinue = predicate(x.value);\n    }\n  }\n\n  /**\n   * Handles errors thrown on this stream using a provided handler function.\n   *\n   * @param handler A function that handles any `Error` thrown during a `next()`\n   *   call and returns true if the stream should continue (dropping the failed\n   *   call) or false if the stream should quietly terminate.  If the handler\n   *   itself throws (or rethrows) an `Error`, that will be propagated.\n   *\n   * @returns A `LazyIterator` of elements passed through from upstream,\n   *   possibly filtering or terminating on upstream `next()` calls that\n   *   throw an `Error`.\n   */\n  handleErrors(handler: (error: Error) => boolean): LazyIterator<T> {\n    return new ErrorHandlingLazyIterator(this, handler);\n  }\n\n  // TODO(soergel): Implement reduce() etc.\n\n  /**\n   * Filters this stream according to `predicate`.\n   *\n   * @param predicate A function mapping a stream element to a boolean or a\n   * `Promise` for one.\n   *\n   * @returns A `LazyIterator` of elements for which the predicate was true.\n   */\n  filter(predicate: (value: T) => boolean): LazyIterator<T> {\n    return new FilterIterator(this, predicate);\n  }\n\n  /**\n   * Maps this stream through a 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  map<O>(transform: (value: T) => O): LazyIterator<O> {\n    return new MapIterator(this, transform);\n  }\n\n  /**\n   * Maps this stream through an async 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a `Promise` for a\n   *   transformed stream element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  mapAsync<O>(transform: (value: T) => Promise<O>): LazyIterator<O> {\n    return new AsyncMapIterator(this, transform);\n  }\n\n  /**\n   * Maps this stream through a 1-to-1 transform, forcing serial execution.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  serialMapAsync<O>(transform: (value: T) => Promise<O>): LazyIterator<O> {\n    return new AsyncMapIterator(this, transform).serial();\n  }\n\n  /**\n   * Maps this stream through a 1-to-many transform.\n   *\n   * @param transform A function mapping a stream element to an array of\n   *   transformed elements.\n   *\n   * @returns A `DataStream` of transformed elements.\n   */\n  flatmap<O>(transform: (value: T) => O[]): LazyIterator<O> {\n    return new FlatmapIterator(this, transform);\n  }\n\n  /**\n   * Apply a function to every element of the stream.\n   *\n   * @param f A function to apply to each stream element.\n   */\n  async forEachAsync(f: (value: T) => void): Promise<void> {\n    return this.map(f).resolveFully();\n  }\n\n  /**\n   * Apply a function to every element of the stream, forcing serial execution.\n   *\n   * @param f A function to apply to each stream element.  Should return 'true'\n   *   to indicate that the stream should continue, or 'false' to cause it to\n   *   terminate.\n   */\n  async serialForEach(f: (value: T) => Promise<boolean>): Promise<void> {\n    return this.serialMapAsync(f).resolveWhile(x => (x === true));\n  }\n\n  /**\n   * Groups elements into batches, represented as arrays of elements.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n   * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n   * form, which is needed for vectorized computation.\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @returns A `LazyIterator` of batches of elements, represented as arrays\n   *   of the original element type.\n   */\n  rowMajorBatch(batchSize: number, smallLastBatch = true): LazyIterator<T[]> {\n    return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n  }\n\n  /**\n   * Groups elements into batches, represented in column-major form.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"column-major\" means that the resulting batch is a (potentially\n   * nested) structure representing the columns.  Each column entry, then,\n   * contains a collection of the values found in that column for a range of\n   * input elements.  This representation allows for vectorized computation, in\n   * contrast to the row-major form.\n   *\n   * The inputs should all have the same nested structure (i.e., of arrays and\n   * dicts).  The result is a single object with the same nested structure,\n   * where the leaves are arrays collecting the values of the inputs at that\n   * location (or, optionally, the result of a custom function applied to those\n   * arrays).\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @param zipFn: (optional) A function that expects an array of elements at a\n   *   single node of the object tree, and returns a `DeepMapResult`.  The\n   *   `DeepMapResult` either provides a result value for that node (i.e.,\n   *   representing the subtree), or indicates that the node should be processed\n   *   recursively.  The default zipFn recurses as far as possible and places\n   *   arrays at the leaves.\n   * @returns A `LazyIterator` of batches of elements, represented as an object\n   *   with collections at the leaves.\n   */\n  columnMajorBatch(\n      batchSize: number, smallLastBatch = true,\n      // tslint:disable-next-line:no-any\n      zipFn: (xs: any[]) => DeepMapResult = zipToList):\n      LazyIterator<tf.TensorContainer> {\n    // First collect the desired number of input elements as a row-major batch.\n    const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n    // Now 'rotate' or 'pivot' the data, collecting all values from each column\n    // in the batch (i.e., for each key within the elements) into an array.\n    return rowBatches.map(x => deepZip(x, zipFn));\n  }\n\n  /**\n   * Concatenate this `LazyIterator` with another.\n   *\n   * @param iterator A `LazyIterator` to be concatenated onto this one.\n   * @param baseErrorHandler An optional function that can intercept `Error`s\n   *   raised during a `next()` call on the base stream.  This function can\n   *   decide whether the error should be propagated, whether the error should\n   *   be ignored, or whether the base stream should be terminated.\n   * @returns A `LazyIterator`.\n   */\n  concatenate(\n      iterator: LazyIterator<T>,\n      baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n    return new ChainedIterator(\n        iteratorFromItems([this, iterator]), baseErrorHandler);\n  }\n\n  /**\n   * Limits this stream to return at most `count` items.\n   *\n   * @param count The maximum number of items to provide from the stream. If\n   * a negative or undefined value is given, the entire stream is returned\n   *   unaltered.\n   */\n  take(count: number): LazyIterator<T> {\n    if (count < 0 || count == null) {\n      return this;\n    }\n    return new TakeIterator(this, count);\n  }\n\n  /**\n   * Skips the first `count` items in this stream.\n   *\n   * @param count The number of items to skip.  If a negative or undefined\n   * value is given, the entire stream is returned unaltered.\n   */\n  skip(count: number): LazyIterator<T> {\n    if (count < 0 || count == null) {\n      return this;\n    }\n    return new SkipIterator(this, count);\n  }\n\n  /**\n   * Prefetch the first `bufferSize` items in this stream.\n   *\n   * Note this prefetches Promises, but makes no guarantees about when those\n   * Promises resolve.\n   *\n   * @param bufferSize: An integer specifying the number of elements to be\n   *   prefetched.\n   */\n  prefetch(bufferSize: number): LazyIterator<T> {\n    return new PrefetchIterator(this, bufferSize);\n  }\n\n  // TODO(soergel): deep sharded shuffle, where supported\n\n  /**\n   * Randomly shuffles the elements of this stream.\n   *\n   * @param bufferSize: An integer specifying the number of elements from\n   * this stream from which the new stream will sample.\n   * @param seed: (Optional.) An integer specifying the random seed that\n   * will be used to create the distribution.\n   */\n  shuffle(windowSize: number, seed?: string): LazyIterator<T> {\n    return new ShuffleIterator(this, windowSize, seed);\n  }\n\n  /**\n   * Force an iterator to execute serially: each next() call will await the\n   * prior one, so that they cannot execute concurrently.\n   */\n  serial(): LazyIterator<T> {\n    return new SerialIterator(this);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n\n// Iterators that just extend LazyIterator directly\n// ============================================================================\n\nclass ArrayIterator<T> extends LazyIterator<T> {\n  private trav = 0;\n  constructor(protected items: T[]) {\n    super();\n  }\n\n  summary() {\n    return `Array of ${this.items.length} items`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.trav >= this.items.length) {\n      return {value: null, done: true};\n    }\n    const item = this.items[this.trav];\n    this.trav++;\n    return {value: deepClone(item), done: false};\n  }\n}\n\nclass FunctionCallIterator<T> extends LazyIterator<T> {\n  constructor(\n      protected nextFn: () => IteratorResult<T>| Promise<IteratorResult<T>>) {\n    super();\n  }\n\n  summary() {\n    return `Function call`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    try {\n      return this.nextFn();\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message =\n          `Error thrown while iterating through a dataset: ${e.message}`;\n      throw e;\n    }\n  }\n}\n\nclass SerialIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  constructor(protected upstream: LazyIterator<T>) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Serial`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    return this.upstream.next();\n  }\n}\n\nclass SkipIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  count = 0;\n\n  constructor(protected upstream: LazyIterator<T>, protected maxCount: number) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Skip`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n    // collecting next() promises in an Array and then waiting for\n    // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n    // maybe delayed GC.\n    while (this.count++ < this.maxCount) {\n      const skipped = await this.upstream.next();\n      // short-circuit if upstream is already empty\n      if (skipped.done) {\n        return skipped;\n      }\n      tf.dispose(skipped.value as {});\n    }\n    return this.upstream.next();\n  }\n}\n\nclass TakeIterator<T> extends LazyIterator<T> {\n  count = 0;\n  constructor(protected upstream: LazyIterator<T>, protected maxCount: number) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Take`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.count++ >= this.maxCount) {\n      return {value: null, done: true};\n    }\n    return this.upstream.next();\n  }\n}\n\n// Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nclass RowMajorBatchIterator<T> extends LazyIterator<T[]> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T[]>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected batchSize: number,\n      protected enableSmallLastBatch = true) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> RowMajorBatch`;\n  }\n\n  async next(): Promise<IteratorResult<T[]>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T[]>> {\n    const batch: T[] = [];\n    while (batch.length < this.batchSize) {\n      const item = await this.upstream.next();\n      if (item.done) {\n        if (this.enableSmallLastBatch && batch.length > 0) {\n          return {value: batch, done: false};\n        }\n        return {value: null, done: true};\n      }\n      batch.push(item.value);\n    }\n    return {value: batch, done: false};\n  }\n}\n\nclass FilterIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>,\n      protected predicate: (value: T) => boolean) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Filter`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    while (true) {\n      const item = await this.upstream.next();\n      if (item.done || this.predicate(item.value)) {\n        return item;\n      }\n      tf.dispose(item.value as {});\n    }\n  }\n}\n\nclass MapIterator<I, O> extends LazyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => O) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Map`;\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return {value: null, done: true};\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // That's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying\n    // any intermediate Tensors.  Here we are concerned only about the\n    // inputs.\n    const mapped = this.transform(item.value);\n    const outputTensors = tf.tensor_util.getTensorsInContainer(mapped as {});\n\n    // TODO(soergel) faster intersection\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n    return {value: mapped, done: false};\n  }\n}\n\nclass ErrorHandlingLazyIterator<T> extends LazyIterator<T> {\n  count = 0;\n  constructor(\n      protected upstream: LazyIterator<T>,\n      protected handler: (error: Error) => boolean) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> handleErrors`;\n  }\n\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    while (true) {\n      try {\n        return await this.upstream.next();\n      } catch (e) {\n        if (!this.handler(e)) {\n          return {value: null, done: true};\n        }\n        // If the handler returns true, loop and fetch the next upstream item.\n\n        // If the upstream iterator throws an endless stream of errors, and if\n        // the handler says to ignore them, then we loop forever here.  That is\n        // the correct behavior-- it's up to the handler to decide when to stop.\n      }\n    }\n  }\n}\n\nclass AsyncMapIterator<I, O> extends LazyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => Promise<O>) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> AsyncMap`;\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return {value: null, done: true};\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // That's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying\n    // any intermediate Tensors.  Here we are concerned only about the\n    // inputs.\n    const mapped = await this.transform(item.value);\n    const outputTensors = tf.tensor_util.getTensorsInContainer(mapped as {});\n\n    // TODO(soergel) faster intersection\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n    return {value: mapped, done: false};\n  }\n}\n\n// Iterators that maintain a queue of pending items\n// ============================================================================\n\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport abstract class OneToManyIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  protected outputQueue: RingBuffer<T>;\n\n  constructor() {\n    super();\n    this.outputQueue = new GrowingRingBuffer<T>();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  /**\n   * Read one or more chunks from upstream and process them, possibly\n   * reading or writing a carryover, and adding processed items to the\n   * output queue.  Note it's possible that no items are added to the queue\n   * on a given pump() call, even if the upstream stream is not closed\n   * (e.g., because items are filtered).\n   *\n   * @return `true` if any action was taken, i.e. fetching items from the\n   *   upstream source OR adding items to the output queue.  `false` if the\n   *   upstream source is exhausted AND nothing was added to the queue\n   * (i.e., any remaining carryover).\n   */\n  protected abstract pump(): Promise<boolean>;\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    // Fetch so that the queue contains at least one item if possible.\n    // If the upstream source is exhausted, AND there are no items left in\n    // the output queue, then this stream is also exhausted.\n    while (this.outputQueue.length() === 0) {\n      // TODO(soergel): consider parallel reads.\n      if (!await this.pump()) {\n        return {value: null, done: true};\n      }\n    }\n    return {value: this.outputQueue.shift(), done: false};\n  }\n}\nclass FlatmapIterator<I, O> extends OneToManyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => O[]) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Flatmap`;\n  }\n\n  async pump(): Promise<boolean> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return false;\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // that's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying any\n    // intermediate Tensors.  Here we are concerned only about the inputs.\n    const mappedArray = this.transform(item.value);\n    const outputTensors =\n        tf.tensor_util.getTensorsInContainer(mappedArray as {});\n    this.outputQueue.pushAll(mappedArray);\n\n    // TODO(soergel) faster intersection, and deduplicate outputTensors\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n\n    return true;\n  }\n}\n\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport class ChainedIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>> = null;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  private iterator: LazyIterator<T> = null;\n  private moreIterators: LazyIterator<LazyIterator<T>>;\n\n  constructor(\n      iterators: LazyIterator<LazyIterator<T>>,\n      private readonly baseErrorHandler?: (e: Error) => boolean) {\n    super();\n    this.moreIterators = iterators;\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n    return `${upstreamSummaries} -> Chained`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    this.lastRead = this.readFromChain(this.lastRead);\n    return this.lastRead;\n  }\n\n  private async readFromChain(lastRead: Promise<IteratorResult<T>>):\n      Promise<IteratorResult<T>> {\n    // Must await on the previous read since the previous read may have advanced\n    // the stream of streams, from which we need to read.\n    // This is unfortunate since we can't parallelize reads. Which means\n    // prefetching of chained streams is a no-op.\n    // One solution is to prefetch immediately upstream of this.\n    await lastRead;\n    if (this.iterator == null) {\n      const iteratorResult = await this.moreIterators.next();\n      if (iteratorResult.done) {\n        // No more streams to stream from.\n        return {value: null, done: true};\n      }\n      this.iterator = iteratorResult.value;\n      if (this.baseErrorHandler != null) {\n        this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n      }\n    }\n    const itemResult = await this.iterator.next();\n    if (itemResult.done) {\n      this.iterator = null;\n      return this.readFromChain(lastRead);\n    }\n    return itemResult;\n  }\n}\n\nexport enum ZipMismatchMode {\n  FAIL,      // require zipped streams to have the same length\n  SHORTEST,  // terminate zip when the first stream is exhausted\n  LONGEST    // use nulls for exhausted streams; use up the longest stream.\n}\n\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nclass ZipIterator<O extends tf.TensorContainer> extends LazyIterator<O> {\n  private count = 0;\n  private currentPromise: Promise<IteratorResult<O>> = null;\n\n  constructor(\n      protected readonly iterators: IteratorContainer,\n      protected readonly mismatchMode: ZipMismatchMode = ZipMismatchMode.FAIL) {\n    super();\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n    return `{${upstreamSummaries}} -> Zip`;\n  }\n\n  private async nextState(afterState: Promise<IteratorResult<O>>):\n      Promise<IteratorResult<O>> {\n    // This chaining ensures that the underlying next() are not even called\n    // before the previous ones have resolved.\n    await afterState;\n\n    // Collect underlying iterator \"done\" signals as a side effect in\n    // getNext()\n    let numIterators = 0;\n    let iteratorsDone = 0;\n\n    function getNext(container: IteratorContainer): DeepMapAsyncResult {\n      if (container instanceof LazyIterator) {\n        const result = container.next();\n        return {\n          value: result.then(x => {\n            numIterators++;\n            if (x.done) {\n              iteratorsDone++;\n            }\n            return x.value;\n          }),\n          recurse: false\n        };\n      } else {\n        return {value: null, recurse: true};\n      }\n    }\n\n    const mapped: O = await deepMapAndAwaitAll(this.iterators, getNext);\n\n    if (numIterators === iteratorsDone) {\n      // The streams have all ended.\n      return {value: null, done: true};\n    }\n    if (iteratorsDone > 0) {\n      switch (this.mismatchMode) {\n        case ZipMismatchMode.FAIL:\n          throw new Error(\n              'Zipped streams should have the same length. ' +\n              `Mismatched at element ${this.count}.`);\n        case ZipMismatchMode.SHORTEST:\n          return {value: null, done: true};\n        case ZipMismatchMode.LONGEST:\n        default:\n          // Continue.  The exhausted streams already produced value: null.\n      }\n    }\n\n    this.count++;\n    return {value: mapped, done: false};\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    this.currentPromise = this.nextState(this.currentPromise);\n    return this.currentPromise;\n  }\n}\n\n// Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport class PrefetchIterator<T> extends LazyIterator<T> {\n  protected buffer: RingBuffer<Promise<IteratorResult<T>>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected bufferSize: number) {\n    super();\n    this.buffer = new RingBuffer<Promise<IteratorResult<T>>>(bufferSize);\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Prefetch`;\n  }\n\n  /**\n   * Refill the prefetch buffer.  Returns only after the buffer is full, or\n   * the upstream source is exhausted.\n   */\n  protected refill() {\n    while (!this.buffer.isFull()) {\n      const v = this.upstream.next();\n      this.buffer.push(v);\n    }\n  }\n\n  next(): Promise<IteratorResult<T>> {\n    this.refill();\n    // This shift will never throw an error because the buffer is always\n    // full after a refill. If the stream is exhausted, the buffer will be\n    // full of Promises that will resolve to the end-of-stream signal.\n    return this.buffer.shift();\n  }\n}\n\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport class ShuffleIterator<T> extends PrefetchIterator<T> {\n  private readonly random: seedrandom.prng;\n\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  private upstreamExhausted = false;\n\n  constructor(\n    protected override upstream: LazyIterator<T>, protected windowSize: number,\n      seed?: string) {\n    super(upstream, windowSize);\n    this.random = seedrandom.alea(seed || tf.util.now().toString());\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  override async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private randomInt(max: number) {\n    return Math.floor(this.random() * max);\n  }\n\n  protected chooseIndex(): number {\n    return this.randomInt(this.buffer.length());\n  }\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    // TODO(soergel): consider performance\n    if (!this.upstreamExhausted) {\n      this.refill();\n    }\n    while (!this.buffer.isEmpty()) {\n      const chosenIndex = this.chooseIndex();\n      const result = await this.buffer.shuffleExcise(chosenIndex);\n      if (result.done) {\n        this.upstreamExhausted = true;\n      } else {\n        this.refill();\n        return result;\n      }\n    }\n    return {value: null, done: true};\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}