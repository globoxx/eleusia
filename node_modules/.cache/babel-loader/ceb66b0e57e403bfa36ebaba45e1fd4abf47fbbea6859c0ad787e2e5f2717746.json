{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Mean, util } from '@tensorflow/tfjs-core';\nimport { meanImpl } from './Mean_impl';\nimport { transposeImpl, transposeImplCPU } from './Transpose_impl';\nexport var meanConfig = {\n  kernelName: Mean,\n  backendName: 'webgl',\n  kernelFunc: function kernelFunc(_ref) {\n    var inputs = _ref.inputs,\n      attrs = _ref.attrs,\n      backend = _ref.backend;\n    var x = inputs.x;\n    var keepDims = attrs.keepDims,\n      axis = attrs.axis;\n    var webglBackend = backend;\n    var xRank = x.shape.length;\n    var origAxes = util.parseAxisParam(axis, x.shape);\n    var axes = origAxes;\n    var permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    var meanInputIsTransposed = permutedAxes != null;\n    var shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n    var intermediates = [];\n    var meanInput = x;\n    if (meanInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        var xTexData = webglBackend.texData.get(meanInput.dataId);\n        var values = xTexData.values;\n        var newShape = new Array(xRank);\n        for (var i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        var meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n        meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        var meanInputData = webglBackend.texData.get(meanInput.dataId);\n        meanInputData.values = meanInputValues;\n      } else {\n        meanInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n      intermediates.push(meanInput);\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n    backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    var _backend_util$compute = backend_util.computeOutAndReduceShapes(meanInput.shape, axes),\n      _backend_util$compute2 = _slicedToArray(_backend_util$compute, 2),\n      meanOutShape = _backend_util$compute2[0],\n      reduceShape = _backend_util$compute2[1];\n    var outShape = meanOutShape;\n    if (keepDims) {\n      // rather than reshape at the end, set the target shape here.\n      outShape = backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n    }\n    var out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n    for (var _i = 0, _intermediates = intermediates; _i < _intermediates.length; _i++) {\n      var _i2 = _intermediates[_i];\n      webglBackend.disposeIntermediateTensorInfo(_i2);\n    }\n    return out;\n  }\n};","map":{"version":3,"names":["backend_util","Mean","util","meanImpl","transposeImpl","transposeImplCPU","meanConfig","kernelName","backendName","kernelFunc","_ref","inputs","attrs","backend","x","keepDims","axis","webglBackend","xRank","shape","length","origAxes","parseAxisParam","axes","permutedAxes","getAxesPermutation","meanInputIsTransposed","shouldExecuteOnCPU","intermediates","meanInput","xTexData","texData","get","dataId","values","newShape","Array","i","meanInputValues","dtype","makeTensorInfo","meanInputData","push","getInnerMostAxes","assertAxesAreInnerMostDims","_backend_util$compute","computeOutAndReduceShapes","_backend_util$compute2","_slicedToArray","meanOutShape","reduceShape","outShape","expandShapeToKeepDim","out","_i","_intermediates","disposeIntermediateTensorInfo"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\kernels\\Mean.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Mean, MeanAttrs, MeanInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {meanImpl} from './Mean_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport const meanConfig: KernelConfig = {\n  kernelName: Mean,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MeanInputs;\n    const {keepDims, axis} = attrs as unknown as MeanAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const meanInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n\n    const intermediates: TensorInfo[] = [];\n\n    let meanInput = x;\n    if (meanInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        const xTexData = webglBackend.texData.get(meanInput.dataId);\n        const values = xTexData.values as TypedArray;\n\n        const newShape: number[] = new Array(xRank);\n        for (let i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        const meanInputValues =\n            transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n        meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const meanInputData = webglBackend.texData.get(meanInput.dataId);\n        meanInputData.values = meanInputValues;\n      } else {\n        meanInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n\n      intermediates.push(meanInput);\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n\n    backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    const [meanOutShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(meanInput.shape, axes);\n\n    let outShape = meanOutShape;\n    if (keepDims) {\n      // rather than reshape at the end, set the target shape here.\n      outShape = backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n    }\n\n    const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n    for (const i of intermediates) {\n      webglBackend.disposeIntermediateTensorInfo(i);\n    }\n\n    return out;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}