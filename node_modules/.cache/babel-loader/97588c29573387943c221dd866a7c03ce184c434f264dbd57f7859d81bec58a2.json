{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * =============================================================================\r\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nvar CODE_QUOTE = '\"';\nvar STATE_OUT = Symbol('out');\nvar STATE_FIELD = Symbol('field');\nvar STATE_QUOTE = Symbol('quote');\nvar STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nvar STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\r\n * Represents a potentially large collection of delimited text records.\r\n *\r\n * The produced `TensorContainer`s each contain one key-value pair for\r\n * every column of the table.  When a field is empty in the incoming data, the\r\n * resulting value is `undefined`, or throw error if it is required.  Values\r\n * that can be parsed as numbers are emitted as type `number`, other values\r\n * are parsed as `string`.\r\n *\r\n * The results are not batched.\r\n *\r\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\r\n */\nexport var CSVDataset = /*#__PURE__*/function (_Dataset) {\n  _inherits(CSVDataset, _Dataset);\n  var _super = _createSuper(CSVDataset);\n  /**\r\n   * Create a `CSVDataset`.\r\n   *\r\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\r\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\r\n   *     of reading and decoding from CSV file(s).\r\n   *\r\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\r\n   *     row of provided CSV file is a header line with column names, and should\r\n   *     not be included in the data. Defaults to `true`.\r\n   *\r\n   *     columnNames: (Optional) A list of strings that corresponds to\r\n   *     the CSV column names, in order. If provided, it ignores the column\r\n   *     names inferred from the header row. If not provided, infers the column\r\n   *     names from the first row of the records. If hasHeader is false and\r\n   *     columnNames is not provided, this method throws an error.\r\n   *\r\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\r\n   *     is an object stating if this column is required, column's data type,\r\n   *     default value, and if this column is label. If provided, keys must\r\n   *     correspond to names provided in columnNames or inferred from the file\r\n   *     header lines. If isLabel is true any column, returns an array of two\r\n   *     items: the first item is a dict of features key/value pairs, the second\r\n   *     item is a dict of labels key/value pairs. If no feature is marked as\r\n   *     label, returns a dict of features only.\r\n   *\r\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\r\n   *     columnConfigs will be parsed and provided during iteration.\r\n   *\r\n   *     delimiter (Optional) The string used to parse each line of the input\r\n   *     file. Defaults to `,`.\r\n   */\n  function CSVDataset(input, csvConfig) {\n    var _this;\n    _classCallCheck(this, CSVDataset);\n    _this = _super.call(this);\n    _this.input = input;\n    _this.hasHeader = true;\n    _this.fullColumnNames = null;\n    _this.columnNamesValidated = false;\n    _this.columnConfigs = null;\n    _this.configuredColumnsOnly = false;\n    _this.delimiter = ',';\n    _this.delimWhitespace = false;\n    _this.base = new TextLineDataset(input);\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n    _this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    _this.fullColumnNames = csvConfig.columnNames;\n    _this.columnConfigs = csvConfig.columnConfigs;\n    _this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n    if (csvConfig.delimWhitespace) {\n      util.assert(csvConfig.delimiter == null, function () {\n        return 'Delimiter should not be provided when delimWhitespace is true.';\n      });\n      _this.delimWhitespace = true;\n      _this.delimiter = ' ';\n    } else {\n      _this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n    return _this;\n  }\n  _createClass(CSVDataset, [{\n    key: \"columnNames\",\n    value:\n    /**\r\n     * Returns column names of the csv dataset. If `configuredColumnsOnly` is\r\n     * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\r\n     * false and `columnNames` is provided, `columnNames`. If\r\n     * `configuredColumnsOnly` is false and `columnNames` is not provided, return\r\n     * all column names parsed from the csv file. For example usage please go to\r\n     * `tf.data.csv`.\r\n     *\r\n     * @doc {heading: 'Data', subheading: 'Classes'}\r\n     */\n    function () {\n      var _columnNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.columnNamesValidated) {\n                _context.next = 3;\n                break;\n              }\n              _context.next = 3;\n              return this.setColumnNames();\n            case 3:\n              return _context.abrupt(\"return\", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function columnNames() {\n        return _columnNames.apply(this, arguments);\n      }\n      return columnNames;\n    }()\n    /* 1) If `columnNames` is provided as string[], use this string[] as output\r\n     * keys in corresponding order. The length must match the number of inferred\r\n     * columns if `hasHeader` is true .\r\n     * 2) If `columnNames` is not provided, parse header line as `columnNames` if\r\n     * hasHeader is true. If `hasHeader` is false, throw an error.\r\n     * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\r\n     * exist in parsed `columnNames`.\r\n     */\n  }, {\n    key: \"setColumnNames\",\n    value: function () {\n      var _setColumnNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this2 = this;\n        var columnNamesFromFile, counts, duplicateNames, _i, _Object$keys, key, index;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.maybeReadHeaderLine();\n            case 2:\n              columnNamesFromFile = _context2.sent;\n              if (!(!this.fullColumnNames && !columnNamesFromFile)) {\n                _context2.next = 7;\n                break;\n              }\n              throw new Error('Column names must be provided if there is no header line.');\n            case 7:\n              if (this.fullColumnNames && columnNamesFromFile) {\n                // Check provided columnNames match header line.\n                util.assert(columnNamesFromFile.length === this.fullColumnNames.length, function () {\n                  return 'The length of provided columnNames (' + _this2.fullColumnNames.length.toString() + ') does not match the length of the header line read from ' + 'file (' + columnNamesFromFile.length.toString() + ').';\n                });\n              }\n            case 8:\n              if (!this.fullColumnNames) {\n                this.fullColumnNames = columnNamesFromFile;\n              }\n              // Check if there are duplicate column names.\n              counts = this.fullColumnNames.reduce(function (countAcc, name) {\n                countAcc[name] = countAcc[name] + 1 || 1;\n                return countAcc;\n              }, {});\n              duplicateNames = Object.keys(counts).filter(function (name) {\n                return counts[name] > 1;\n              });\n              util.assert(duplicateNames.length === 0, function () {\n                return 'Duplicate column names found: ' + duplicateNames.toString();\n              });\n              // Check if keys in columnConfigs match columnNames.\n              if (!this.columnConfigs) {\n                _context2.next = 22;\n                break;\n              }\n              _i = 0, _Object$keys = Object.keys(this.columnConfigs);\n            case 14:\n              if (!(_i < _Object$keys.length)) {\n                _context2.next = 22;\n                break;\n              }\n              key = _Object$keys[_i];\n              index = this.fullColumnNames.indexOf(key);\n              if (!(index === -1)) {\n                _context2.next = 19;\n                break;\n              }\n              throw new Error('The key \"' + key + '\" provided in columnConfigs does not match any of the column ' + 'names (' + this.fullColumnNames.toString() + ').');\n            case 19:\n              _i++;\n              _context2.next = 14;\n              break;\n            case 22:\n              this.columnNamesValidated = true;\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function setColumnNames() {\n        return _setColumnNames.apply(this, arguments);\n      }\n      return setColumnNames;\n    }()\n  }, {\n    key: \"maybeReadHeaderLine\",\n    value: function () {\n      var _maybeReadHeaderLine = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var iter, firstElement, firstLine, headers;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!this.hasHeader) {\n                _context3.next = 14;\n                break;\n              }\n              _context3.next = 3;\n              return this.base.iterator();\n            case 3:\n              iter = _context3.sent;\n              _context3.next = 6;\n              return iter.next();\n            case 6:\n              firstElement = _context3.sent;\n              if (!firstElement.done) {\n                _context3.next = 9;\n                break;\n              }\n              throw new Error('No data was found for CSV parsing.');\n            case 9:\n              firstLine = firstElement.value;\n              headers = this.parseRow(firstLine, false);\n              return _context3.abrupt(\"return\", headers);\n            case 14:\n              return _context3.abrupt(\"return\", null);\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function maybeReadHeaderLine() {\n        return _maybeReadHeaderLine.apply(this, arguments);\n      }\n      return maybeReadHeaderLine;\n    }()\n  }, {\n    key: \"iterator\",\n    value: function () {\n      var _iterator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this3 = this;\n        var lines;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.columnNamesValidated) {\n                _context4.next = 3;\n                break;\n              }\n              _context4.next = 3;\n              return this.setColumnNames();\n            case 3:\n              _context4.next = 5;\n              return this.base.iterator();\n            case 5:\n              lines = _context4.sent;\n              if (this.hasHeader) {\n                // We previously read the first line to get the columnNames.\n                // Now that we're providing data, skip it.\n                lines = lines.skip(1);\n              }\n              return _context4.abrupt(\"return\", lines.map(function (x) {\n                return _this3.makeDataElement(x);\n              }));\n            case 8:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function iterator() {\n        return _iterator.apply(this, arguments);\n      }\n      return iterator;\n    }()\n  }, {\n    key: \"makeDataElement\",\n    value: function makeDataElement(line) {\n      var values = this.parseRow(line);\n      var features = {};\n      var labels = {};\n      for (var i = 0; i < this.fullColumnNames.length; i++) {\n        var key = this.fullColumnNames[i];\n        var config = this.columnConfigs ? this.columnConfigs[key] : null;\n        if (this.configuredColumnsOnly && !config) {\n          // This column is not selected.\n          continue;\n        } else {\n          var value = values[i];\n          var parsedValue = null;\n          if (value === '') {\n            // If default value is provided, use it. If default value is not\n            // provided, set as undefined.\n            if (config && config.default !== undefined) {\n              parsedValue = config.default;\n            } else if (config && (config.required || config.isLabel)) {\n              throw new Error(\"Required column \".concat(key, \" is empty in this line: \").concat(line));\n            } else {\n              parsedValue = undefined;\n            }\n          } else {\n            // A value is present, so parse it based on type\n            var valueAsNum = Number(value);\n            if (isNaN(valueAsNum)) {\n              // The value is a string and this column is declared as boolean\n              // in config, parse it as boolean.\n              if (config && config.dtype === 'bool') {\n                parsedValue = this.getBoolean(value);\n              } else {\n                // Set value as string\n                parsedValue = value;\n              }\n            } else if (!config || !config.dtype) {\n              // If this value is a number and no type config is provided, return\n              // it as number.\n              parsedValue = valueAsNum;\n            } else {\n              // If this value is a number and data type is provided, parse it\n              // according to provided data type.\n              switch (config.dtype) {\n                case 'float32':\n                  parsedValue = valueAsNum;\n                  break;\n                case 'int32':\n                  parsedValue = Math.floor(valueAsNum);\n                  break;\n                case 'bool':\n                  parsedValue = this.getBoolean(value);\n                  break;\n                default:\n                  parsedValue = valueAsNum;\n              }\n            }\n          }\n          // Check if this column is label.\n          config && config.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;\n        }\n      }\n      // If label exists, return an object of features and labels as {xs:features,\n      // ys:labels}, otherwise return features only.\n      if (Object.keys(labels).length === 0) {\n        return features;\n      } else {\n        return {\n          xs: features,\n          ys: labels\n        };\n      }\n    }\n  }, {\n    key: \"getBoolean\",\n    value: function getBoolean(value) {\n      if (value === '1' || value.toLowerCase() === 'true') {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n  }, {\n    key: \"parseRow\",\n    value: function parseRow(line) {\n      var validateElementCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var result = [];\n      var readOffset = 0;\n      var readLength = line.length;\n      var currentState = STATE_OUT;\n      // Goes through the line to parse quote.\n      for (var i = 0; i < readLength; i++) {\n        switch (currentState) {\n          // Before enter a new field\n          case STATE_OUT:\n            switch (line.charAt(i)) {\n              // Enter a quoted field\n              case CODE_QUOTE:\n                readOffset = i + 1;\n                currentState = STATE_QUOTE;\n                break;\n              // Read an empty field\n              case this.delimiter:\n                readOffset = i + 1;\n                // If delimiter is white space and configured to collapse\n                // multiple white spaces, ignore this white space.\n                if (this.delimiter === ' ' && this.delimWhitespace) {\n                  break;\n                }\n                result.push('');\n                currentState = STATE_OUT;\n                break;\n              // Enter an unquoted field\n              default:\n                currentState = STATE_FIELD;\n                readOffset = i;\n                break;\n            }\n            break;\n          // In an unquoted field\n          case STATE_FIELD:\n            switch (line.charAt(i)) {\n              // Exit an unquoted field, add it to result\n              case this.delimiter:\n                result.push(line.substring(readOffset, i));\n                currentState = STATE_OUT;\n                readOffset = i + 1;\n                break;\n              default:\n            }\n            break;\n          // In a quoted field\n          case STATE_QUOTE:\n            switch (line.charAt(i)) {\n              // Read a quote after a quote\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE_AFTER_QUOTE;\n                break;\n              default:\n            }\n            break;\n          // This state means it's right after a second quote in a field\n          case STATE_QUOTE_AFTER_QUOTE:\n            switch (line.charAt(i)) {\n              // Finished a quoted field\n              case this.delimiter:\n                result.push(line.substring(readOffset, i - 1));\n                currentState = STATE_OUT;\n                readOffset = i + 1;\n                break;\n              // Finished a quoted part in a quoted field\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE;\n                break;\n              // In a quoted part in a quoted field\n              default:\n                currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n                break;\n            }\n            break;\n          case STATE_WITHIN_QUOTE_IN_QUOTE:\n            switch (line.charAt(i)) {\n              // Exit a quoted part in a quoted field\n              case CODE_QUOTE:\n                currentState = STATE_QUOTE;\n                break;\n              default:\n            }\n            break;\n          default:\n        }\n      }\n      // Adds last item based on if it is quoted.\n      if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n        result.push(line.substring(readOffset, readLength - 1));\n      } else {\n        result.push(line.substring(readOffset));\n      }\n      // Check if each row has the same number of elements as column names.\n      if (validateElementCount && result.length !== this.fullColumnNames.length) {\n        throw new Error(\"Invalid row in csv file. Should have \".concat(this.fullColumnNames.length, \" elements in a row, but got \").concat(result));\n      }\n      return result;\n    }\n  }]);\n  return CSVDataset;\n}(Dataset);\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()","map":{"version":3,"names":["util","Dataset","TextLineDataset","CODE_QUOTE","STATE_OUT","Symbol","STATE_FIELD","STATE_QUOTE","STATE_QUOTE_AFTER_QUOTE","STATE_WITHIN_QUOTE_IN_QUOTE","CSVDataset","_Dataset","_inherits","_super","_createSuper","input","csvConfig","_this","_classCallCheck","call","hasHeader","fullColumnNames","columnNamesValidated","columnConfigs","configuredColumnsOnly","delimiter","delimWhitespace","base","columnNames","assert","_createClass","key","value","_columnNames","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","setColumnNames","abrupt","Object","keys","stop","apply","arguments","_setColumnNames","_callee2","_this2","columnNamesFromFile","counts","duplicateNames","_i","_Object$keys","index","_callee2$","_context2","maybeReadHeaderLine","sent","Error","length","toString","reduce","countAcc","name","filter","indexOf","_maybeReadHeaderLine","_callee3","iter","firstElement","firstLine","headers","_callee3$","_context3","iterator","done","parseRow","_iterator","_callee4","_this3","lines","_callee4$","_context4","skip","map","x","makeDataElement","line","values","features","labels","i","config","parsedValue","default","undefined","required","isLabel","concat","valueAsNum","Number","isNaN","dtype","getBoolean","Math","floor","xs","ys","toLowerCase","validateElementCount","result","readOffset","readLength","currentState","charAt","push","substring"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-data\\src\\datasets\\csv_dataset.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {Dataset} from '../dataset';\nimport {DataSource} from '../datasource';\nimport {LazyIterator} from '../iterators/lazy_iterator';\nimport {ColumnConfig, CSVConfig} from '../types';\nimport {TextLineDataset} from './text_line_dataset';\n\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport class CSVDataset extends Dataset<TensorContainer> {\n  base: TextLineDataset;\n  private hasHeader = true;\n  private fullColumnNames: string[] = null;\n  private columnNamesValidated = false;\n  private columnConfigs: {[key: string]: ColumnConfig} = null;\n  private configuredColumnsOnly = false;\n  private delimiter = ',';\n  private delimWhitespace = false;\n\n  /**\n   * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n   * false and `columnNames` is provided, `columnNames`. If\n   * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n   * all column names parsed from the csv file. For example usage please go to\n   * `tf.data.csv`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  async columnNames() {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n    return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :\n                                        this.fullColumnNames;\n  }\n\n  /* 1) If `columnNames` is provided as string[], use this string[] as output\n   * keys in corresponding order. The length must match the number of inferred\n   * columns if `hasHeader` is true .\n   * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n   * hasHeader is true. If `hasHeader` is false, throw an error.\n   * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n   * exist in parsed `columnNames`.\n   */\n  private async setColumnNames() {\n    const columnNamesFromFile = await this.maybeReadHeaderLine();\n    if (!this.fullColumnNames && !columnNamesFromFile) {\n      // Throw an error if columnNames is not provided and no header line.\n      throw new Error(\n          'Column names must be provided if there is no header line.');\n    } else if (this.fullColumnNames && columnNamesFromFile) {\n      // Check provided columnNames match header line.\n      util.assert(\n          columnNamesFromFile.length === this.fullColumnNames.length,\n          () => 'The length of provided columnNames (' +\n              this.fullColumnNames.length.toString() +\n              ') does not match the length of the header line read from ' +\n              'file (' + columnNamesFromFile.length.toString() + ').');\n    }\n    if (!this.fullColumnNames) {\n      this.fullColumnNames = columnNamesFromFile;\n    }\n    // Check if there are duplicate column names.\n    const counts: {[key: string]: number} = this.fullColumnNames.reduce(\n        (countAcc: {[key: string]: number}, name) => {\n          countAcc[name] = (countAcc[name] + 1) || 1;\n          return countAcc;\n        },\n        {});\n    const duplicateNames =\n        Object.keys(counts).filter((name) => (counts[name] > 1));\n    util.assert(\n        duplicateNames.length === 0,\n        () => 'Duplicate column names found: ' + duplicateNames.toString());\n    // Check if keys in columnConfigs match columnNames.\n    if (this.columnConfigs) {\n      for (const key of Object.keys(this.columnConfigs)) {\n        const index = this.fullColumnNames.indexOf(key);\n        if (index === -1) {\n          throw new Error(\n              'The key \"' + key +\n              '\" provided in columnConfigs does not match any of the column ' +\n              'names (' + this.fullColumnNames.toString() + ').');\n        }\n      }\n    }\n    this.columnNamesValidated = true;\n  }\n\n  private async maybeReadHeaderLine() {\n    if (this.hasHeader) {\n      const iter = await this.base.iterator();\n      const firstElement = await iter.next();\n      if (firstElement.done) {\n        throw new Error('No data was found for CSV parsing.');\n      }\n      const firstLine: string = firstElement.value;\n      const headers = this.parseRow(firstLine, false);\n      return headers;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Create a `CSVDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\n   *     row of provided CSV file is a header line with column names, and should\n   *     not be included in the data. Defaults to `true`.\n   *\n   *     columnNames: (Optional) A list of strings that corresponds to\n   *     the CSV column names, in order. If provided, it ignores the column\n   *     names inferred from the header row. If not provided, infers the column\n   *     names from the first row of the records. If hasHeader is false and\n   *     columnNames is not provided, this method throws an error.\n   *\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\n   *     is an object stating if this column is required, column's data type,\n   *     default value, and if this column is label. If provided, keys must\n   *     correspond to names provided in columnNames or inferred from the file\n   *     header lines. If isLabel is true any column, returns an array of two\n   *     items: the first item is a dict of features key/value pairs, the second\n   *     item is a dict of labels key/value pairs. If no feature is marked as\n   *     label, returns a dict of features only.\n   *\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\n   *     columnConfigs will be parsed and provided during iteration.\n   *\n   *     delimiter (Optional) The string used to parse each line of the input\n   *     file. Defaults to `,`.\n   */\n  constructor(protected readonly input: DataSource, csvConfig?: CSVConfig) {\n    super();\n    this.base = new TextLineDataset(input);\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n    this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    this.fullColumnNames = csvConfig.columnNames;\n    this.columnConfigs = csvConfig.columnConfigs;\n    this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n    if (csvConfig.delimWhitespace) {\n      util.assert(\n          csvConfig.delimiter == null,\n          () =>\n              'Delimiter should not be provided when delimWhitespace is true.');\n      this.delimWhitespace = true;\n      this.delimiter = ' ';\n    } else {\n      this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n  }\n\n  async iterator(): Promise<LazyIterator<TensorContainer>> {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n    let lines = await this.base.iterator();\n    if (this.hasHeader) {\n      // We previously read the first line to get the columnNames.\n      // Now that we're providing data, skip it.\n      lines = lines.skip(1);\n    }\n    return lines.map(x => this.makeDataElement(x));\n  }\n\n  makeDataElement(line: string): TensorContainer {\n    const values = this.parseRow(line);\n    const features: {[key: string]: TensorContainer} = {};\n    const labels: {[key: string]: TensorContainer} = {};\n\n    for (let i = 0; i < this.fullColumnNames.length; i++) {\n      const key = this.fullColumnNames[i];\n      const config = this.columnConfigs ? this.columnConfigs[key] : null;\n      if (this.configuredColumnsOnly && !config) {\n        // This column is not selected.\n        continue;\n      } else {\n        const value = values[i];\n        let parsedValue = null;\n        if (value === '') {\n          // If default value is provided, use it. If default value is not\n          // provided, set as undefined.\n          if (config && config.default !== undefined) {\n            parsedValue = config.default;\n          } else if (config && (config.required || config.isLabel)) {\n            throw new Error(\n                `Required column ${key} is empty in this line: ${line}`);\n          } else {\n            parsedValue = undefined;\n          }\n        } else {\n          // A value is present, so parse it based on type\n          const valueAsNum = Number(value);\n          if (isNaN(valueAsNum)) {\n            // The value is a string and this column is declared as boolean\n            // in config, parse it as boolean.\n            if (config && config.dtype === 'bool') {\n              parsedValue = this.getBoolean(value);\n            } else {\n              // Set value as string\n              parsedValue = value;\n            }\n          } else if (!config || !config.dtype) {\n            // If this value is a number and no type config is provided, return\n            // it as number.\n            parsedValue = valueAsNum;\n          } else {\n            // If this value is a number and data type is provided, parse it\n            // according to provided data type.\n            switch (config.dtype) {\n              case 'float32':\n                parsedValue = valueAsNum;\n                break;\n              case 'int32':\n                parsedValue = Math.floor(valueAsNum);\n                break;\n              case 'bool':\n                parsedValue = this.getBoolean(value);\n                break;\n              default:\n                parsedValue = valueAsNum;\n            }\n          }\n        }\n        // Check if this column is label.\n        (config && config.isLabel) ? labels[key] = parsedValue :\n                                     features[key] = parsedValue;\n      }\n    }\n    // If label exists, return an object of features and labels as {xs:features,\n    // ys:labels}, otherwise return features only.\n    if (Object.keys(labels).length === 0) {\n      return features;\n\n    } else {\n      return {xs: features, ys: labels};\n    }\n  }\n\n  private getBoolean(value: string): number {\n    if (value === '1' || value.toLowerCase() === 'true') {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n  private parseRow(line: string, validateElementCount = true): string[] {\n    const result: string[] = [];\n    let readOffset = 0;\n    const readLength = line.length;\n    let currentState = STATE_OUT;\n    // Goes through the line to parse quote.\n    for (let i = 0; i < readLength; i++) {\n      switch (currentState) {\n        // Before enter a new field\n        case STATE_OUT:\n          switch (line.charAt(i)) {\n            // Enter a quoted field\n            case CODE_QUOTE:\n              readOffset = i + 1;\n              currentState = STATE_QUOTE;\n              break;\n            // Read an empty field\n            case this.delimiter:\n              readOffset = i + 1;\n              // If delimiter is white space and configured to collapse\n              // multiple white spaces, ignore this white space.\n              if (this.delimiter === ' ' && this.delimWhitespace) {\n                break;\n              }\n              result.push('');\n              currentState = STATE_OUT;\n              break;\n            // Enter an unquoted field\n            default:\n              currentState = STATE_FIELD;\n              readOffset = i;\n              break;\n          }\n          break;\n        // In an unquoted field\n        case STATE_FIELD:\n          switch (line.charAt(i)) {\n            // Exit an unquoted field, add it to result\n            case this.delimiter:\n              result.push(line.substring(readOffset, i));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            default:\n          }\n          break;\n        // In a quoted field\n        case STATE_QUOTE:\n          switch (line.charAt(i)) {\n            // Read a quote after a quote\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE_AFTER_QUOTE;\n              break;\n            default:\n          }\n          break;\n        // This state means it's right after a second quote in a field\n        case STATE_QUOTE_AFTER_QUOTE:\n          switch (line.charAt(i)) {\n            // Finished a quoted field\n            case this.delimiter:\n              result.push(line.substring(readOffset, i - 1));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            // Finished a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            // In a quoted part in a quoted field\n            default:\n              currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n              break;\n          }\n          break;\n        case STATE_WITHIN_QUOTE_IN_QUOTE:\n          switch (line.charAt(i)) {\n            // Exit a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            default:\n          }\n          break;\n        default:\n      }\n    }\n    // Adds last item based on if it is quoted.\n    if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n      result.push(line.substring(readOffset, readLength - 1));\n    } else {\n      result.push(line.substring(readOffset));\n    }\n    // Check if each row has the same number of elements as column names.\n    if (validateElementCount && result.length !== this.fullColumnNames.length) {\n      throw new Error(`Invalid row in csv file. Should have ${\n          this.fullColumnNames.length} elements in a row, but got ${result}`);\n    }\n    return result;\n  }\n}\n\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}