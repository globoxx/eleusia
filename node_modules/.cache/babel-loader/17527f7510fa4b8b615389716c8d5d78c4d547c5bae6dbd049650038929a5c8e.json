{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var RowPartitionType;\n(function (RowPartitionType) {\n  RowPartitionType[RowPartitionType[\"FIRST_DIM_SIZE\"] = 0] = \"FIRST_DIM_SIZE\";\n  RowPartitionType[RowPartitionType[\"VALUE_ROWIDS\"] = 1] = \"VALUE_ROWIDS\";\n  RowPartitionType[RowPartitionType[\"ROW_LENGTHS\"] = 2] = \"ROW_LENGTHS\";\n  RowPartitionType[RowPartitionType[\"ROW_SPLITS\"] = 3] = \"ROW_SPLITS\";\n  RowPartitionType[RowPartitionType[\"ROW_LIMITS\"] = 4] = \"ROW_LIMITS\";\n  RowPartitionType[RowPartitionType[\"ROW_STARTS\"] = 5] = \"ROW_STARTS\";\n})(RowPartitionType || (RowPartitionType = {}));\nexport function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n  var outputShape = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(\"rt input.shape and shape=\".concat(shape, \" are incompatible: rt input.rank = \").concat(raggedRank + valueShape.length, \", but shape.rank = \").concat(outputShape.length));\n  }\n  for (var i = 1; i < valueShape.length; ++i) {\n    var valueDim = valueShape[i];\n    var outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];\n    var outputShapeDim = outputShape[outputShapeDimIndex];\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(\"rt input.shape and shape=\".concat(shape, \" are incompatible: rt input.shape[\").concat(i + raggedRank, \"] = \").concat(valueDim, \" but shape[\").concat(i + raggedRank, \"] = \").concat(outputShapeDim));\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings) {\n  var stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n  var result = [];\n  var _iterator = _createForOfIteratorHelper(rowPartitionTypeStrings),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var typeStr = _step.value;\n      if (typeStr in stringToType) {\n        result.push(stringToType[typeStr]);\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\nexport function getRaggedRank(rowPartitionTypes) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\nexport function validateDefaultValueShape(defaultValueShape, valueShape) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n  var defaultNDims = defaultValueShape.length;\n  var valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(\"defaultValue.shape=\".concat(defaultValueShape, \" and ragged tensor flatValues.shape=\").concat(valueShape, \", are incompatible: defaultValue.rank = \").concat(defaultNDims, \" must be less than ragged tensor input flatValues.rank = \").concat(valuesNDims, \")\"));\n  }\n  for (var i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    var defaultDim = defaultValueShape[i];\n    var valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {\n      throw new Error(\"defaultValue.shape=\".concat(defaultValueShape, \", and ragged tensor input flatValues.shape=\").concat(valueShape, \" are incompatible: defaultValue.shape[\").concat(i - defaultValueShape.length, \"] = \").concat(defaultDim, \" but ragged tensor input.flatValues.shape[\").concat(i - defaultValueShape.length, \"] = \").concat(valueDim));\n    }\n  }\n}","map":{"version":3,"names":["RowPartitionType","combineRaggedTensorToTensorShapes","raggedRank","shape","valueShape","outputShape","Array","length","push","slice","Error","concat","i","valueDim","outputShapeDimIndex","outputShapeDim","getRowPartitionTypesHelper","rowPartitionTypeStrings","stringToType","FIRST_DIM_SIZE","VALUE_ROWIDS","ROW_LENGTHS","ROW_SPLITS","ROW_LIMITS","ROW_STARTS","result","_iterator","_createForOfIteratorHelper","_step","s","n","done","typeStr","value","err","e","f","getRaggedRank","rowPartitionTypes","validateDefaultValueShape","defaultValueShape","defaultNDims","valuesNDims","Math","min","defaultDim"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\ops\\ragged_to_dense_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum RowPartitionType {\n  FIRST_DIM_SIZE,\n  VALUE_ROWIDS,\n  ROW_LENGTHS,\n  ROW_SPLITS,\n  ROW_LIMITS,\n  ROW_STARTS\n}\n\nexport function combineRaggedTensorToTensorShapes(\n    raggedRank: number, shape: number[], valueShape: number[]) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n\n  let outputShape: number[] = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(\n        `rt input.shape and shape=${shape} are incompatible: rt input.rank = ${\n            raggedRank +\n            valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex =\n        outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${\n              shape} are incompatible: rt input.shape[${i + raggedRank}] = ${\n              valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\n\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings: string[]) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n\n  const result: RowPartitionType[] = [];\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr as keyof typeof stringToType]);\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport function getRaggedRank(rowPartitionTypes: RowPartitionType[]) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\n\nexport function validateDefaultValueShape(\n    defaultValueShape: number[], valueShape: number[]) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${\n        defaultValueShape} and ragged tensor flatValues.shape=${\n        valueShape}, are incompatible: defaultValue.rank = ${\n        defaultNDims} must be less than ragged tensor input flatValues.rank = ${\n        valuesNDims})`);\n  }\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 &&\n        defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${\n          defaultValueShape}, and ragged tensor input flatValues.shape=${\n          valueShape} are incompatible: defaultValue.shape[${\n          i - defaultValueShape.length}] = ${\n          defaultDim} but ragged tensor input.flatValues.shape[${\n          i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}