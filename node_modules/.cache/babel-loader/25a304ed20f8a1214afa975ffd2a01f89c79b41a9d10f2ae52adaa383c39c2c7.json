{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport var RingBuffer = /*#__PURE__*/function () {\n  /**\n   * Constructs a `RingBuffer`.\n   * @param capacity The number of items that the buffer can accomodate.\n   */\n  function RingBuffer(capacity) {\n    _classCallCheck(this, RingBuffer);\n    this.capacity = capacity;\n    // Note we store the indices in the range 0 <= index < 2*capacity.\n    // This allows us to distinguish the full from the empty case.\n    // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n    this.begin = 0; // inclusive\n    this.end = 0; // exclusive\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n    this.data = new Array(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n  /**\n   * Map any index into the range 0 <= index < 2*capacity.\n   */\n  _createClass(RingBuffer, [{\n    key: \"wrap\",\n    value: function wrap(index) {\n      // don't trust % on negative numbers\n      while (index < 0) {\n        index += this.doubledCapacity;\n      }\n      return index % this.doubledCapacity;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      if (index < 0) {\n        throw new RangeError('Can\\'t get item at a negative index.');\n      }\n      return this.data[index % this.capacity];\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      if (index < 0) {\n        throw new RangeError('Can\\'t set item at a negative index.');\n      }\n      this.data[index % this.capacity] = value;\n    }\n    /**\n     * Returns the current number of items in the buffer.\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      var length = this.end - this.begin;\n      if (length < 0) {\n        length = this.doubledCapacity + length;\n      }\n      return length;\n    }\n    /**\n     * Reports whether the buffer is full.\n     * @returns true if the number of items in the buffer equals its capacity, and\n     *   false otherwise.\n     */\n  }, {\n    key: \"isFull\",\n    value: function isFull() {\n      return this.length() === this.capacity;\n    }\n    /**\n     * Reports whether the buffer is empty.\n     * @returns true if the number of items in the buffer equals zero, and\n     *   false otherwise.\n     */\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.length() === 0;\n    }\n    /**\n     * Adds an item to the end of the buffer.\n     */\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      if (this.isFull()) {\n        throw new RangeError('Ring buffer is full.');\n      }\n      this.set(this.end, value);\n      this.end = this.wrap(this.end + 1);\n    }\n    /**\n     * Adds many items to the end of the buffer, in order.\n     */\n  }, {\n    key: \"pushAll\",\n    value: function pushAll(values) {\n      var _iterator = _createForOfIteratorHelper(values),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var value = _step.value;\n          this.push(value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Removes and returns the last item in the buffer.\n     */\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.isEmpty()) {\n        throw new RangeError('Ring buffer is empty.');\n      }\n      this.end = this.wrap(this.end - 1);\n      var result = this.get(this.end);\n      this.set(this.end, undefined);\n      return result;\n    }\n    /**\n     * Adds an item to the beginning of the buffer.\n     */\n  }, {\n    key: \"unshift\",\n    value: function unshift(value) {\n      if (this.isFull()) {\n        throw new RangeError('Ring buffer is full.');\n      }\n      this.begin = this.wrap(this.begin - 1);\n      this.set(this.begin, value);\n    }\n    /**\n     * Removes and returns the first item in the buffer.\n     */\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.isEmpty()) {\n        throw new RangeError('Ring buffer is empty.');\n      }\n      var result = this.get(this.begin);\n      this.set(this.begin, undefined);\n      this.begin = this.wrap(this.begin + 1);\n      return result;\n    }\n    /**\n     * Removes and returns a specific item in the buffer, and moves the last item\n     * to the vacated slot.  This is useful for implementing a shuffling stream.\n     * Note that this operation necessarily scrambles the original order.\n     *\n     * @param relativeIndex: the index of the item to remove, relative to the\n     *   first item in the buffer (e.g., hiding the ring nature of the underlying\n     *   storage).\n     */\n  }, {\n    key: \"shuffleExcise\",\n    value: function shuffleExcise(relativeIndex) {\n      if (this.isEmpty()) {\n        throw new RangeError('Ring buffer is empty.');\n      }\n      var index = this.wrap(this.begin + relativeIndex);\n      var result = this.get(index);\n      this.set(index, this.pop());\n      return result;\n    }\n  }]);\n  return RingBuffer;\n}();","map":{"version":3,"names":["RingBuffer","capacity","_classCallCheck","begin","end","RangeError","data","Array","doubledCapacity","_createClass","key","value","wrap","index","get","set","length","isFull","isEmpty","push","pushAll","values","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","pop","result","undefined","unshift","shift","shuffleExcise","relativeIndex"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-data\\src\\util\\ring_buffer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer<T> {\n  // Note we store the indices in the range 0 <= index < 2*capacity.\n  // This allows us to distinguish the full from the empty case.\n  // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n  protected begin = 0;  // inclusive\n  protected end = 0;    // exclusive\n  protected doubledCapacity: number;\n\n  protected data: T[];\n\n  /**\n   * Constructs a `RingBuffer`.\n   * @param capacity The number of items that the buffer can accomodate.\n   */\n  constructor(public capacity: number) {\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n    this.data = new Array<T>(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n\n  /**\n   * Map any index into the range 0 <= index < 2*capacity.\n   */\n  protected wrap(index: number) {\n    // don't trust % on negative numbers\n    while (index < 0) {\n      index += this.doubledCapacity;\n    }\n    return index % this.doubledCapacity;\n  }\n\n  protected get(index: number) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t get item at a negative index.');\n    }\n    return this.data[index % this.capacity];\n  }\n\n  protected set(index: number, value: T) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t set item at a negative index.');\n    }\n    this.data[index % this.capacity] = value;\n  }\n\n  /**\n   * Returns the current number of items in the buffer.\n   */\n  length(): number {\n    let length = this.end - this.begin;\n    if (length < 0) {\n      length = this.doubledCapacity + length;\n    }\n    return length;\n  }\n\n  /**\n   * Reports whether the buffer is full.\n   * @returns true if the number of items in the buffer equals its capacity, and\n   *   false otherwise.\n   */\n  isFull() {\n    return this.length() === this.capacity;\n  }\n\n  /**\n   * Reports whether the buffer is empty.\n   * @returns true if the number of items in the buffer equals zero, and\n   *   false otherwise.\n   */\n  isEmpty() {\n    return this.length() === 0;\n  }\n\n  /**\n   * Adds an item to the end of the buffer.\n   */\n  push(value: T) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.set(this.end, value);\n    this.end = this.wrap(this.end + 1);\n  }\n\n  /**\n   * Adds many items to the end of the buffer, in order.\n   */\n  pushAll(values: T[]) {\n    for (const value of values) {\n      this.push(value);\n    }\n  }\n\n  /**\n   * Removes and returns the last item in the buffer.\n   */\n  pop(): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    this.end = this.wrap(this.end - 1);\n    const result = this.get(this.end);\n    this.set(this.end, undefined);\n    return result;\n  }\n\n  /**\n   * Adds an item to the beginning of the buffer.\n   */\n  unshift(value: T) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.begin = this.wrap(this.begin - 1);\n    this.set(this.begin, value);\n  }\n\n  /**\n   * Removes and returns the first item in the buffer.\n   */\n  shift(): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const result = this.get(this.begin);\n    this.set(this.begin, undefined);\n    this.begin = this.wrap(this.begin + 1);\n    return result;\n  }\n\n  /**\n   * Removes and returns a specific item in the buffer, and moves the last item\n   * to the vacated slot.  This is useful for implementing a shuffling stream.\n   * Note that this operation necessarily scrambles the original order.\n   *\n   * @param relativeIndex: the index of the item to remove, relative to the\n   *   first item in the buffer (e.g., hiding the ring nature of the underlying\n   *   storage).\n   */\n  shuffleExcise(relativeIndex: number): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const index = this.wrap(this.begin + relativeIndex);\n    const result = this.get(index);\n    this.set(index, this.pop());\n    return result;\n  }\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;AAkBA;;;AAGA,WAAaA,UAAU;EAUrB;;;;EAIA,SAAAA,WAAmBC,QAAgB;IAAAC,eAAA,OAAAF,UAAA;IAAhB,KAAAC,QAAQ,GAARA,QAAQ;IAb3B;IACA;IACA;IACU,KAAAE,KAAK,GAAG,CAAC,CAAC,CAAE;IACZ,KAAAC,GAAG,GAAG,CAAC,CAAC,CAAI;IAUpB,IAAIH,QAAQ,IAAI,IAAI,EAAE;MACpB,MAAM,IAAII,UAAU,CAAC,kDAAkD,CAAC;;IAE1E,IAAIJ,QAAQ,GAAG,CAAC,EAAE;MAChB,MAAM,IAAII,UAAU,CAAC,4CAA4C,CAAC;;IAEpE,IAAI,CAACC,IAAI,GAAG,IAAIC,KAAK,CAAIN,QAAQ,CAAC;IAClC,IAAI,CAACO,eAAe,GAAG,CAAC,GAAGP,QAAQ;EACrC;EAEA;;;EAAAQ,YAAA,CAAAT,UAAA;IAAAU,GAAA;IAAAC,KAAA,EAGU,SAAAC,KAAKC,KAAa;MAC1B;MACA,OAAOA,KAAK,GAAG,CAAC,EAAE;QAChBA,KAAK,IAAI,IAAI,CAACL,eAAe;;MAE/B,OAAOK,KAAK,GAAG,IAAI,CAACL,eAAe;IACrC;EAAC;IAAAE,GAAA;IAAAC,KAAA,EAES,SAAAG,IAAID,KAAa;MACzB,IAAIA,KAAK,GAAG,CAAC,EAAE;QACb,MAAM,IAAIR,UAAU,CAAC,sCAAsC,CAAC;;MAE9D,OAAO,IAAI,CAACC,IAAI,CAACO,KAAK,GAAG,IAAI,CAACZ,QAAQ,CAAC;IACzC;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAES,SAAAI,IAAIF,KAAa,EAAEF,KAAQ;MACnC,IAAIE,KAAK,GAAG,CAAC,EAAE;QACb,MAAM,IAAIR,UAAU,CAAC,sCAAsC,CAAC;;MAE9D,IAAI,CAACC,IAAI,CAACO,KAAK,GAAG,IAAI,CAACZ,QAAQ,CAAC,GAAGU,KAAK;IAC1C;IAEA;;;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAGA,SAAAK,OAAA,EAAM;MACJ,IAAIA,MAAM,GAAG,IAAI,CAACZ,GAAG,GAAG,IAAI,CAACD,KAAK;MAClC,IAAIa,MAAM,GAAG,CAAC,EAAE;QACdA,MAAM,GAAG,IAAI,CAACR,eAAe,GAAGQ,MAAM;;MAExC,OAAOA,MAAM;IACf;IAEA;;;;;EAAA;IAAAN,GAAA;IAAAC,KAAA,EAKA,SAAAM,OAAA,EAAM;MACJ,OAAO,IAAI,CAACD,MAAM,EAAE,KAAK,IAAI,CAACf,QAAQ;IACxC;IAEA;;;;;EAAA;IAAAS,GAAA;IAAAC,KAAA,EAKA,SAAAO,QAAA,EAAO;MACL,OAAO,IAAI,CAACF,MAAM,EAAE,KAAK,CAAC;IAC5B;IAEA;;;EAAA;IAAAN,GAAA;IAAAC,KAAA,EAGA,SAAAQ,KAAKR,KAAQ;MACX,IAAI,IAAI,CAACM,MAAM,EAAE,EAAE;QACjB,MAAM,IAAIZ,UAAU,CAAC,sBAAsB,CAAC;;MAE9C,IAAI,CAACU,GAAG,CAAC,IAAI,CAACX,GAAG,EAAEO,KAAK,CAAC;MACzB,IAAI,CAACP,GAAG,GAAG,IAAI,CAACQ,IAAI,CAAC,IAAI,CAACR,GAAG,GAAG,CAAC,CAAC;IACpC;IAEA;;;EAAA;IAAAM,GAAA;IAAAC,KAAA,EAGA,SAAAS,QAAQC,MAAW;MAAA,IAAAC,SAAA,GAAAC,0BAAA,CACGF,MAAM;QAAAG,KAAA;MAAA;QAA1B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA4B;UAAA,IAAjBhB,KAAK,GAAAa,KAAA,CAAAb,KAAA;UACd,IAAI,CAACQ,IAAI,CAACR,KAAK,CAAC;;MACjB,SAAAiB,GAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA;MAAA;QAAAN,SAAA,CAAAQ,CAAA;MAAA;IACH;IAEA;;;EAAA;IAAApB,GAAA;IAAAC,KAAA,EAGA,SAAAoB,IAAA,EAAG;MACD,IAAI,IAAI,CAACb,OAAO,EAAE,EAAE;QAClB,MAAM,IAAIb,UAAU,CAAC,uBAAuB,CAAC;;MAE/C,IAAI,CAACD,GAAG,GAAG,IAAI,CAACQ,IAAI,CAAC,IAAI,CAACR,GAAG,GAAG,CAAC,CAAC;MAClC,IAAM4B,MAAM,GAAG,IAAI,CAAClB,GAAG,CAAC,IAAI,CAACV,GAAG,CAAC;MACjC,IAAI,CAACW,GAAG,CAAC,IAAI,CAACX,GAAG,EAAE6B,SAAS,CAAC;MAC7B,OAAOD,MAAM;IACf;IAEA;;;EAAA;IAAAtB,GAAA;IAAAC,KAAA,EAGA,SAAAuB,QAAQvB,KAAQ;MACd,IAAI,IAAI,CAACM,MAAM,EAAE,EAAE;QACjB,MAAM,IAAIZ,UAAU,CAAC,sBAAsB,CAAC;;MAE9C,IAAI,CAACF,KAAK,GAAG,IAAI,CAACS,IAAI,CAAC,IAAI,CAACT,KAAK,GAAG,CAAC,CAAC;MACtC,IAAI,CAACY,GAAG,CAAC,IAAI,CAACZ,KAAK,EAAEQ,KAAK,CAAC;IAC7B;IAEA;;;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAGA,SAAAwB,MAAA,EAAK;MACH,IAAI,IAAI,CAACjB,OAAO,EAAE,EAAE;QAClB,MAAM,IAAIb,UAAU,CAAC,uBAAuB,CAAC;;MAE/C,IAAM2B,MAAM,GAAG,IAAI,CAAClB,GAAG,CAAC,IAAI,CAACX,KAAK,CAAC;MACnC,IAAI,CAACY,GAAG,CAAC,IAAI,CAACZ,KAAK,EAAE8B,SAAS,CAAC;MAC/B,IAAI,CAAC9B,KAAK,GAAG,IAAI,CAACS,IAAI,CAAC,IAAI,CAACT,KAAK,GAAG,CAAC,CAAC;MACtC,OAAO6B,MAAM;IACf;IAEA;;;;;;;;;EAAA;IAAAtB,GAAA;IAAAC,KAAA,EASA,SAAAyB,cAAcC,aAAqB;MACjC,IAAI,IAAI,CAACnB,OAAO,EAAE,EAAE;QAClB,MAAM,IAAIb,UAAU,CAAC,uBAAuB,CAAC;;MAE/C,IAAMQ,KAAK,GAAG,IAAI,CAACD,IAAI,CAAC,IAAI,CAACT,KAAK,GAAGkC,aAAa,CAAC;MACnD,IAAML,MAAM,GAAG,IAAI,CAAClB,GAAG,CAACD,KAAK,CAAC;MAC9B,IAAI,CAACE,GAAG,CAACF,KAAK,EAAE,IAAI,CAACkB,GAAG,EAAE,CAAC;MAC3B,OAAOC,MAAM;IACf;EAAC;EAAA,OAAAhC,UAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}