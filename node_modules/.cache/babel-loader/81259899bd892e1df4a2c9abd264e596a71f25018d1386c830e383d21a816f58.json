{"ast":null,"code":"import _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { getCoordsDataType } from './shader_compiler';\nexport var CumOpType;\n(function (CumOpType) {\n  CumOpType[\"Prod\"] = \"*\";\n  CumOpType[\"Sum\"] = \"+\";\n})(CumOpType || (CumOpType = {}));\nexport var CumProgram = /*#__PURE__*/_createClass(function CumProgram(op, outputShape, exclusive, reverse) {\n  _classCallCheck(this, CumProgram);\n  this.op = op;\n  this.outputShape = outputShape;\n  this.variableNames = ['x'];\n  this.customUniforms = [{\n    name: 'index',\n    type: 'float'\n  }];\n  var rank = this.outputShape.length;\n  var initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n  var val = exclusive ? initVal : \"getX(\".concat(getCoords(rank, 'coords', this.op), \")\");\n  var length = this.outputShape[this.outputShape.length - 1];\n  var condition = '';\n  var idxString = '';\n  // When exclusive is set, the cum op becomes roll op that copies the\n  // value from the previous index based on the direction specified by the\n  // reverse flag.\n  if (exclusive) {\n    condition = reverse ? \"end != \".concat(length - 1) : 'end != 0';\n    idxString = reverse ? 'end + 1' : 'end - 1';\n  } else {\n    condition = reverse ? \"end + pow2 < \".concat(length) : 'end >= pow2';\n    idxString = reverse ? 'end + pow2' : 'end - pow2';\n  }\n  this.userCode = \"\\n      void main() {\\n        \".concat(getCoordsDataType(rank), \" coords = getOutputCoords();\\n        int end = \").concat(getFinalCoord(rank, 'coords', this.op), \";\\n        float val = \").concat(val, \";\\n        int pow2 = int(pow(2.0, index));\\n        if (\").concat(condition, \") {\\n          int idx = \").concat(idxString, \";\\n          \").concat(getFinalCoord(rank, 'coords', this.op), \" = idx;\\n          val \").concat(this.op, \"= getX(\").concat(getCoords(rank, 'coords', this.op), \");\\n        }\\n        setOutput(val);\\n      }\\n    \");\n});\nfunction getCoords(rank, name, op) {\n  if (rank === 1) {\n    return \"\".concat(name);\n  } else if (rank === 2) {\n    return \"\".concat(name, \".x, \").concat(name, \".y\");\n  } else if (rank === 3) {\n    return \"\".concat(name, \".x, \").concat(name, \".y, \").concat(name, \".z\");\n  } else if (rank === 4) {\n    return \"\".concat(name, \".x, \").concat(name, \".y, \").concat(name, \".z, \").concat(name, \".w\");\n  } else {\n    throw new Error(\"Cumulative \".concat(op, \" for rank \").concat(rank, \" is not yet supported\"));\n  }\n}\nfunction getFinalCoord(rank, name, op) {\n  if (rank === 1) {\n    return \"\".concat(name);\n  } else if (rank === 2) {\n    return \"\".concat(name, \".y\");\n  } else if (rank === 3) {\n    return \"\".concat(name, \".z\");\n  } else if (rank === 4) {\n    return \"\".concat(name, \".w\");\n  } else {\n    throw new Error(\"Cumulative \".concat(op, \" for rank \").concat(rank, \" is not yet supported\"));\n  }\n}","map":{"version":3,"names":["getCoordsDataType","CumOpType","CumProgram","_createClass","op","outputShape","exclusive","reverse","_classCallCheck","variableNames","customUniforms","name","type","rank","length","initVal","Prod","val","concat","getCoords","condition","idxString","userCode","getFinalCoord","Error"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\cum_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport enum CumOpType {\n  Prod = '*',\n  Sum = '+',\n}\n\nexport class CumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  userCode: string;\n  customUniforms = [{name: 'index', type: 'float' as UniformType}];\n\n  constructor(\n      public op: CumOpType, public outputShape: number[], exclusive: boolean,\n      reverse: boolean) {\n    const rank = this.outputShape.length;\n    const initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n    const val =\n        exclusive ? initVal : `getX(${getCoords(rank, 'coords', this.op)})`;\n    const length = this.outputShape[this.outputShape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = (reverse ? 'end + pow2' : 'end - pow2');\n    }\n\n    this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords', this.op)};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords', this.op)} = idx;\n          val ${this.op}= getX(${getCoords(rank, 'coords', this.op)});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n}\n\nfunction getCoords(rank: number, name: string, op: CumOpType): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string, op: CumOpType): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}