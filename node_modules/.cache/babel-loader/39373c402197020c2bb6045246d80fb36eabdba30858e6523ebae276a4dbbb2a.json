{"ast":null,"code":"import _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport var ReversePackedProgram = /*#__PURE__*/_createClass(function ReversePackedProgram(xShape, axis) {\n  _classCallCheck(this, ReversePackedProgram);\n  this.variableNames = ['x'];\n  this.packedInputs = true;\n  this.packedOutput = true;\n  var rank = xShape.length;\n  if (rank > 4) {\n    throw new Error(\"WebGL backend: Reverse of rank-\".concat(rank, \" tensor is not yet supported\"));\n  }\n  this.outputShape = xShape;\n  var channels = getChannels('rc', rank);\n  var nextColumn = \"\".concat(channels[rank - 1], \" + 1 < \").concat(this.outputShape[rank - 1]);\n  var nextRow = \"\".concat(channels[rank - 2], \" + 1 < \").concat(this.outputShape[rank - 2]);\n  var type = getCoordsDataType(rank);\n  if (rank === 1) {\n    this.userCode = \"\\n        void main(){\\n          int rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = getChannel(getX(\".concat(xShape[0], \" - rc - 1),\\n            \").concat(xShape[0], \" - rc - 1);\\n          if(\").concat(nextColumn, \"){\\n              result.g = getChannel(getX(\").concat(xShape[0], \" - (rc  + 1) - 1),\\n                \").concat(xShape[0], \" - (rc  + 1) - 1);\\n          }\\n          setOutput(result);\\n        }\\n      \");\n  } else {\n    this.userCode = \"\\n        void main() {\\n          \".concat(type, \" rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = \").concat(getR(channels.slice()), \";\\n          if(\").concat(nextColumn, \"){\\n            result.g = \").concat(getG(channels.slice()), \";\\n          }\\n          if(\").concat(nextRow, \") {\\n            result.b = \").concat(getB(channels.slice()), \";\\n            if(\").concat(nextColumn, \") {\\n              result.a = \").concat(getA(channels.slice()), \";\\n            }\\n          }\\n          setOutput(result);\\n        }\\n    \");\n  }\n  function getR(channels) {\n    return getChannel(channels);\n  }\n  function getG(channels) {\n    channels[rank - 1] = '(' + channels[rank - 1] + \" + 1)\";\n    return getChannel(channels);\n  }\n  function getB(channels) {\n    channels[rank - 2] = '(' + channels[rank - 2] + \" + 1)\";\n    return getChannel(channels);\n  }\n  function getA(channels) {\n    channels[rank - 1] = '(' + channels[rank - 1] + \" + 1)\";\n    channels[rank - 2] = '(' + channels[rank - 2] + \" + 1)\";\n    return getChannel(channels);\n  }\n  function getChannel(channels) {\n    var inCoordsArray = xShape.map(function (_, i) {\n      return getInCoord(i, channels);\n    });\n    var inCoords = inCoordsArray.join(',');\n    var innerDims = inCoordsArray.slice(-2).join(',');\n    return \"getChannel(getX(\".concat(inCoords, \"), vec2(\").concat(innerDims, \"))\");\n  }\n  function getInCoord(i, channels1) {\n    if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n      return \"\".concat(xShape[i], \" - \").concat(channels1[i], \" - 1\");\n    } else {\n      return \"\".concat(channels1[i]);\n    }\n  }\n});","map":{"version":3,"names":["getChannels","getCoordsDataType","ReversePackedProgram","_createClass","xShape","axis","_classCallCheck","variableNames","packedInputs","packedOutput","rank","length","Error","concat","outputShape","channels","nextColumn","nextRow","type","userCode","getR","slice","getG","getB","getA","getChannel","inCoordsArray","map","_","i","getInCoord","inCoords","join","innerDims","channels1","indexOf"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\reverse_packed_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}