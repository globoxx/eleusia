{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { HashTable } from '../../executor/hash_table';\nimport { getParamValue } from './utils';\nexport var executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(node, tensorMap, context, resourceManager) {\n    var existingTableHandle, keyDType, valueDType, hashTable, handle, keys, values, _hashTable, _handle, _keys, defaultValue, _hashTable2, _handle2, _hashTable3;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = node.op;\n          _context.next = _context.t0 === 'HashTable' ? 3 : _context.t0 === 'HashTableV2' ? 3 : _context.t0 === 'InitializeTable' ? 13 : _context.t0 === 'InitializeTableV2' ? 13 : _context.t0 === 'LookupTableImport' ? 13 : _context.t0 === 'LookupTableImportV2' ? 13 : _context.t0 === 'LookupTableFind' ? 21 : _context.t0 === 'LookupTableFindV2' ? 21 : _context.t0 === 'LookupTableSize' ? 29 : _context.t0 === 'LookupTableSizeV2' ? 29 : 32;\n          break;\n        case 3:\n          existingTableHandle = resourceManager.getHashTableHandleByName(node.name); // Table is shared with initializer.\n          if (!(existingTableHandle != null)) {\n            _context.next = 8;\n            break;\n          }\n          return _context.abrupt(\"return\", [existingTableHandle]);\n        case 8:\n          keyDType = getParamValue('keyDType', node, tensorMap, context);\n          valueDType = getParamValue('valueDType', node, tensorMap, context);\n          hashTable = new HashTable(keyDType, valueDType);\n          resourceManager.addHashTable(node.name, hashTable);\n          return _context.abrupt(\"return\", [hashTable.handle]);\n        case 13:\n          handle = getParamValue('tableHandle', node, tensorMap, context, resourceManager);\n          keys = getParamValue('keys', node, tensorMap, context);\n          values = getParamValue('values', node, tensorMap, context);\n          _hashTable = resourceManager.getHashTableById(handle.id);\n          _context.next = 19;\n          return _hashTable.import(keys, values);\n        case 19:\n          _context.t1 = _context.sent;\n          return _context.abrupt(\"return\", [_context.t1]);\n        case 21:\n          _handle = getParamValue('tableHandle', node, tensorMap, context, resourceManager);\n          _keys = getParamValue('keys', node, tensorMap, context);\n          defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n          _hashTable2 = resourceManager.getHashTableById(_handle.id);\n          _context.next = 27;\n          return _hashTable2.find(_keys, defaultValue);\n        case 27:\n          _context.t2 = _context.sent;\n          return _context.abrupt(\"return\", [_context.t2]);\n        case 29:\n          _handle2 = getParamValue('tableHandle', node, tensorMap, context, resourceManager);\n          _hashTable3 = resourceManager.getHashTableById(_handle2.id);\n          return _context.abrupt(\"return\", [_hashTable3.tensorSize()]);\n        case 32:\n          throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n        case 33:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function executeOp(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var CATEGORY = 'hash_table';","map":{"version":3,"names":["HashTable","getParamValue","executeOp","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","node","tensorMap","context","resourceManager","existingTableHandle","keyDType","valueDType","hashTable","handle","keys","values","_hashTable","_handle","_keys","defaultValue","_hashTable2","_handle2","_hashTable3","wrap","_callee$","_context","prev","next","t0","op","getHashTableHandleByName","name","abrupt","addHashTable","getHashTableById","id","import","t1","sent","find","t2","tensorSize","TypeError","concat","stop","_x","_x2","_x3","_x4","apply","arguments","CATEGORY"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\operations\\executors\\hash_table_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {HashTable} from '../../executor/hash_table';\nimport {ResourceManager} from '../../executor/resource_manager';\nimport {InternalOpAsyncExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpAsyncExecutor = async(\n    node: Node, tensorMap: NamedTensorsMap, context: ExecutionContext,\n    resourceManager: ResourceManager): Promise<Tensor[]> => {\n  switch (node.op) {\n    case 'HashTable':\n    case 'HashTableV2': {\n      const existingTableHandle =\n          resourceManager.getHashTableHandleByName(node.name);\n      // Table is shared with initializer.\n      if (existingTableHandle != null) {\n        return [existingTableHandle];\n      } else {\n        const keyDType =\n            getParamValue('keyDType', node, tensorMap, context) as DataType;\n        const valueDType =\n            getParamValue('valueDType', node, tensorMap, context) as DataType;\n\n        const hashTable = new HashTable(keyDType, valueDType);\n        resourceManager.addHashTable(node.name, hashTable);\n        return [hashTable.handle];\n      }\n    }\n    case 'InitializeTable':\n    case 'InitializeTableV2':\n    case 'LookupTableImport':\n    case 'LookupTableImportV2': {\n      const handle = getParamValue(\n                         'tableHandle', node, tensorMap, context,\n                         resourceManager) as Tensor;\n      const keys = getParamValue('keys', node, tensorMap, context) as Tensor;\n      const values =\n          getParamValue('values', node, tensorMap, context) as Tensor;\n\n      const hashTable = resourceManager.getHashTableById(handle.id);\n\n      return [await hashTable.import(keys, values)];\n    }\n    case 'LookupTableFind':\n    case 'LookupTableFindV2': {\n      const handle = getParamValue(\n                         'tableHandle', node, tensorMap, context,\n                         resourceManager) as Tensor;\n      const keys = getParamValue('keys', node, tensorMap, context) as Tensor;\n      const defaultValue =\n          getParamValue('defaultValue', node, tensorMap, context) as Tensor;\n\n      const hashTable = resourceManager.getHashTableById(handle.id);\n      return [await hashTable.find(keys, defaultValue)];\n    }\n    case 'LookupTableSize':\n    case 'LookupTableSizeV2': {\n      const handle = getParamValue(\n                         'tableHandle', node, tensorMap, context,\n                         resourceManager) as Tensor;\n\n      const hashTable = resourceManager.getHashTableById(handle.id);\n      return [hashTable.tensorSize()];\n    }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\n\nexport const CATEGORY = 'hash_table';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}