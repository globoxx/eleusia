{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  var ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        var n = getParamValue('n', node, tensorMap, context);\n        var axis = getParamValue('axis', node, tensorMap, context);\n        var inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n    case 'Gather':\n      {\n        var input = getParamValue('x', node, tensorMap, context);\n        var indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n    case 'GatherV2':\n      {\n        var _axis = getParamValue('axis', node, tensorMap, context);\n        var batchDims = getParamValue('batchDims', node, tensorMap, context);\n        var _input = getParamValue('x', node, tensorMap, context);\n        var _indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(_input, ops.cast(_indices, 'int32'), _axis, batchDims)];\n      }\n    case 'Reverse':\n      {\n        var dims = getParamValue('dims', node, tensorMap, context);\n        var _axis2 = [];\n        for (var i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            _axis2.push(i);\n          }\n        }\n        var _input2 = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(_input2, _axis2)];\n      }\n    case 'ReverseV2':\n      {\n        var _axis3 = getParamValue('axis', node, tensorMap, context);\n        var _input3 = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(_input3, _axis3)];\n      }\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        var begin = getParamValue('begin', node, tensorMap, context);\n        // tslint:disable-next-line:no-any\n        var size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n    case 'StridedSlice':\n      {\n        var _begin = getParamValue('begin', node, tensorMap, context);\n        var end = getParamValue('end', node, tensorMap, context);\n        var strides = getParamValue('strides', node, tensorMap, context);\n        var beginMask = getParamValue('beginMask', node, tensorMap, context);\n        var endMask = getParamValue('endMask', node, tensorMap, context);\n        var ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        var newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        var shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        var tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, _begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n    case 'Pack':\n      {\n        return tidy(function () {\n          var axis = getParamValue('axis', node, tensorMap, context);\n          var tensors = getParamValue('tensors', node, tensorMap, context);\n          // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n          var shape = tensors[0].shape;\n          var squeezedShape = ops.squeeze(tensors[0]).shape;\n          var mapped = tensors.map(function (tensor) {\n            var sameShape = util.arraysEqual(tensor.shape, shape);\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n    case 'Unpack':\n      {\n        var _axis4 = getParamValue('axis', node, tensorMap, context);\n        var _tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(_tensor, _axis4);\n      }\n    case 'Tile':\n      {\n        var reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n    case 'Split':\n    case 'SplitV':\n      {\n        var _axis5 = getParamValue('axis', node, tensorMap, context);\n        var numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        var _tensor2 = getParamValue('x', node, tensorMap, context);\n        return ops.split(_tensor2, numOrSizeSplits, _axis5);\n      }\n    case 'ScatterNd':\n      {\n        var _indices2 = getParamValue('indices', node, tensorMap, context);\n        var values = getParamValue('values', node, tensorMap, context);\n        var shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(_indices2, values, shape)];\n      }\n    case 'GatherNd':\n      {\n        var x = getParamValue('x', node, tensorMap, context);\n        var _indices3 = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, _indices3)];\n      }\n    case 'SparseToDense':\n      {\n        var _indices4 = getParamValue('sparseIndices', node, tensorMap, context);\n        var _shape = getParamValue('outputShape', node, tensorMap, context);\n        var sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        var defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(_indices4, sparseValues, _shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n    case 'TensorScatterUpdate':\n      {\n        var _indices5 = getParamValue('indices', node, tensorMap, context);\n        var _values = getParamValue('values', node, tensorMap, context);\n        var _tensor3 = getParamValue('tensor', node, tensorMap, context);\n        return [ops.tensorScatterUpdate(_tensor3, _indices5, _values)];\n      }\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'slice_join';","map":{"version":3,"names":["tidy","util","tfOps","getParamValue","executeOp","node","tensorMap","context","ops","arguments","length","undefined","op","n","axis","inputs","slice","concat","input","indices","gather","cast","batchDims","dims","i","push","reverse","begin","size","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","tensor","stridedSlice","tensors","shape","squeezedShape","squeeze","mapped","map","sameShape","arraysEqual","Error","reshape","stack","unstack","reps","tile","numOrSizeSplits","split","values","scatterND","x","gatherND","sparseValues","defaultValue","sparseToDense","dtype","tensorScatterUpdate","TypeError","CATEGORY"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\operations\\executors\\slice_join_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor1D, tidy, util} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap, context: ExecutionContext,\n     ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n          const n = getParamValue('n', node, tensorMap, context) as number;\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          let inputs =\n              getParamValue('tensors', node, tensorMap, context) as Tensor[];\n          inputs = inputs.slice(0, n);\n          return [ops.concat(inputs, axis)];\n        }\n        case 'Gather': {\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const batchDims =\n              getParamValue('batchDims', node, tensorMap, context) as number;\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(\n              input, ops.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n          const dims =\n              getParamValue('dims', node, tensorMap, context) as boolean[];\n          const axis = [];\n          for (let i = 0; i < dims.length; i++) {\n            if (dims[i]) {\n              axis.push(i);\n            }\n          }\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number[];\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'Slice': {\n          // tslint:disable-next-line:no-any\n          const begin = getParamValue('begin', node, tensorMap, context) as any;\n          // tslint:disable-next-line:no-any\n          const size = getParamValue('size', node, tensorMap, context) as any;\n          return [ops.slice(\n              getParamValue('x', node, tensorMap, context) as Tensor, begin,\n              size)];\n        }\n        case 'StridedSlice': {\n          const begin =\n              getParamValue('begin', node, tensorMap, context) as number[];\n          const end =\n              getParamValue('end', node, tensorMap, context) as number[];\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const beginMask =\n              getParamValue('beginMask', node, tensorMap, context) as number;\n          const endMask =\n              getParamValue('endMask', node, tensorMap, context) as number;\n          const ellipsisMask =\n              getParamValue('ellipsisMask', node, tensorMap, context) as number;\n          const newAxisMask =\n              getParamValue('newAxisMask', node, tensorMap, context) as number;\n          const shrinkAxisMask =\n              getParamValue('shrinkAxisMask', node, tensorMap, context) as\n              number;\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return [ops.stridedSlice(\n              tensor, begin, end, strides, beginMask, endMask, ellipsisMask,\n              newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n          return tidy(() => {\n            const axis =\n                getParamValue('axis', node, tensorMap, context) as number;\n            const tensors =\n                getParamValue('tensors', node, tensorMap, context) as Tensor[];\n            // Reshape the tensors to the first tensor's shape if they don't\n            // match.\n            const shape = tensors[0].shape;\n            const squeezedShape = ops.squeeze(tensors[0]).shape;\n            const mapped = tensors.map(tensor => {\n              const sameShape = util.arraysEqual(tensor.shape, shape);\n              if (!sameShape &&\n                  !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n                throw new Error('the input tensors shape does not match');\n              }\n              return sameShape ? tensor : ops.reshape(tensor, shape);\n            });\n            return [ops.stack(mapped, axis)];\n          });\n        }\n        case 'Unpack': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return ops.unstack(tensor, axis);\n        }\n        case 'Tile': {\n          const reps =\n              getParamValue('reps', node, tensorMap, context) as number[];\n          return [ops.tile(\n              getParamValue('x', node, tensorMap, context) as Tensor, reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const numOrSizeSplits =\n              getParamValue('numOrSizeSplits', node, tensorMap, context) as\n                  number |\n              number[];\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return ops.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const shape =\n              getParamValue('shape', node, tensorMap, context) as number[];\n          return [ops.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n          const x = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          return [ops.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n          const indices =\n              getParamValue('sparseIndices', node, tensorMap, context) as\n              Tensor;\n          const shape =\n              getParamValue('outputShape', node, tensorMap, context) as\n              number[];\n          const sparseValues =\n              getParamValue('sparseValues', node, tensorMap, context) as Tensor;\n          const defaultValue =\n              getParamValue('defaultValue', node, tensorMap, context) as Scalar;\n          return [ops.sparseToDense(\n              indices, sparseValues, shape,\n              sparseValues.dtype === defaultValue.dtype ?\n                  defaultValue :\n                  ops.cast(defaultValue, sparseValues.dtype))];\n        }\n        case 'TensorScatterUpdate': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return [ops.tensorScatterUpdate(tensor, indices, values)];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'slice_join';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}