{"ast":null,"code":"import _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nvar NEW_AXIS = -2;\nvar SHRINK_AXIS = -1;\nexport function assertParamsValid(input, begin, size) {\n  var inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, function () {\n    return \"Error in slice\".concat(inputRank, \"D: Length of begin \").concat(begin, \" must \") + \"match the rank of the array (\".concat(inputRank, \").\");\n  });\n  util.assert(inputRank === size.length, function () {\n    return \"Error in slice\".concat(inputRank, \"D: Length of size \").concat(size, \" must \") + \"match the rank of the array (\".concat(inputRank, \").\");\n  });\n  var _loop = function _loop(i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], function () {\n      return \"Error in slice\".concat(inputRank, \"D: begin[\").concat(i, \"] + size[\").concat(i, \"] \") + \"(\".concat(begin[i] + size[i], \") would overflow input.shape[\").concat(i, \"] (\").concat(input.shape[i], \")\");\n    });\n  };\n  for (var i = 0; i < inputRank; ++i) {\n    _loop(i);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n  var axes = [];\n  var axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n  var size = [];\n  for (var axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  var newStrides = _toConsumableArray(strides);\n  for (var i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (var _i = 0; _i < numElidedAxes; _i++) {\n    if (_i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n  return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  var elidedAxes = [];\n  for (var i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  var inputRank = inputShape.length;\n  var normalizedBegin = new Array(inputRank),\n    normalizedEnd = new Array(inputRank),\n    normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    var fullIndex = ellipsisAxes[0];\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    var numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (var axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  var newIndices = _toConsumableArray(inputShape);\n  var elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n  for (var axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      var originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      var originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  var newIndices = _toConsumableArray(inputShape);\n  var elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n  for (var axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      var originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      var originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n  for (var i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    var axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  var stride = strides[axis];\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  var start = startIndices[axis];\n  var stride = strides[axis] || 1;\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n  // Handle negative indices\n  var axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  var stop = stopIndices[axis];\n  var stride = strides[axis] || 1;\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n  // Handle negative indices\n  var axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  var firstNonOneAxis = size.length;\n  for (var i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n  for (var _i2 = firstNonOneAxis + 1; _i2 < size.length; _i2++) {\n    if (begin[_i2] > 0 || size[_i2] !== shape[_i2]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  var flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (var i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  var begin_;\n  var xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin].concat(_toConsumableArray(new Array(xRank - 1).fill(0)));\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(function (d) {\n    util.assert(d !== -1, function () {\n      return 'slice() does not support negative begin indexing.';\n    });\n  });\n  var size_;\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size].concat(_toConsumableArray(new Array(xRank - 1).fill(-1)));\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map(function (d, i) {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, function () {\n        return \"Negative size values should be exactly -1 but got \" + \"\".concat(d, \" for the slice() size at index \").concat(i, \".\");\n      });\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\n// Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  var stridesNonNull;\n  if (strides == null) {\n    stridesNonNull = new Array(begin.length);\n    stridesNonNull.fill(1);\n  } else {\n    stridesNonNull = strides;\n  }\n  // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n  // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n  // of 2. When i is a power of 2, i & (i - 1) is always 0.\n  // Also ref:\n  // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n  if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n  // Step 1: Account for ellipsis and new axis.\n  // Check for ellipsis and count how many non-newaxis there are after.\n  var ellipsisSeen = false;\n  var sparseSpec = {\n    dims: stridesNonNull.length,\n    numAddAxisAfterEllipsis: 0,\n    begin: begin.slice(),\n    end: end.slice(),\n    strides: stridesNonNull.slice(),\n    beginMask: beginMask,\n    endMask: endMask,\n    ellipsisMask: ellipsisMask,\n    newAxisMask: newAxisMask,\n    shrinkAxisMask: shrinkAxisMask\n  };\n  for (var i = 0; i < sparseSpec.dims; i++) {\n    if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {\n      sparseSpec.numAddAxisAfterEllipsis++;\n    }\n    if (1 << i & ellipsisMask) {\n      ellipsisSeen = true;\n    }\n  }\n  // If no ellipsis insert one at the end.\n  if (!ellipsisSeen) {\n    sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;\n    sparseSpec.dims++; // this effects loop iteration below\n  }\n  // Step 2: Make a sparse spec into a full index spec.\n  //\n  // The sparse spec deos not correspond to the number of dimensions.\n  // Make a dense spec that cooresponds to the number of dimensions.\n  //\n  // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n  // produce the missing beginMask for the first two dimensions i.e. from\n  // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n  // endMask = 7 (111).\n  var denseSpec = {\n    dims: xShape.length,\n    beginMask: 0,\n    endMask: 0,\n    beginValid: false,\n    endValid: false\n  };\n  buildDenseSpec(sparseSpec, denseSpec);\n  // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n  // and bounds check.\n  var isIdentity = true;\n  var sliceDim0 = true;\n  var isSimpleSlice = true;\n  var processingShape = [];\n  var finalShape = [];\n  for (var _i3 = 0; _i3 < xShape.length; ++_i3) {\n    if (denseSpec.strides[_i3] === 0) {\n      throw Error(\"strides[\".concat(_i3, \"] must be non-zero\"));\n    }\n    var shrinkI = !!(denseSpec.shrinkAxisMask & 1 << _i3);\n    var dimI = xShape[_i3];\n    if (dimI === -1) {\n      processingShape.push(shrinkI ? 1 : -1);\n      continue;\n    }\n    var masks = [denseSpec.beginMask & 1 << _i3, denseSpec.endMask & 1 << _i3];\n    var validRange = [denseSpec.strides[_i3] > 0 ? 0 : -1, denseSpec.strides[_i3] > 0 ? dimI : dimI - 1];\n    if (shrinkI && denseSpec.strides[_i3] <= 0) {\n      throw Error('only stride 1 allowed on non-range indexing.');\n    }\n    isSimpleSlice = isSimpleSlice && denseSpec.strides[_i3] === 1;\n    var beginAndEndMasked = !!(denseSpec.beginMask & 1 << _i3 && denseSpec.endMask & 1 << _i3);\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      if (shrinkI) {\n        // If we are shrinking, the end index is now possibly incorrect. In\n        // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n        // and canonical puts these to n-1 and 0, which implies a degenerate\n        // interval. Fortunately, it is now safe to re-create end as begin + 1.\n        var xFwd = denseSpec.begin[_i3] < 0 ? dimI + denseSpec.begin[_i3] : denseSpec.begin[_i3];\n        denseSpec.begin[_i3] = xFwd;\n        denseSpec.end[_i3] = denseSpec.begin[_i3] + 1;\n        if (xFwd < 0 || xFwd >= dimI) {\n          throw Error(\"slice index \".concat(denseSpec.begin[_i3], \" of dimension \").concat(_i3, \" out of bounds.\"));\n        }\n      } else {\n        denseSpec.begin[_i3] = canonical(denseSpec.begin[_i3], 0, denseSpec.strides[_i3], dimI, masks, validRange);\n        denseSpec.end[_i3] = canonical(denseSpec.end[_i3], 1, denseSpec.strides[_i3], dimI, masks, validRange);\n      }\n      // Update optimization values\n      var takeAllInDimension = denseSpec.strides[_i3] === 1 && denseSpec.begin[_i3] === 0 && denseSpec.end[_i3] === dimI;\n      isIdentity = isIdentity && takeAllInDimension;\n      sliceDim0 = sliceDim0 && (_i3 === 0 && denseSpec.strides[_i3] === 1 || takeAllInDimension);\n    } else {\n      isIdentity = isIdentity && denseSpec.strides[_i3] === 1 && beginAndEndMasked;\n      sliceDim0 = sliceDim0 && (_i3 === 0 && denseSpec.strides[_i3] === 1 || beginAndEndMasked);\n    }\n    // Compute the processing shape (the intermediate Eigen will produce)\n    var intervalLength = void 0;\n    var knownInterval = false;\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      intervalLength = denseSpec.end[_i3] - denseSpec.begin[_i3];\n      knownInterval = true;\n    } else if (shrinkI) {\n      // The dimension is still known as 1 for the processingShape, but will be\n      // discarded for the final shape.\n      intervalLength = 1;\n      knownInterval = true;\n    } else if (beginAndEndMasked) {\n      // Even if we don't have values for begin or end, we do know that this\n      // dimension covers the whole interval. If we have shape information for\n      // this dimension, that tells us the interval length.\n      if (dimI >= 0) {\n        if (denseSpec.strides[_i3] < 0) {\n          intervalLength = -dimI;\n        } else {\n          intervalLength = dimI;\n        }\n        knownInterval = true;\n      }\n    }\n    if (knownInterval) {\n      var sizeI = void 0;\n      // Hold zero if the interval is degenerate, otherwise account for\n      // remainder\n      if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[_i3] < 0) {\n        sizeI = 0;\n      } else {\n        sizeI = Math.trunc(intervalLength / denseSpec.strides[_i3]) + (intervalLength % denseSpec.strides[_i3] !== 0 ? 1 : 0);\n      }\n      processingShape.push(sizeI);\n    } else {\n      processingShape.push(-1);\n    }\n  }\n  // Step 4: Compute the final shape\n  //\n  // newAxis will increase dimension by 1 (with a one-size dimension)\n  // slices like foo[3, ...] will reduce dimension by 1.\n  // This cannot be done earlier, because it depends on Step 3.\n  for (var denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {\n    var gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n    if (gatherIndex >= 0) {\n      finalShape.push(processingShape[gatherIndex]);\n    } else if (gatherIndex === NEW_AXIS) {\n      finalShape.push(1);\n    }\n  }\n  var finalShapeSparse = finalShape.filter(function (dim, i) {\n    return denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS;\n  });\n  return {\n    finalShapeSparse: finalShapeSparse,\n    finalShape: finalShape,\n    isIdentity: isIdentity,\n    sliceDim0: sliceDim0,\n    isSimpleSlice: isSimpleSlice,\n    begin: denseSpec.begin,\n    end: denseSpec.end,\n    strides: denseSpec.strides\n  };\n}\nfunction buildDenseSpec(sparse, dense) {\n  dense.beginMask = 0;\n  dense.endMask = 0;\n  dense.shrinkAxisMask = 0;\n  var fullIndex = 0;\n  dense.beginValid = sparse.begin != null;\n  dense.endValid = sparse.end != null;\n  dense.begin = new Array(dense.dims);\n  dense.end = new Array(dense.dims);\n  dense.strides = new Array(dense.dims);\n  dense.finalShapeGatherIndices = [];\n  dense.finalShapeGatherIndicesSparse = [];\n  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n  for (var i = 0; i < sparse.dims; i++) {\n    if (1 << i & sparse.ellipsisMask) {\n      // Only the bit that has ellipsis will fall in this condition.\n      // Expand the ellipsis into the appropriate indices\n      // Note: this only works because we guaranteed one ellipsis.\n      var nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);\n      for (; fullIndex < nextIndex; fullIndex++) {\n        // newAxis aren't real axis so you have to skip.\n        dense.begin[fullIndex] = 0;\n        dense.end[fullIndex] = 0;\n        dense.strides[fullIndex] = 1;\n        dense.beginMask |= 1 << fullIndex;\n        dense.endMask |= 1 << fullIndex;\n        dense.finalShapeGatherIndices.push(fullIndex);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      }\n    } else if (1 << i & sparse.newAxisMask) {\n      // Only the bit that has newAxis will fall in this condition.\n      dense.finalShapeGatherIndices.push(NEW_AXIS);\n      dense.finalShapeGatherIndicesSparse.push(-1);\n    } else {\n      if (fullIndex === dense.begin.length) {\n        throw Error(\"Index out of range using input dim \".concat(fullIndex, \"; input \") + \"has only \".concat(dense.dims, \" dims, \").concat(dense.begin.length, \".\"));\n      }\n      // Gather slicing spec into appropriate index.\n      if (sparse.begin != null) {\n        dense.begin[fullIndex] = sparse.begin[i];\n      }\n      if (sparse.end != null) {\n        dense.end[fullIndex] = sparse.end[i];\n      }\n      dense.strides[fullIndex] = sparse.strides[i];\n      if (sparse.beginMask & 1 << i) {\n        dense.beginMask |= 1 << fullIndex;\n      }\n      if (sparse.endMask & 1 << i) {\n        dense.endMask |= 1 << fullIndex;\n      }\n      // If shrink, record where to get the dimensionality from (i.e. newAxis)\n      // creates a fake 1 size dimension. Also remember shrink axis (now in\n      // dense form) so we can ignore dense.end below.\n      if (sparse.shrinkAxisMask & 1 << i) {\n        dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.shrinkAxisMask |= 1 << fullIndex;\n      } else {\n        dense.finalShapeGatherIndices.push(fullIndex);\n        // Remember that where in the sparse shape the dense dim comes from.\n        dense.finalShapeGatherIndicesSparse.push(i);\n      }\n      dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      fullIndex++;\n    }\n  }\n}\nfunction canonical(x, c, strideI, dimI, masks, validRange) {\n  if (masks[c]) {\n    return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];\n  } else {\n    var xFwd = x < 0 ? dimI + x : x; // make negative indices positive\n    return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;\n  }\n}","map":{"version":3,"names":["util","NEW_AXIS","SHRINK_AXIS","assertParamsValid","input","begin","size","inputRank","shape","length","assert","concat","_loop","i","maskToAxes","mask","axes","axis","push","computeOutShape","end","strides","Math","ceil","stridesWithElidedDims","ellipsisInsertionIndex","numElidedAxes","inputShape","newStrides","_toConsumableArray","splice","pop","unnormalizeAxis","normalizedAxis","getElidedAxes","elidedAxes","getNormalizedAxes","ellipsisAxes","numInterpolatedAxes","beginMask","endMask","ellipsisMask","normalizedBegin","Array","normalizedEnd","normalizedStrides","fullIndex","startIndicesWithElidedDims","stopIndicesWithElidedDims","startForAxis","stopForAxis","stridesForAxis","originalBegin","newIndices","indexOf","originalAxis","originalValue","originalEnd","Number","MAX_SAFE_INTEGER","axisSize","clamp","stride","startIndices","start","MIN_SAFE_INTEGER","stopIndices","stop","isSliceContinous","firstNonOneAxis","computeFlatOffset","flatOffset","parseSliceParams","x","begin_","xRank","fill","slice","forEach","d","size_","map","sliceInfo","xShape","newAxisMask","shrinkAxisMask","stridesNonNull","Error","ellipsisSeen","sparseSpec","dims","numAddAxisAfterEllipsis","denseSpec","beginValid","endValid","buildDenseSpec","isIdentity","sliceDim0","isSimpleSlice","processingShape","finalShape","shrinkI","dimI","masks","validRange","beginAndEndMasked","xFwd","canonical","takeAllInDimension","intervalLength","knownInterval","sizeI","trunc","denseDim","finalShapeGatherIndices","gatherIndex","finalShapeSparse","filter","dim","sparse","dense","finalShapeGatherIndicesSparse","inputShapeGatherIndicesSparse","nextIndex","min","c","strideI"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\ops\\slice_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { TensorInfo } from '../tensor_info';\nimport * as util from '../util';\n\nconst NEW_AXIS = -2;\nconst SHRINK_AXIS = -1;\n\n// Sparse slicing specification\n// if one does foo[3:5, ..., -3], the begin, end and strides will have length\n// of 3.\ninterface StridedSliceSparseSpec {\n  dims: number;\n  numAddAxisAfterEllipsis: number;\n  begin: number[];\n  end: number[];\n  strides: number[];\n  beginMask: number;\n  endMask: number;\n  ellipsisMask: number;\n  newAxisMask: number;\n  shrinkAxisMask: number;\n}\n\n// Dense slicing specification\n// all ellipses and newaxis are expanded out. So if foo[3:5, ..., -3] where foo\n// is 10 dimensional, each array of begin, end, strides will have 10 entries\n// where as the sparse can have length less than the rank of foo.\ninterface StridedSliceDenseSpec {\n  dims: number;\n  beginMask?: number;\n  endMask?: number;\n  beginValid: boolean;\n  endValid: boolean;\n  begin?: number[];\n  end?: number[];\n  strides?: number[];\n  // This array helps construct the final shape of the slice.\n  // The final tensor is reduced in rank whenever a single index e.g. foo[3]\n  // is called for. The final tensor increases in rank with newAxis entries.\n  // If an index in this array is positive, the size of the dimension is\n  // obtained from canonical end-begin.  Otherwise, if it is a NEW_AXIS, it will\n  // be 1. A shrunk dimension is skipped.\n  finalShapeGatherIndices?: number[];\n  // This array has the same size as finalShapeGatherIndices, but it remembers\n  // the sparse index that a dimension comes from, instead of dense index.\n  // A -1 in this vector means the index is not from the sparse input.\n  finalShapeGatherIndicesSparse?: number[];\n  inputShapeGatherIndicesSparse?: number[];\n  // The dense indexed shrink mask is which processing dimensions should be\n  // shrunk. For example, if foo.shape = [10, 10, 10, 10], foo[3, ..., 5] has\n  // sparseShrinkAxisMask of 5 (0101) and denseShrinkAxisMask of 9 (1001),\n  // yielding a final shape [10, 10].\n  shrinkAxisMask?: number;\n}\n\nexport type SliceInfo = {\n  finalShapeSparse: number[],\n  finalShape: number[],\n  isIdentity: boolean,\n  sliceDim0: boolean,\n  isSimpleSlice: boolean,\n  begin: number[],\n  end: number[],\n  strides: number[]\n};\n\nexport function assertParamsValid(\n    input: TensorInfo, begin: number[], size: number[]): void {\n  const inputRank = input.shape.length;\n  util.assert(\n      inputRank === begin.length,\n      () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n          `match the rank of the array (${inputRank}).`);\n  util.assert(\n      inputRank === size.length,\n      () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n          `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(\n        begin[i] + size[i] <= input.shape[i],\n        () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${\n                  input.shape[i]})`);\n  }\n}\n\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask: number): number[] {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(\n    begin: number[], end: number[], strides: number[]): number[] {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(\n    strides: number[], ellipsisInsertionIndex: number, numElidedAxes: number,\n    inputShape: number[]): number[] {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(\n          ellipsisInsertionIndex, 0 /* num elements to delete */,\n          1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\n\nfunction unnormalizeAxis(\n    ellipsisInsertionIndex: number, numElidedAxes: number,\n    normalizedAxis: number): number {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes: number, ellipsisInsertionIndex: number) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(\n    inputShape: number[], ellipsisAxes: number[], numInterpolatedAxes: number,\n    begin: number[], end: number[], strides: number[], beginMask: number,\n    endMask: number,\n    ellipsisMask: number): {begin: number[], end: number[], strides: number[]} {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(\n        beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(\n        endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides =\n        stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(\n          beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] =\n          stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(\n    beginMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalBegin: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(\n    endMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalEnd: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\n\nexport function stridesForAxis(\n    strides: number[], axis: number, ellipsisMask: number): number {\n  let stride = strides[axis];\n  if (ellipsisMask & (1 << axis) || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\n\nexport function startForAxis(\n    beginMask: number, startIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n\n  return start;\n}\n\nexport function stopForAxis(\n    endMask: number, stopIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(\n    shape: number[], begin: number[], size: number[]) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function computeFlatOffset(begin: number[], strides: number[]): number {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\n\nexport function parseSliceParams(\n    x: TensorInfo, begin: number|number[], size?: number|number[]) {\n  // The following logic allows for more ergonomic calls.\n  let begin_: number[];\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(\n        d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_: number[];\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(\n          d === -1,\n          () => `Negative size values should be exactly -1 but got ` +\n              `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\n\n// Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\nexport function sliceInfo(\n    xShape: number[], begin: number[], end: number[], strides: number[],\n    beginMask: number, endMask: number, ellipsisMask: number,\n    newAxisMask: number, shrinkAxisMask: number): SliceInfo {\n  let stridesNonNull;\n  if (strides == null) {\n    stridesNonNull = new Array(begin.length);\n    stridesNonNull.fill(1);\n  } else {\n    stridesNonNull = strides;\n  }\n\n  // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n  // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n  // of 2. When i is a power of 2, i & (i - 1) is always 0.\n  // Also ref:\n  // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n  if (ellipsisMask != null && (ellipsisMask & (ellipsisMask - 1)) !== 0) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  // Step 1: Account for ellipsis and new axis.\n  // Check for ellipsis and count how many non-newaxis there are after.\n  let ellipsisSeen = false;\n\n  const sparseSpec: StridedSliceSparseSpec = {\n    dims: stridesNonNull.length,\n    numAddAxisAfterEllipsis: 0,\n    begin: begin.slice(),\n    end: end.slice(),\n    strides: stridesNonNull.slice(),\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  };\n\n  for (let i = 0; i < sparseSpec.dims; i++) {\n    if (ellipsisSeen && ((1 << i) & newAxisMask) !== 0) {\n      sparseSpec.numAddAxisAfterEllipsis++;\n    }\n    if ((1 << i) & ellipsisMask) {\n      ellipsisSeen = true;\n    }\n  }\n  // If no ellipsis insert one at the end.\n  if (!ellipsisSeen) {\n    sparseSpec.ellipsisMask |= (1 << sparseSpec.dims);\n    sparseSpec.dims++;  // this effects loop iteration below\n  }\n\n  // Step 2: Make a sparse spec into a full index spec.\n  //\n  // The sparse spec deos not correspond to the number of dimensions.\n  // Make a dense spec that cooresponds to the number of dimensions.\n  //\n  // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n  // produce the missing beginMask for the first two dimensions i.e. from\n  // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n  // endMask = 7 (111).\n  const denseSpec: StridedSliceDenseSpec = {\n    dims: xShape.length,\n    beginMask: 0,\n    endMask: 0,\n    beginValid: false,\n    endValid: false\n  };\n\n  buildDenseSpec(sparseSpec, denseSpec);\n\n  // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n  // and bounds check.\n  let isIdentity = true;\n  let sliceDim0 = true;\n  let isSimpleSlice = true;\n  const processingShape = [];\n  const finalShape = [];\n\n  for (let i = 0; i < xShape.length; ++i) {\n    if (denseSpec.strides[i] === 0) {\n      throw Error(`strides[${i}] must be non-zero`);\n    }\n    const shrinkI = !!(denseSpec.shrinkAxisMask & (1 << i));\n    const dimI = xShape[i];\n    if (dimI === -1) {\n      processingShape.push(shrinkI ? 1 : -1);\n      continue;\n    }\n\n    const masks =\n        [denseSpec.beginMask & (1 << i), denseSpec.endMask & (1 << i)];\n    const validRange = [\n      denseSpec.strides[i] > 0 ? 0 : -1,\n      denseSpec.strides[i] > 0 ? dimI : dimI - 1\n    ];\n\n    if (shrinkI && denseSpec.strides[i] <= 0) {\n      throw Error('only stride 1 allowed on non-range indexing.');\n    }\n\n    isSimpleSlice = isSimpleSlice && (denseSpec.strides[i] === 1);\n\n    const beginAndEndMasked =\n        !!((denseSpec.beginMask & (1 << i)) && (denseSpec.endMask & (1 << i)));\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      if (shrinkI) {\n        // If we are shrinking, the end index is now possibly incorrect. In\n        // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n        // and canonical puts these to n-1 and 0, which implies a degenerate\n        // interval. Fortunately, it is now safe to re-create end as begin + 1.\n        const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] :\n                                              denseSpec.begin[i];\n        denseSpec.begin[i] = xFwd;\n        denseSpec.end[i] = denseSpec.begin[i] + 1;\n        if (xFwd < 0 || xFwd >= dimI) {\n          throw Error(`slice index ${denseSpec.begin[i]} of dimension ${\n              i} out of bounds.`);\n        }\n      } else {\n        denseSpec.begin[i] = canonical(\n            denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks,\n            validRange);\n        denseSpec.end[i] = canonical(\n            denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);\n      }\n      // Update optimization values\n      const takeAllInDimension = denseSpec.strides[i] === 1 &&\n          denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;\n      isIdentity = isIdentity && takeAllInDimension;\n      sliceDim0 = sliceDim0 &&\n          ((i === 0 && denseSpec.strides[i] === 1) || takeAllInDimension);\n    } else {\n      isIdentity =\n          isIdentity && ((denseSpec.strides[i] === 1) && beginAndEndMasked);\n      sliceDim0 = sliceDim0 &&\n          ((i === 0 && denseSpec.strides[i] === 1) || beginAndEndMasked);\n    }\n    // Compute the processing shape (the intermediate Eigen will produce)\n    let intervalLength;\n    let knownInterval = false;\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      intervalLength = denseSpec.end[i] - denseSpec.begin[i];\n      knownInterval = true;\n    } else if (shrinkI) {\n      // The dimension is still known as 1 for the processingShape, but will be\n      // discarded for the final shape.\n      intervalLength = 1;\n      knownInterval = true;\n    } else if (beginAndEndMasked) {\n      // Even if we don't have values for begin or end, we do know that this\n      // dimension covers the whole interval. If we have shape information for\n      // this dimension, that tells us the interval length.\n      if (dimI >= 0) {\n        if (denseSpec.strides[i] < 0) {\n          intervalLength = -dimI;\n        } else {\n          intervalLength = dimI;\n        }\n        knownInterval = true;\n      }\n    }\n    if (knownInterval) {\n      let sizeI;\n      // Hold zero if the interval is degenerate, otherwise account for\n      // remainder\n      if (intervalLength === 0 ||\n          ((intervalLength < 0) !== (denseSpec.strides[i] < 0))) {\n        sizeI = 0;\n      } else {\n        sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) +\n            (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);\n      }\n      processingShape.push(sizeI);\n    } else {\n      processingShape.push(-1);\n    }\n  }\n\n  // Step 4: Compute the final shape\n  //\n  // newAxis will increase dimension by 1 (with a one-size dimension)\n  // slices like foo[3, ...] will reduce dimension by 1.\n  // This cannot be done earlier, because it depends on Step 3.\n  for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length;\n       ++denseDim) {\n    const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n    if (gatherIndex >= 0) {\n      finalShape.push(processingShape[gatherIndex]);\n    } else if (gatherIndex === NEW_AXIS) {\n      finalShape.push(1);\n    }\n  }\n\n  const finalShapeSparse = finalShape.filter(\n      (dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);\n\n  return {\n    finalShapeSparse,\n    finalShape,\n    isIdentity,\n    sliceDim0,\n    isSimpleSlice,\n    begin: denseSpec.begin,\n    end: denseSpec.end,\n    strides: denseSpec.strides\n  };\n}\n\nfunction buildDenseSpec(\n    sparse: StridedSliceSparseSpec, dense: StridedSliceDenseSpec) {\n  dense.beginMask = 0;\n  dense.endMask = 0;\n  dense.shrinkAxisMask = 0;\n\n  let fullIndex = 0;\n  dense.beginValid = sparse.begin != null;\n  dense.endValid = sparse.end != null;\n\n  dense.begin = new Array(dense.dims);\n  dense.end = new Array(dense.dims);\n  dense.strides = new Array(dense.dims);\n  dense.finalShapeGatherIndices = [];\n  dense.finalShapeGatherIndicesSparse = [];\n  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n\n  for (let i = 0; i < sparse.dims; i++) {\n    if ((1 << i) & sparse.ellipsisMask) {\n      // Only the bit that has ellipsis will fall in this condition.\n      // Expand the ellipsis into the appropriate indices\n      // Note: this only works because we guaranteed one ellipsis.\n      const nextIndex = Math.min(\n          dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis,\n          dense.dims);\n      for (; fullIndex < nextIndex; fullIndex++) {\n        // newAxis aren't real axis so you have to skip.\n        dense.begin[fullIndex] = 0;\n        dense.end[fullIndex] = 0;\n        dense.strides[fullIndex] = 1;\n        dense.beginMask |= (1 << fullIndex);\n        dense.endMask |= (1 << fullIndex);\n        dense.finalShapeGatherIndices.push(fullIndex);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      }\n    } else if ((1 << i) & sparse.newAxisMask) {\n      // Only the bit that has newAxis will fall in this condition.\n      dense.finalShapeGatherIndices.push(NEW_AXIS);\n      dense.finalShapeGatherIndicesSparse.push(-1);\n    } else {\n      if (fullIndex === dense.begin.length) {\n        throw Error(\n            `Index out of range using input dim ${fullIndex}; input ` +\n            `has only ${dense.dims} dims, ${dense.begin.length}.`);\n      }\n\n      // Gather slicing spec into appropriate index.\n      if (sparse.begin != null) {\n        dense.begin[fullIndex] = sparse.begin[i];\n      }\n      if (sparse.end != null) {\n        dense.end[fullIndex] = sparse.end[i];\n      }\n      dense.strides[fullIndex] = sparse.strides[i];\n      if (sparse.beginMask & (1 << i)) {\n        dense.beginMask |= (1 << fullIndex);\n      }\n      if (sparse.endMask & (1 << i)) {\n        dense.endMask |= (1 << fullIndex);\n      }\n      // If shrink, record where to get the dimensionality from (i.e. newAxis)\n      // creates a fake 1 size dimension. Also remember shrink axis (now in\n      // dense form) so we can ignore dense.end below.\n      if (sparse.shrinkAxisMask & (1 << i)) {\n        dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.shrinkAxisMask |= (1 << fullIndex);\n      } else {\n        dense.finalShapeGatherIndices.push(fullIndex);\n        // Remember that where in the sparse shape the dense dim comes from.\n        dense.finalShapeGatherIndicesSparse.push(i);\n      }\n      dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      fullIndex++;\n    }\n  }\n}\n\nfunction canonical(\n    x: number, c: number, strideI: number, dimI: number, masks: number[],\n    validRange: number[]) {\n  if (masks[c]) {\n    return strideI > 0 ? validRange[c] : validRange[(c + 1) & 1];\n  } else {\n    const xFwd = x < 0 ? dimI + x : x;  // make negative indices positive\n    return xFwd < validRange[0] ? validRange[0] :\n                                  xFwd > validRange[1] ? validRange[1] : xFwd;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}