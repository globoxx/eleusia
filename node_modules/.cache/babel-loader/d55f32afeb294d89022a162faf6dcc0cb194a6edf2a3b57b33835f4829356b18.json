{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\r\n * Calculate FFT of inner most elements of batch tensor.\r\n */\nexport function fftBatch(input, inverse, cpuBackend) {\n  var inputShape = input.shape;\n  var batch = inputShape[0];\n  var innerDim = inputShape[1];\n  var inputVals = cpuBackend.data.get(input.dataId);\n  var real2D = inputVals.complexTensorInfos.real;\n  var imag2D = inputVals.complexTensorInfos.imag;\n  // Collects real and imaginary values separately.\n  var resultShape = [batch, innerDim];\n  var resultSize = util.sizeFromShape(resultShape);\n  var resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  var resultImag = util.getTypedArrayFromDType('float32', resultSize);\n  for (var b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    var r = slice({\n      inputs: {\n        x: real2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    var i = slice({\n      inputs: {\n        x: imag2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    var _input = complex({\n      inputs: {\n        real: r,\n        imag: i\n      },\n      backend: cpuBackend\n    });\n    // Run FFT by batch element.\n    var _fftImpl = fftImpl(_input, inverse, cpuBackend),\n      _real = _fftImpl.real,\n      _imag = _fftImpl.imag;\n    var res = backend_util.mergeRealAndImagArrays(_real, _imag);\n    for (var d = 0; d < innerDim; d++) {\n      var c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(_input);\n  }\n  var $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  var $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n  var result = complex({\n    inputs: {\n      real: $realInfo,\n      imag: $imagInfo\n    },\n    backend: cpuBackend\n  });\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n  return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n  var inputSize = util.sizeFromShape(input.shape);\n  var inputVals = cpuBackend.data.get(input.dataId);\n  var realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n  var imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n  if (isExponentOf2(inputSize)) {\n    var result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n    var resultShape = [input.shape[0], input.shape[1]];\n    if (inverse) {\n      var realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      var imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n      var sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n      var sizeInfoCopy = identity({\n        inputs: {\n          x: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      var divRealInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: realInfo,\n          b: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      var divImagInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: imagInfo,\n          b: sizeInfoCopy\n        },\n        backend: cpuBackend\n      });\n      var divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n      var divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n      return {\n        real: divRealVals,\n        imag: divImagVals\n      };\n    }\n    return result;\n  } else {\n    var data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    var rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\nfunction isExponentOf2(size) {\n  return (size & size - 1) === 0;\n}\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n  if (size === 1) {\n    return {\n      real: realVals,\n      imag: imagVals\n    };\n  }\n  var data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n  var half = size / 2;\n  var evenComplex = backend_util.complexWithEvenIndex(data);\n  var evenRealVals = evenComplex.real;\n  var evenImagVals = evenComplex.imag;\n  var evenShape = [evenRealVals.length];\n  var evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  var evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n  var evenTensorInfo = complex({\n    inputs: {\n      real: evenRealInfo,\n      imag: evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  var oddComplex = backend_util.complexWithOddIndex(data);\n  var oddRealVals = oddComplex.real;\n  var oddImagVals = oddComplex.imag;\n  var oddShape = [oddRealVals.length];\n  var oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  var oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n  var oddTensorInfo = complex({\n    inputs: {\n      real: oddRealInfo,\n      imag: oddImagInfo\n    },\n    backend: cpuBackend\n  });\n  // Recursive call for half part of original input.\n  var $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n  var $evenRealVals = $evenComplex.real;\n  var $evenImagVals = $evenComplex.imag;\n  var $evenShape = [$evenRealVals.length];\n  var $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  var $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n  var $evenTensorInfo = complex({\n    inputs: {\n      real: $evenRealInfo,\n      imag: $evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  var $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n  var $oddRealVals = $oddComplex.real;\n  var $oddImagVals = $oddComplex.imag;\n  var $oddShape = [$oddRealVals.length];\n  var $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  var $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n  var $oddTensorInfo = complex({\n    inputs: {\n      real: $oddRealInfo,\n      imag: $oddImagInfo\n    },\n    backend: cpuBackend\n  });\n  var e = backend_util.exponents(size, inverse);\n  var eShape = [e.real.length];\n  var eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  var eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n  var complexInfo = complex({\n    inputs: {\n      real: eRealInfo,\n      imag: eImagInfo\n    },\n    backend: cpuBackend\n  });\n  var exponentInfo = multiply({\n    inputs: {\n      a: complexInfo,\n      b: $oddTensorInfo\n    },\n    backend: cpuBackend\n  });\n  var addPart = add({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  var subPart = sub({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  var addPartReal = real({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  var subPartReal = real({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  var addPartImag = imag({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  var subPartImag = imag({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  var $real = concat({\n    inputs: [addPartReal, subPartReal],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  var $imag = concat({\n    inputs: [addPartImag, subPartImag],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  var $realVals = cpuBackend.data.get($real.dataId).values;\n  var $imagVals = cpuBackend.data.get($imag.dataId).values;\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n  return {\n    real: $realVals,\n    imag: $imagVals\n  };\n}\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(data, size, inverse) {\n  var ret = new Float32Array(size * 2);\n  // TODO: Use matmul instead once it supports complex64 type.\n  for (var r = 0; r < size; r++) {\n    var _real2 = 0.0;\n    var _imag2 = 0.0;\n    for (var c = 0; c < size; c++) {\n      var e = backend_util.exponent(r * c, size, inverse);\n      var term = backend_util.getComplexWithIndex(data, c);\n      _real2 += term.real * e.real - term.imag * e.imag;\n      _imag2 += term.real * e.imag + term.imag * e.real;\n    }\n    if (inverse) {\n      _real2 /= size;\n      _imag2 /= size;\n    }\n    backend_util.assignToTypedArray(ret, _real2, _imag2, r);\n  }\n  return ret;\n}","map":{"version":3,"names":["backend_util","util","add","complex","concat","identity","imag","multiply","real","realDivConfig","slice","sub","fftBatch","input","inverse","cpuBackend","inputShape","shape","batch","innerDim","inputVals","data","get","dataId","real2D","complexTensorInfos","imag2D","resultShape","resultSize","sizeFromShape","resultReal","getTypedArrayFromDType","resultImag","b","r","inputs","x","backend","attrs","begin","size","i","_fftImpl","fftImpl","res","mergeRealAndImagArrays","d","c","getComplexWithIndex","disposeIntermediateTensorInfo","$realInfo","makeTensorInfo","$imagInfo","result","inputSize","realVals","values","imagVals","isExponentOf2","fftRadix2","realInfo","imagInfo","sizeInfo","createScalarValue","sizeInfoCopy","divRealInfo","kernelFunc","a","divImagInfo","divRealVals","divImagVals","rawOutput","fourierTransformByMatmul","splitRealAndImagArrays","half","evenComplex","complexWithEvenIndex","evenRealVals","evenImagVals","evenShape","length","evenRealInfo","evenImagInfo","evenTensorInfo","oddComplex","complexWithOddIndex","oddRealVals","oddImagVals","oddShape","oddRealInfo","oddImagInfo","oddTensorInfo","$evenComplex","$evenRealVals","$evenImagVals","$evenShape","$evenRealInfo","$evenImagInfo","$evenTensorInfo","$oddComplex","$oddRealVals","$oddImagVals","$oddShape","$oddRealInfo","$oddImagInfo","$oddTensorInfo","e","exponents","eShape","eRealInfo","eImagInfo","complexInfo","exponentInfo","addPart","subPart","addPartReal","subPartReal","addPartImag","subPartImag","$real","axis","$imag","$realVals","$imagVals","ret","Float32Array","exponent","term","assignToTypedArray"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-cpu\\src\\utils\\fft_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Tensor, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {add} from '../kernels/Add';\nimport {complex} from '../kernels/Complex';\nimport {concat} from '../kernels/Concat';\nimport {identity} from '../kernels/Identity';\nimport {imag} from '../kernels/Imag';\nimport {multiply} from '../kernels/Multiply';\nimport {real} from '../kernels/Real';\nimport {realDivConfig} from '../kernels/RealDiv';\nimport {slice} from '../kernels/Slice';\nimport {sub} from '../kernels/Sub';\n\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\nexport function fftBatch(\n    input: TensorInfo, inverse: boolean,\n    cpuBackend: MathBackendCPU): TensorInfo {\n  const inputShape = input.shape;\n  const batch = inputShape[0];\n  const innerDim = inputShape[1];\n\n  const inputVals = cpuBackend.data.get(input.dataId);\n\n  const real2D = inputVals.complexTensorInfos.real;\n  const imag2D = inputVals.complexTensorInfos.imag;\n\n  // Collects real and imaginary values separately.\n  const resultShape = [batch, innerDim];\n  const resultSize = util.sizeFromShape(resultShape);\n  const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n\n  for (let b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    const r = slice({\n      inputs: {x: real2D},\n      backend: cpuBackend,\n      attrs: {begin: [b, 0], size: [1, innerDim]}\n    });\n    const i = slice({\n      inputs: {x: imag2D},\n      backend: cpuBackend,\n      attrs: {begin: [b, 0], size: [1, innerDim]}\n    });\n\n    const input = complex({inputs: {real: r, imag: i}, backend: cpuBackend});\n\n    // Run FFT by batch element.\n    const {real, imag} = fftImpl(input, inverse, cpuBackend);\n    const res = backend_util.mergeRealAndImagArrays(real, imag);\n\n    for (let d = 0; d < innerDim; d++) {\n      const c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(input);\n  }\n\n  const $realInfo: TensorInfo =\n      cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  const $imagInfo: TensorInfo =\n      cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n\n  const result = complex(\n      {inputs: {real: $realInfo, imag: $imagInfo}, backend: cpuBackend});\n\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n\n  return result;\n}\n\nexport function fftImpl(\n    input: TensorInfo, inverse: boolean,\n    cpuBackend: MathBackendCPU): {real: Float32Array, imag: Float32Array} {\n  const inputSize = util.sizeFromShape(input.shape);\n\n  const inputVals = cpuBackend.data.get(input.dataId);\n\n  const realVals =\n      cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values as\n      Float32Array;\n\n  const imagVals =\n      cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values as\n      Float32Array;\n\n  if (isExponentOf2(inputSize)) {\n    const result =\n        fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n\n    const resultShape = [input.shape[0], input.shape[1]];\n\n    if (inverse) {\n      const realInfo: TensorInfo =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      const imagInfo: TensorInfo =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n\n      const sizeInfo: TensorInfo = cpuBackend.makeTensorInfo(\n          [], 'float32',\n          util.createScalarValue(inputSize as unknown as 'float32', 'float32'));\n      const sizeInfoCopy =\n          identity({inputs: {x: sizeInfo}, backend: cpuBackend});\n\n      const divRealInfo =\n          realDivConfig.kernelFunc(\n              {inputs: {a: realInfo, b: sizeInfo}, backend: cpuBackend}) as\n          TensorInfo;\n      const divImagInfo =\n          realDivConfig.kernelFunc(\n              {inputs: {a: imagInfo, b: sizeInfoCopy}, backend: cpuBackend}) as\n          TensorInfo;\n\n      const divRealVals =\n          cpuBackend.data.get(divRealInfo.dataId).values as Float32Array;\n      const divImagVals =\n          cpuBackend.data.get(divImagInfo.dataId).values as Float32Array;\n\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n\n      return {real: divRealVals, imag: divImagVals};\n    }\n\n    return result;\n  } else {\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n\n    const rawOutput =\n        fourierTransformByMatmul(data, inputSize, inverse) as Float32Array;\n\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\n\nfunction isExponentOf2(size: number): boolean {\n  return (size & size - 1) === 0;\n}\n\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(\n    realVals: Float32Array, imagVals: Float32Array, size: number,\n    inverse: boolean,\n    cpuBackend: MathBackendCPU): {real: Float32Array, imag: Float32Array} {\n  if (size === 1) {\n    return {real: realVals, imag: imagVals};\n  }\n\n  const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n\n  const half = size / 2;\n\n  const evenComplex = backend_util.complexWithEvenIndex(data);\n\n  const evenRealVals = evenComplex.real;\n  const evenImagVals = evenComplex.imag;\n\n  const evenShape = [evenRealVals.length];\n\n  const evenRealInfo =\n      cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  const evenImagInfo =\n      cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n\n  const evenTensorInfo = complex(\n      {inputs: {real: evenRealInfo, imag: evenImagInfo}, backend: cpuBackend});\n\n  const oddComplex = backend_util.complexWithOddIndex(data);\n\n  const oddRealVals = oddComplex.real;\n  const oddImagVals = oddComplex.imag;\n\n  const oddShape = [oddRealVals.length];\n\n  const oddRealInfo =\n      cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  const oddImagInfo =\n      cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n\n  const oddTensorInfo = complex(\n      {inputs: {real: oddRealInfo, imag: oddImagInfo}, backend: cpuBackend});\n\n  // Recursive call for half part of original input.\n  const $evenComplex =\n      fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n\n  const $evenRealVals = $evenComplex.real;\n  const $evenImagVals = $evenComplex.imag;\n\n  const $evenShape = [$evenRealVals.length];\n\n  const $evenRealInfo =\n      cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  const $evenImagInfo =\n      cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n\n  const $evenTensorInfo = complex({\n    inputs: {real: $evenRealInfo, imag: $evenImagInfo},\n    backend: cpuBackend\n  });\n\n  const $oddComplex =\n      fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n\n  const $oddRealVals = $oddComplex.real;\n  const $oddImagVals = $oddComplex.imag;\n\n  const $oddShape = [$oddRealVals.length];\n\n  const $oddRealInfo =\n      cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  const $oddImagInfo =\n      cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n\n  const $oddTensorInfo = complex(\n      {inputs: {real: $oddRealInfo, imag: $oddImagInfo}, backend: cpuBackend});\n\n  const e = backend_util.exponents(size, inverse);\n  const eShape = [e.real.length];\n\n  const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n\n  const complexInfo = complex(\n      {inputs: {real: eRealInfo, imag: eImagInfo}, backend: cpuBackend});\n\n  const exponentInfo =\n      multiply(\n          {inputs: {a: complexInfo, b: $oddTensorInfo}, backend: cpuBackend}) as\n      TensorInfo;\n\n  const addPart = add({\n                    inputs: {a: $evenTensorInfo, b: exponentInfo},\n                    backend: cpuBackend\n                  }) as TensorInfo;\n  const subPart = sub({\n                    inputs: {a: $evenTensorInfo, b: exponentInfo},\n                    backend: cpuBackend\n                  }) as TensorInfo;\n\n  const addPartReal = real({inputs: {input: addPart}, backend: cpuBackend});\n  const subPartReal = real({inputs: {input: subPart}, backend: cpuBackend});\n\n  const addPartImag = imag({inputs: {input: addPart}, backend: cpuBackend});\n  const subPartImag = imag({inputs: {input: subPart}, backend: cpuBackend});\n\n  const $real = concat({\n    inputs: [addPartReal as Tensor, subPartReal as Tensor],\n    backend: cpuBackend,\n    attrs: {axis: 0}\n  });\n  const $imag = concat({\n    inputs: [addPartImag as Tensor, subPartImag as Tensor],\n    backend: cpuBackend,\n    attrs: {axis: 0}\n  });\n\n  const $realVals = cpuBackend.data.get($real.dataId).values as Float32Array;\n  const $imagVals = cpuBackend.data.get($imag.dataId).values as Float32Array;\n\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n\n  return {real: $realVals, imag: $imagVals};\n}\n\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(\n    data: TypedArray, size: number, inverse: boolean): TypedArray {\n  const ret = new Float32Array(size * 2);\n  // TODO: Use matmul instead once it supports complex64 type.\n  for (let r = 0; r < size; r++) {\n    let real = 0.0;\n    let imag = 0.0;\n    for (let c = 0; c < size; c++) {\n      const e = backend_util.exponent(r * c, size, inverse);\n      const term = backend_util.getComplexWithIndex(data as Float32Array, c);\n      real += term.real * e.real - term.imag * e.imag;\n      imag += term.real * e.imag + term.imag * e.real;\n    }\n    if (inverse) {\n      real /= size;\n      imag /= size;\n    }\n    backend_util.assignToTypedArray(ret, real, imag, r);\n  }\n  return ret;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}