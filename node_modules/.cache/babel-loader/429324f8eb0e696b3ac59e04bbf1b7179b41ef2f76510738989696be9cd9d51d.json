{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var CropAndResizeProgram = /*#__PURE__*/_createClass(function CropAndResizeProgram(imageShape, boxShape, cropSize, method, extrapolationValue) {\n  _classCallCheck(this, CropAndResizeProgram);\n  this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n  this.outputShape = [];\n  var _imageShape = _slicedToArray(imageShape, 4),\n    batch = _imageShape[0],\n    imageHeight = _imageShape[1],\n    imageWidth = _imageShape[2],\n    depth = _imageShape[3];\n  var _boxShape = _slicedToArray(boxShape, 1),\n    numBoxes = _boxShape[0];\n  var _cropSize = _slicedToArray(cropSize, 2),\n    cropHeight = _cropSize[0],\n    cropWidth = _cropSize[1];\n  this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n  var methodId = method === 'bilinear' ? 1 : 0;\n  var inputHeightFloat = \"\".concat(imageHeight - 1, \".0\"),\n    inputWidthFloat = \"\".concat(imageWidth - 1, \".0\");\n  var _ref = cropHeight > 1 ? [\"\".concat((imageHeight - 1) / (cropHeight - 1)), '(y2-y1) * height_ratio', \"y1*\".concat(inputHeightFloat, \" + float(y)*(height_scale)\")] : ['0.0', '0.0', \"0.5 * (y1+y2) * \".concat(inputHeightFloat)],\n    _ref2 = _slicedToArray(_ref, 3),\n    heightRatio = _ref2[0],\n    heightScale = _ref2[1],\n    inY = _ref2[2];\n  var _ref3 = cropWidth > 1 ? [\"\".concat((imageWidth - 1) / (cropWidth - 1)), '(x2-x1) * width_ratio', \"x1*\".concat(inputWidthFloat, \" + float(x)*(width_scale)\")] : ['0.0', '0.0', \"0.5 * (x1+x2) * \".concat(inputWidthFloat)],\n    _ref4 = _slicedToArray(_ref3, 3),\n    widthRatio = _ref4[0],\n    widthScale = _ref4[1],\n    inX = _ref4[2];\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n  this.userCode = \"\\n      const float height_ratio = float(\".concat(heightRatio, \");\\n      const float width_ratio = float(\").concat(widthRatio, \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \").concat(batch, \") {\\n          return;\\n        }\\n\\n        float height_scale = \").concat(heightScale, \";\\n        float width_scale = \").concat(widthScale, \";\\n\\n        float in_y = \").concat(inY, \";\\n        if( in_y < 0.0 || in_y > \").concat(inputHeightFloat, \" ) {\\n          setOutput(float(\").concat(extrapolationValue, \"));\\n          return;\\n        }\\n        float in_x = \").concat(inX, \";\\n        if( in_x < 0.0 || in_x > \").concat(inputWidthFloat, \" ) {\\n          setOutput(float(\").concat(extrapolationValue, \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\").concat(methodId, \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \");\n});","map":{"version":3,"names":["CropAndResizeProgram","_createClass","imageShape","boxShape","cropSize","method","extrapolationValue","_classCallCheck","variableNames","outputShape","_imageShape","_slicedToArray","batch","imageHeight","imageWidth","depth","_boxShape","numBoxes","_cropSize","cropHeight","cropWidth","methodId","inputHeightFloat","concat","inputWidthFloat","_ref","_ref2","heightRatio","heightScale","inY","_ref3","_ref4","widthRatio","widthScale","inX","userCode"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\crop_and_resize_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class CropAndResizeProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], boxShape: [number, number],\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number) {\n    const [batch, imageHeight, imageWidth, depth] = imageShape;\n    const [numBoxes, ] = boxShape;\n    const [cropHeight, cropWidth] = cropSize;\n    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n    const methodId = method === 'bilinear' ? 1 : 0;\n\n    const [inputHeightFloat, inputWidthFloat] =\n        [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n\n    const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n        [\n          `${(imageHeight - 1) / (cropHeight - 1)}`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n        [\n          `${(imageWidth - 1) / (cropWidth - 1)}`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n  }\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;AAmBA,WAAaA,oBAAoB,gBAAAC,YAAA,CAK/B,SAAAD,qBACIE,UAA4C,EAAEC,QAA0B,EACxEC,QAA0B,EAAEC,MAA4B,EACxDC,kBAA0B;EAAAC,eAAA,OAAAP,oBAAA;EAP9B,KAAAQ,aAAa,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC;EAC5C,KAAAC,WAAW,GAAa,EAAE;EAOxB,IAAAC,WAAA,GAAAC,cAAA,CAAgDT,UAAU;IAAnDU,KAAK,GAAAF,WAAA;IAAEG,WAAW,GAAAH,WAAA;IAAEI,UAAU,GAAAJ,WAAA;IAAEK,KAAK,GAAAL,WAAA;EAC5C,IAAAM,SAAA,GAAAL,cAAA,CAAqBR,QAAQ;IAAtBc,QAAQ,GAAAD,SAAA;EACf,IAAAE,SAAA,GAAAP,cAAA,CAAgCP,QAAQ;IAAjCe,UAAU,GAAAD,SAAA;IAAEE,SAAS,GAAAF,SAAA;EAC5B,IAAI,CAACT,WAAW,GAAG,CAACQ,QAAQ,EAAEE,UAAU,EAAEC,SAAS,EAAEL,KAAK,CAAC;EAC3D,IAAMM,QAAQ,GAAGhB,MAAM,KAAK,UAAU,GAAG,CAAC,GAAG,CAAC;EAE9C,IAAOiB,gBAAgB,MAAAC,MAAA,CACfV,WAAW,GAAG,CAAC;IADEW,eAAe,MAAAD,MAAA,CACRT,UAAU,GAAG,CAAC;EAE9C,IAAAW,IAAA,GAAwCN,UAAU,GAAG,CAAC,GAClD,IAAAI,MAAA,CACK,CAACV,WAAW,GAAG,CAAC,KAAKM,UAAU,GAAG,CAAC,CAAC,GACvC,wBAAwB,QAAAI,MAAA,CAClBD,gBAAgB,gCACvB,GACD,CACE,KAAK,EACL,KAAK,qBAAAC,MAAA,CACcD,gBAAgB,EACpC;IAAAI,KAAA,GAAAf,cAAA,CAAAc,IAAA;IAVEE,WAAW,GAAAD,KAAA;IAAEE,WAAW,GAAAF,KAAA;IAAEG,GAAG,GAAAH,KAAA;EAWpC,IAAAI,KAAA,GAAsCV,SAAS,GAAG,CAAC,GAC/C,IAAAG,MAAA,CACK,CAACT,UAAU,GAAG,CAAC,KAAKM,SAAS,GAAG,CAAC,CAAC,GACrC,uBAAuB,QAAAG,MAAA,CACjBC,eAAe,+BACtB,GACD,CACE,KAAK,EACL,KAAK,qBAAAD,MAAA,CACcC,eAAe,EACnC;IAAAO,KAAA,GAAApB,cAAA,CAAAmB,KAAA;IAVEE,UAAU,GAAAD,KAAA;IAAEE,UAAU,GAAAF,KAAA;IAAEG,GAAG,GAAAH,KAAA;EAYlC;EACA;EACA;EACA,IAAI,CAACI,QAAQ,+CAAAZ,MAAA,CACwBI,WAAW,gDAAAJ,MAAA,CACZS,UAAU,gdAAAT,MAAA,CAgBjBX,KAAK,wEAAAW,MAAA,CAIPK,WAAW,qCAAAL,MAAA,CACZU,UAAU,gCAAAV,MAAA,CAEjBM,GAAG,0CAAAN,MAAA,CACSD,gBAAgB,sCAAAC,MAAA,CACvBjB,kBAAkB,8DAAAiB,MAAA,CAGvBW,GAAG,0CAAAX,MAAA,CACSC,eAAe,sCAAAD,MAAA,CACtBjB,kBAAkB,yGAAAiB,MAAA,CAKjCF,QAAQ,umCAwBhB;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}