{"ast":null,"code":"import _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _assertThisInitialized from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport var DEFAULT_YIELD_EVERY_MS = 125;\n/**\r\n * Abstract base class used to build new callbacks.\r\n *\r\n * The `logs` dictionary that callback methods take as argument will contain\r\n * keys for quantities relevant to the current batch or epoch.\r\n *\r\n * Currently, the `.fit()` method of the `Sequential` model class\r\n * will include the following quantities in the `logs` that\r\n * it passes to its callbacks:\r\n *\r\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\r\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\r\n *   accuracy monitoring are enabled).\r\n * onBatchBegin: Logs include `size`, the number of samples in the current\r\n *   batch.\r\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\r\n *   is enabled).\r\n */\nexport var BaseCallback = /*#__PURE__*/function () {\n  function BaseCallback() {\n    _classCallCheck(this, BaseCallback);\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n  _createClass(BaseCallback, [{\n    key: \"setParams\",\n    value: function setParams(params) {\n      this.params = params;\n    }\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(epoch, logs) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function onEpochBegin(_x, _x2) {\n        return _onEpochBegin.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(epoch, logs) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function onEpochEnd(_x3, _x4) {\n        return _onEpochEnd.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(batch, logs) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function onBatchBegin(_x5, _x6) {\n        return _onBatchBegin.apply(this, arguments);\n      }\n      return onBatchBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(batch, logs) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function onBatchEnd(_x7, _x8) {\n        return _onBatchEnd.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(logs) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      function onTrainBegin(_x9) {\n        return _onTrainBegin.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(logs) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function onTrainEnd(_x10) {\n        return _onTrainEnd.apply(this, arguments);\n      }\n      return onTrainEnd;\n    }() // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {\n      // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n  }]);\n  return BaseCallback;\n}();\n/**\r\n * Container abstracting a list of callbacks.\r\n */\nexport var CallbackList = /*#__PURE__*/function () {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n  /**\r\n   * Constructor of CallbackList.\r\n   * @param callbacks Array of `Callback` instances.\r\n   * @param queueLength Queue length for keeping running statistics over\r\n   *   callback execution time.\r\n   */\n  function CallbackList(callbacks) {\n    var queueLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    _classCallCheck(this, CallbackList);\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n  _createClass(CallbackList, [{\n    key: \"append\",\n    value: function append(callback) {\n      this.callbacks.push(callback);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(params) {\n      var _iterator = _createForOfIteratorHelper(this.callbacks),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var callback = _step.value;\n          callback.setParams(params);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {\n      var _iterator2 = _createForOfIteratorHelper(this.callbacks),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var callback = _step2.value;\n          callback.setModel(model);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\r\n     * Called at the start of an epoch.\r\n     * @param epoch Index of epoch.\r\n     * @param logs Dictionary of logs.\r\n     */\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(epoch, logs) {\n        var _iterator3, _step3, callback;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator3 = _createForOfIteratorHelper(this.callbacks);\n              _context7.prev = 2;\n              _iterator3.s();\n            case 4:\n              if ((_step3 = _iterator3.n()).done) {\n                _context7.next = 10;\n                break;\n              }\n              callback = _step3.value;\n              _context7.next = 8;\n              return callback.onEpochBegin(epoch, logs);\n            case 8:\n              _context7.next = 4;\n              break;\n            case 10:\n              _context7.next = 15;\n              break;\n            case 12:\n              _context7.prev = 12;\n              _context7.t0 = _context7[\"catch\"](2);\n              _iterator3.e(_context7.t0);\n            case 15:\n              _context7.prev = 15;\n              _iterator3.f();\n              return _context7.finish(15);\n            case 18:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 12, 15, 18]]);\n      }));\n      function onEpochBegin(_x11, _x12) {\n        return _onEpochBegin2.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n    /**\r\n     * Called at the end of an epoch.\r\n     * @param epoch Index of epoch.\r\n     * @param logs Dictionary of logs.\r\n     */\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(epoch, logs) {\n        var _iterator4, _step4, callback;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator4 = _createForOfIteratorHelper(this.callbacks);\n              _context8.prev = 2;\n              _iterator4.s();\n            case 4:\n              if ((_step4 = _iterator4.n()).done) {\n                _context8.next = 10;\n                break;\n              }\n              callback = _step4.value;\n              _context8.next = 8;\n              return callback.onEpochEnd(epoch, logs);\n            case 8:\n              _context8.next = 4;\n              break;\n            case 10:\n              _context8.next = 15;\n              break;\n            case 12:\n              _context8.prev = 12;\n              _context8.t0 = _context8[\"catch\"](2);\n              _iterator4.e(_context8.t0);\n            case 15:\n              _context8.prev = 15;\n              _iterator4.f();\n              return _context8.finish(15);\n            case 18:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 12, 15, 18]]);\n      }));\n      function onEpochEnd(_x13, _x14) {\n        return _onEpochEnd2.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n    /**\r\n     * Called  right before processing a batch.\r\n     * @param batch Index of batch within the current epoch.\r\n     * @param logs Dictionary of logs.\r\n     */\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(batch, logs) {\n        var _iterator5, _step5, callback;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator5 = _createForOfIteratorHelper(this.callbacks);\n              _context9.prev = 2;\n              _iterator5.s();\n            case 4:\n              if ((_step5 = _iterator5.n()).done) {\n                _context9.next = 10;\n                break;\n              }\n              callback = _step5.value;\n              _context9.next = 8;\n              return callback.onBatchBegin(batch, logs);\n            case 8:\n              _context9.next = 4;\n              break;\n            case 10:\n              _context9.next = 15;\n              break;\n            case 12:\n              _context9.prev = 12;\n              _context9.t0 = _context9[\"catch\"](2);\n              _iterator5.e(_context9.t0);\n            case 15:\n              _context9.prev = 15;\n              _iterator5.f();\n              return _context9.finish(15);\n            case 18:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[2, 12, 15, 18]]);\n      }));\n      function onBatchBegin(_x15, _x16) {\n        return _onBatchBegin2.apply(this, arguments);\n      }\n      return onBatchBegin;\n    }()\n    /**\r\n     * Called at the end of a batch.\r\n     * @param batch Index of batch within the current epoch.\r\n     * @param logs Dictionary of logs.\r\n     */\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(batch, logs) {\n        var _iterator6, _step6, callback;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator6 = _createForOfIteratorHelper(this.callbacks);\n              _context10.prev = 2;\n              _iterator6.s();\n            case 4:\n              if ((_step6 = _iterator6.n()).done) {\n                _context10.next = 10;\n                break;\n              }\n              callback = _step6.value;\n              _context10.next = 8;\n              return callback.onBatchEnd(batch, logs);\n            case 8:\n              _context10.next = 4;\n              break;\n            case 10:\n              _context10.next = 15;\n              break;\n            case 12:\n              _context10.prev = 12;\n              _context10.t0 = _context10[\"catch\"](2);\n              _iterator6.e(_context10.t0);\n            case 15:\n              _context10.prev = 15;\n              _iterator6.f();\n              return _context10.finish(15);\n            case 18:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[2, 12, 15, 18]]);\n      }));\n      function onBatchEnd(_x17, _x18) {\n        return _onBatchEnd2.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n    /**\r\n     * Called at the beginning of training.\r\n     * @param logs Dictionary of logs.\r\n     */\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(logs) {\n        var _iterator7, _step7, callback;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator7 = _createForOfIteratorHelper(this.callbacks);\n              _context11.prev = 2;\n              _iterator7.s();\n            case 4:\n              if ((_step7 = _iterator7.n()).done) {\n                _context11.next = 10;\n                break;\n              }\n              callback = _step7.value;\n              _context11.next = 8;\n              return callback.onTrainBegin(logs);\n            case 8:\n              _context11.next = 4;\n              break;\n            case 10:\n              _context11.next = 15;\n              break;\n            case 12:\n              _context11.prev = 12;\n              _context11.t0 = _context11[\"catch\"](2);\n              _iterator7.e(_context11.t0);\n            case 15:\n              _context11.prev = 15;\n              _iterator7.f();\n              return _context11.finish(15);\n            case 18:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[2, 12, 15, 18]]);\n      }));\n      function onTrainBegin(_x19) {\n        return _onTrainBegin2.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n    /**\r\n     * Called at the end of training.\r\n     * @param logs Dictionary of logs.\r\n     */\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(logs) {\n        var _iterator8, _step8, callback;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator8 = _createForOfIteratorHelper(this.callbacks);\n              _context12.prev = 2;\n              _iterator8.s();\n            case 4:\n              if ((_step8 = _iterator8.n()).done) {\n                _context12.next = 10;\n                break;\n              }\n              callback = _step8.value;\n              _context12.next = 8;\n              return callback.onTrainEnd(logs);\n            case 8:\n              _context12.next = 4;\n              break;\n            case 10:\n              _context12.next = 15;\n              break;\n            case 12:\n              _context12.prev = 12;\n              _context12.t0 = _context12[\"catch\"](2);\n              _iterator8.e(_context12.t0);\n            case 15:\n              _context12.prev = 15;\n              _iterator8.f();\n              return _context12.finish(15);\n            case 18:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this, [[2, 12, 15, 18]]);\n      }));\n      function onTrainEnd(_x20) {\n        return _onTrainEnd2.apply(this, arguments);\n      }\n      return onTrainEnd;\n    }()\n  }]);\n  return CallbackList;\n}();\n/**\r\n * Callback that accumulates epoch averages of metrics.\r\n *\r\n * This callback is automatically applied to every LayersModel.\r\n */\nexport var BaseLogger = /*#__PURE__*/function (_BaseCallback) {\n  _inherits(BaseLogger, _BaseCallback);\n  var _super = _createSuper(BaseLogger);\n  function BaseLogger() {\n    _classCallCheck(this, BaseLogger);\n    return _super.call(this);\n  }\n  _createClass(BaseLogger, [{\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(epoch) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              this.seen = 0;\n              this.totals = {};\n            case 2:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function onEpochBegin(_x21) {\n        return _onEpochBegin3.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(batch, logs) {\n        var _this = this;\n        var batchSize, _loop, key;\n        return _regeneratorRuntime().wrap(function _callee14$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              batchSize = logs['size'] == null ? 0 : logs['size'];\n              this.seen += batchSize;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(key) {\n                var value, oldTotalsToDispose, total;\n                return _regeneratorRuntime().wrap(function _loop$(_context14) {\n                  while (1) switch (_context14.prev = _context14.next) {\n                    case 0:\n                      value = logs[key];\n                      if (typeof value === 'number') {\n                        if (!_this.totals.hasOwnProperty(key)) {\n                          _this.totals[key] = 0;\n                        }\n                        _this.totals[key] = _this.totals[key] + value * batchSize;\n                      } else {\n                        if (key in _this.totals) {\n                          oldTotalsToDispose = _this.totals[key];\n                        } else {\n                          _this.totals[key] = 0;\n                        }\n                        total = tidy(function () {\n                          return add(_this.totals[key], mul(value, batchSize));\n                        });\n                        _this.totals[key] = total;\n                        if (oldTotalsToDispose != null) {\n                          oldTotalsToDispose.dispose();\n                        }\n                      }\n                    case 2:\n                    case \"end\":\n                      return _context14.stop();\n                  }\n                }, _loop);\n              });\n              _context15.t0 = _regeneratorRuntime().keys(logs);\n            case 5:\n              if ((_context15.t1 = _context15.t0()).done) {\n                _context15.next = 10;\n                break;\n              }\n              key = _context15.t1.value;\n              return _context15.delegateYield(_loop(key), \"t2\", 8);\n            case 8:\n              _context15.next = 5;\n              break;\n            case 10:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee14, this);\n      }));\n      function onBatchEnd(_x22, _x23) {\n        return _onBatchEnd3.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(epoch, logs) {\n        var _this2 = this;\n        var _iterator9, _step9, _loop2, _ret;\n        return _regeneratorRuntime().wrap(function _callee15$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!(logs != null)) {\n                _context17.next = 20;\n                break;\n              }\n              _iterator9 = _createForOfIteratorHelper(this.params['metrics']);\n              _context17.prev = 2;\n              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n                var key;\n                return _regeneratorRuntime().wrap(function _loop2$(_context16) {\n                  while (1) switch (_context16.prev = _context16.next) {\n                    case 0:\n                      key = _step9.value;\n                      if (!(_this2.totals[key] == null)) {\n                        _context16.next = 3;\n                        break;\n                      }\n                      return _context16.abrupt(\"return\", \"continue\");\n                    case 3:\n                      if (typeof _this2.totals[key] === 'number') {\n                        logs[key] = _this2.totals[key] / _this2.seen;\n                      } else {\n                        tidy(function () {\n                          var log = mul(div(1, _this2.seen), _this2.totals[key]);\n                          logs[key] = log;\n                          _this2.totals[key].dispose();\n                          keep(logs[key]);\n                        });\n                      }\n                    case 4:\n                    case \"end\":\n                      return _context16.stop();\n                  }\n                }, _loop2);\n              });\n              _iterator9.s();\n            case 5:\n              if ((_step9 = _iterator9.n()).done) {\n                _context17.next = 12;\n                break;\n              }\n              return _context17.delegateYield(_loop2(), \"t0\", 7);\n            case 7:\n              _ret = _context17.t0;\n              if (!(_ret === \"continue\")) {\n                _context17.next = 10;\n                break;\n              }\n              return _context17.abrupt(\"continue\", 10);\n            case 10:\n              _context17.next = 5;\n              break;\n            case 12:\n              _context17.next = 17;\n              break;\n            case 14:\n              _context17.prev = 14;\n              _context17.t1 = _context17[\"catch\"](2);\n              _iterator9.e(_context17.t1);\n            case 17:\n              _context17.prev = 17;\n              _iterator9.f();\n              return _context17.finish(17);\n            case 20:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee15, this, [[2, 14, 17, 20]]);\n      }));\n      function onEpochEnd(_x24, _x25) {\n        return _onEpochEnd3.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n  }]);\n  return BaseLogger;\n}(BaseCallback);\n/**\r\n * Callback that records events into a `History` object. This callback is\r\n * automatically applied to every TF.js Layers model. The `History` object\r\n * gets returned by the `fit` method of models.\r\n */\nexport var History = /*#__PURE__*/function (_BaseCallback2) {\n  _inherits(History, _BaseCallback2);\n  var _super2 = _createSuper(History);\n  function History() {\n    _classCallCheck(this, History);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(History, [{\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(logs) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              this.epoch = [];\n              this.history = {};\n            case 2:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee16, this);\n      }));\n      function onTrainBegin(_x26) {\n        return _onTrainBegin3.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(epoch, logs) {\n        var key;\n        return _regeneratorRuntime().wrap(function _callee17$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              this.epoch.push(epoch);\n              for (key in logs) {\n                if (this.history[key] == null) {\n                  this.history[key] = [];\n                }\n                this.history[key].push(logs[key]);\n              }\n            case 3:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee17, this);\n      }));\n      function onEpochEnd(_x27, _x28) {\n        return _onEpochEnd4.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n    /**\r\n     * Await the values of all losses and metrics.\r\n     */\n  }, {\n    key: \"syncData\",\n    value: function () {\n      var _syncData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var promises, keys, indices, key, valueArray, i, valueScalar, values, n, tensorToDispose;\n        return _regeneratorRuntime().wrap(function _callee18$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              promises = [];\n              keys = [];\n              indices = [];\n              for (key in this.history) {\n                valueArray = this.history[key];\n                for (i = 0; i < valueArray.length; ++i) {\n                  if (typeof valueArray[i] !== 'number') {\n                    valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                  }\n                }\n              }\n              _context20.next = 6;\n              return Promise.all(promises);\n            case 6:\n              values = _context20.sent;\n              for (n = 0; n < values.length; ++n) {\n                tensorToDispose = this.history[keys[n]][indices[n]];\n                tensorToDispose.dispose();\n                this.history[keys[n]][indices[n]] = values[n][0];\n              }\n            case 8:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee18, this);\n      }));\n      function syncData() {\n        return _syncData.apply(this, arguments);\n      }\n      return syncData;\n    }()\n  }]);\n  return History;\n}(BaseCallback);\n/**\r\n * Custom callback for training.\r\n */\nexport var CustomCallback = /*#__PURE__*/function (_BaseCallback3) {\n  _inherits(CustomCallback, _BaseCallback3);\n  var _super3 = _createSuper(CustomCallback);\n  function CustomCallback(args, yieldEvery) {\n    var _this3;\n    _classCallCheck(this, CustomCallback);\n    _this3 = _super3.call(this);\n    _this3.currentEpoch = 0;\n    _this3.nowFunc = args.nowFunc;\n    _this3.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    _this3.yieldEvery = yieldEvery || 'auto';\n    if (_this3.yieldEvery === 'auto') {\n      _this3.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (_this3.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(_this3.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      _this3.maybeWait = generic_utils.debounce(_this3.maybeWait.bind(_assertThisInitialized(_this3)), _this3.yieldEvery, _this3.nowFunc);\n    }\n    _this3.trainBegin = args.onTrainBegin;\n    _this3.trainEnd = args.onTrainEnd;\n    _this3.epochBegin = args.onEpochBegin;\n    _this3.epochEnd = args.onEpochEnd;\n    _this3.batchBegin = args.onBatchBegin;\n    _this3.batchEnd = args.onBatchEnd;\n    _this3.yield = args.onYield;\n    return _this3;\n  }\n  _createClass(CustomCallback, [{\n    key: \"maybeWait\",\n    value: function () {\n      var _maybeWait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(epoch, batch, logs) {\n        var ps;\n        return _regeneratorRuntime().wrap(function _callee19$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              ps = [];\n              if (!(this.yield != null)) {\n                _context21.next = 5;\n                break;\n              }\n              _context21.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              ps.push(this.yield(epoch, batch, logs));\n            case 5:\n              ps.push(this.nextFrameFunc());\n              _context21.next = 8;\n              return Promise.all(ps);\n            case 8:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee19, this);\n      }));\n      function maybeWait(_x29, _x30, _x31) {\n        return _maybeWait.apply(this, arguments);\n      }\n      return maybeWait;\n    }()\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(epoch, logs) {\n        return _regeneratorRuntime().wrap(function _callee20$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              this.currentEpoch = epoch;\n              if (!(this.epochBegin != null)) {\n                _context22.next = 6;\n                break;\n              }\n              _context22.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              _context22.next = 6;\n              return this.epochBegin(epoch, logs);\n            case 6:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee20, this);\n      }));\n      function onEpochBegin(_x32, _x33) {\n        return _onEpochBegin4.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(epoch, logs) {\n        var ps;\n        return _regeneratorRuntime().wrap(function _callee21$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              ps = [];\n              if (!(this.epochEnd != null)) {\n                _context23.next = 5;\n                break;\n              }\n              _context23.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              ps.push(this.epochEnd(epoch, logs));\n            case 5:\n              if (this.yieldEvery === 'epoch') {\n                ps.push(this.nextFrameFunc());\n              }\n              _context23.next = 8;\n              return Promise.all(ps);\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee21, this);\n      }));\n      function onEpochEnd(_x34, _x35) {\n        return _onEpochEnd5.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(batch, logs) {\n        return _regeneratorRuntime().wrap(function _callee22$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              if (!(this.batchBegin != null)) {\n                _context24.next = 5;\n                break;\n              }\n              _context24.next = 3;\n              return resolveScalarsInLogs(logs);\n            case 3:\n              _context24.next = 5;\n              return this.batchBegin(batch, logs);\n            case 5:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee22, this);\n      }));\n      function onBatchBegin(_x36, _x37) {\n        return _onBatchBegin3.apply(this, arguments);\n      }\n      return onBatchBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(batch, logs) {\n        var ps;\n        return _regeneratorRuntime().wrap(function _callee23$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              ps = [];\n              if (!(this.batchEnd != null)) {\n                _context25.next = 5;\n                break;\n              }\n              _context25.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              ps.push(this.batchEnd(batch, logs));\n            case 5:\n              if (this.yieldEvery === 'batch') {\n                ps.push(this.nextFrameFunc());\n              } else if (util.isNumber(this.yieldEvery)) {\n                ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n              }\n              _context25.next = 8;\n              return Promise.all(ps);\n            case 8:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee23, this);\n      }));\n      function onBatchEnd(_x38, _x39) {\n        return _onBatchEnd4.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(logs) {\n        return _regeneratorRuntime().wrap(function _callee24$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              if (!(this.trainBegin != null)) {\n                _context26.next = 5;\n                break;\n              }\n              _context26.next = 3;\n              return resolveScalarsInLogs(logs);\n            case 3:\n              _context26.next = 5;\n              return this.trainBegin(logs);\n            case 5:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee24, this);\n      }));\n      function onTrainBegin(_x40) {\n        return _onTrainBegin4.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(logs) {\n        return _regeneratorRuntime().wrap(function _callee25$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              if (!(this.trainEnd != null)) {\n                _context27.next = 5;\n                break;\n              }\n              _context27.next = 3;\n              return resolveScalarsInLogs(logs);\n            case 3:\n              _context27.next = 5;\n              return this.trainEnd(logs);\n            case 5:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee25, this);\n      }));\n      function onTrainEnd(_x41) {\n        return _onTrainEnd3.apply(this, arguments);\n      }\n      return onTrainEnd;\n    }()\n  }]);\n  return CustomCallback;\n}(BaseCallback);\n/**\r\n * Standardize callbacks or configurations of them to an Array of callbacks.\r\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  }\n  // Convert custom callback configs to custom callback objects.\n  var callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(function (callbackConfig) {\n    return new CustomCallback(callbackConfig, yieldEvery);\n  });\n}\n/**\r\n * A global registry for callback constructors to be used during\r\n * LayersModel.fit().\r\n */\nexport var CallbackConstructorRegistry = /*#__PURE__*/function () {\n  /**\r\n   * Blocks public access to constructor.\r\n   */\n  function CallbackConstructorRegistry() {\n    _classCallCheck(this, CallbackConstructorRegistry);\n  }\n  /**\r\n   * Register a tf.LayersModel.fit() callback constructor.\r\n   *\r\n   * The registered callback constructor will be used to instantiate\r\n   * callbacks for every tf.LayersModel.fit() call afterwards.\r\n   *\r\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\r\n   *   is to be reigstered.\r\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\r\n   * @throws Error, if the same callbackConstructor has been registered before,\r\n   *   either at the same or a different `verbosityLevel`.\r\n   */\n  _createClass(CallbackConstructorRegistry, null, [{\n    key: \"registerCallbackConstructor\",\n    value: function registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n      util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), function () {\n        return \"Verbosity level is expected to be an integer >= 0, \" + \"but got \".concat(verbosityLevel);\n      });\n      CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n      if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n        CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n      }\n      CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n  }, {\n    key: \"checkForDuplicate\",\n    value: function checkForDuplicate(callbackConstructor) {\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var constructors = CallbackConstructorRegistry.constructors[+levelName];\n        constructors.forEach(function (ctor) {\n          if (ctor === callbackConstructor) {\n            throw new ValueError('Duplicate callback constructor.');\n          }\n        });\n      }\n    }\n    /**\r\n     * Clear all registered callback constructors.\r\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      CallbackConstructorRegistry.constructors = {};\n    }\n    /**\r\n     * Create callbacks using the registered callback constructors.\r\n     *\r\n     * Given `verbosityLevel`, all constructors registered at that level or above\r\n     * will be called and the instantiated callbacks will be used.\r\n     *\r\n     * @param verbosityLevel: Level of verbosity.\r\n     */\n  }, {\n    key: \"createCallbacks\",\n    value: function createCallbacks(verbosityLevel) {\n      var constructors = [];\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var level = +levelName;\n        if (verbosityLevel >= level) {\n          constructors.push.apply(constructors, _toConsumableArray(CallbackConstructorRegistry.constructors[level]));\n        }\n      }\n      return constructors.map(function (ctor) {\n        return new ctor();\n      });\n    }\n  }]);\n  return CallbackConstructorRegistry;\n}();\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  var history = new History();\n  var actualCallbacks = [new BaseLogger()].concat(_toConsumableArray(CallbackConstructorRegistry.createCallbacks(verbose)));\n  if (callbacks != null) {\n    actualCallbacks.push.apply(actualCallbacks, _toConsumableArray(callbacks));\n  }\n  actualCallbacks.push(history);\n  var callbackList = new CallbackList(actualCallbacks);\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n  callbackList.setParams({\n    epochs: epochs,\n    initialEpoch: initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize: batchSize,\n    verbose: verbose,\n    doValidation: doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList: callbackList,\n    history: history\n  };\n}","map":{"version":3,"names":["add","div","keep","mul","nextFrame","tidy","util","ValueError","resolveScalarsInLogs","generic_utils","ModelLoggingVerbosity","DEFAULT_YIELD_EVERY_MS","BaseCallback","_classCallCheck","validationData","_createClass","key","value","setParams","params","_onEpochBegin","_asyncToGenerator","_regeneratorRuntime","mark","_callee","epoch","logs","wrap","_callee$","_context","prev","next","stop","onEpochBegin","_x","_x2","apply","arguments","_onEpochEnd","_callee2","_callee2$","_context2","onEpochEnd","_x3","_x4","_onBatchBegin","_callee3","batch","_callee3$","_context3","onBatchBegin","_x5","_x6","_onBatchEnd","_callee4","_callee4$","_context4","onBatchEnd","_x7","_x8","_onTrainBegin","_callee5","_callee5$","_context5","onTrainBegin","_x9","_onTrainEnd","_callee6","_callee6$","_context6","onTrainEnd","_x10","setModel","model","CallbackList","callbacks","queueLength","length","undefined","append","callback","push","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","_iterator2","_step2","_onEpochBegin2","_callee7","_iterator3","_step3","_callee7$","_context7","t0","finish","_x11","_x12","_onEpochEnd2","_callee8","_iterator4","_step4","_callee8$","_context8","_x13","_x14","_onBatchBegin2","_callee9","_iterator5","_step5","_callee9$","_context9","_x15","_x16","_onBatchEnd2","_callee10","_iterator6","_step6","_callee10$","_context10","_x17","_x18","_onTrainBegin2","_callee11","_iterator7","_step7","_callee11$","_context11","_x19","_onTrainEnd2","_callee12","_iterator8","_step8","_callee12$","_context12","_x20","BaseLogger","_BaseCallback","_inherits","_super","_createSuper","call","_onEpochBegin3","_callee13","_callee13$","_context13","seen","totals","_x21","_onBatchEnd3","_callee14","_this","batchSize","_loop","_callee14$","_context15","oldTotalsToDispose","total","_loop$","_context14","hasOwnProperty","dispose","keys","t1","delegateYield","_x22","_x23","_onEpochEnd3","_callee15","_this2","_iterator9","_step9","_loop2","_ret","_callee15$","_context17","_loop2$","_context16","abrupt","log","_x24","_x25","History","_BaseCallback2","_super2","_onTrainBegin3","_callee16","_callee16$","_context18","history","_x26","_onEpochEnd4","_callee17","_callee17$","_context19","_x27","_x28","_syncData","_callee18","promises","indices","valueArray","i","valueScalar","values","tensorToDispose","_callee18$","_context20","data","Promise","all","sent","syncData","CustomCallback","_BaseCallback3","_super3","args","yieldEvery","_this3","currentEpoch","nowFunc","nextFrameFunc","onYield","Error","isNumber","maybeWait","debounce","bind","_assertThisInitialized","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","_maybeWait","_callee19","ps","_callee19$","_context21","_x29","_x30","_x31","_onEpochBegin4","_callee20","_callee20$","_context22","_x32","_x33","_onEpochEnd5","_callee21","_callee21$","_context23","_x34","_x35","_onBatchBegin3","_callee22","_callee22$","_context24","_x36","_x37","_onBatchEnd4","_callee23","_callee23$","_context25","_x38","_x39","_onTrainBegin4","_callee24","_callee24$","_context26","_x40","_onTrainEnd3","_callee25","_callee25$","_context27","_x41","standardizeCallbacks","Array","isArray","callbackConfigs","toList","map","callbackConfig","CallbackConstructorRegistry","registerCallbackConstructor","verbosityLevel","callbackConstructor","assert","Number","isInteger","concat","checkForDuplicate","constructors","levelName","forEach","ctor","clear","createCallbacks","level","_toConsumableArray","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","callbackList","samples","steps","metrics"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-layers\\src\\base_callbacks.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\n\nimport {add, div, keep, mul, nextFrame, Scalar, Tensor, tidy, util} from '@tensorflow/tfjs-core';\n\nimport {Container} from './engine/container';\nimport {ValueError} from './errors';\nimport {Logs, resolveScalarsInLogs, UnresolvedLogs} from './logs';\nimport * as generic_utils from './utils/generic_utils';\n\n/** Verbosity logging level when fitting a model. */\nexport enum ModelLoggingVerbosity {\n  SILENT = 0,\n  VERBOSE = 1\n}\n\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n\nexport type Params = {\n  [key: string]: number|string|boolean|number[]|string[]|boolean[];\n};\n\nexport type YieldEveryOptions = 'auto'|'batch'|'epoch'|'never'|number;\n\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport abstract class BaseCallback {\n  // TODO(michaelterry): This type is a best guess.\n  validationData: Tensor|Tensor[] = null;\n  /**\n   * Training parameters (eg. verbosity, batch size, number of epochs...).\n   */\n  params: Params;\n\n  setParams(params: Params): void {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {}\n\n  async onTrainBegin(logs?: UnresolvedLogs) {}\n\n  async onTrainEnd(logs?: UnresolvedLogs) {}\n\n  // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n  setModel(model: Container): void {\n    // Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n}\n\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n  callbacks: BaseCallback[];\n  queueLength: number;\n\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks?: BaseCallback[], queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback: BaseCallback): void {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params: Params): void {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model: Container): void {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainEnd(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n}\n\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n  private seen: number;\n  private totals: UnresolvedLogs;\n\n  constructor() {\n    super();\n  }\n\n  override async onEpochBegin(epoch: number) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  override async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    const batchSize = logs['size'] == null ? 0 : logs['size'] as number;\n    this.seen += batchSize;\n    for (const key in logs) {\n      const value = logs[key];\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n        this.totals[key] = this.totals[key] as number + value * batchSize;\n      } else {\n        let oldTotalsToDispose: Scalar;\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key] as Scalar;\n        } else {\n          this.totals[key] = 0;\n        }\n        const total: Scalar =\n            tidy(() => add((this.totals[key]), mul(value, batchSize)));\n        this.totals[key] = total;\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs != null) {\n      for (const key of this.params['metrics'] as string[]) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] as number / this.seen;\n        } else {\n          tidy(() => {\n            const log: Scalar = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            (this.totals[key] as Tensor).dispose();\n            keep(logs[key] as Scalar);\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n  epoch: number[];\n  history: {[key: string]: Array<number|Tensor>};\n\n  override async onTrainBegin(logs?: UnresolvedLogs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    this.epoch.push(epoch);\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n      this.history[key].push(logs[key]);\n    }\n  }\n\n  /**\n   * Await the values of all losses and metrics.\n   */\n  async syncData() {\n    const promises: Array<Promise<Float32Array|Int32Array|Uint8Array>> = [];\n    const keys: string[] = [];\n    const indices: number[] = [];\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i] as Tensor;\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n    const values = await Promise.all(promises);\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]] as Tensor;\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n}\n\nexport interface CustomCallbackArgs {\n  onTrainBegin?: (logs?: Logs) => void | Promise<void>;\n  onTrainEnd?: (logs?: Logs) => void | Promise<void>;\n  onEpochBegin?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onEpochEnd?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onBatchBegin?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onBatchEnd?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onYield?: (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n  // Used for test DI mocking.\n  nowFunc?: Function;\n  nextFrameFunc?: Function;\n}\n\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n  protected readonly trainBegin: (logs?: Logs) => void | Promise<void>;\n  protected readonly trainEnd: (logs?: Logs) => void | Promise<void>;\n  protected readonly epochBegin:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly epochEnd:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchBegin:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchEnd:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly yield:\n      (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n\n  private yieldEvery: YieldEveryOptions;\n  private currentEpoch = 0;\n  public nowFunc: Function;\n  public nextFrameFunc: Function;\n\n  constructor(args: CustomCallbackArgs, yieldEvery?: YieldEveryOptions) {\n    super();\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error(\n          'yieldEvery is `never` but you provided an `onYield` callback. ' +\n          'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(\n          this.maybeWait.bind(this), this.yieldEvery as number, this.nowFunc);\n    }\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch: number, batch: number, logs: UnresolvedLogs) {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs as Logs));\n    }\n    ps.push(this.nextFrameFunc());\n    await Promise.all(ps);\n  }\n\n  override async onEpochBegin(epoch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    this.currentEpoch = epoch;\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs as Logs);\n    }\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs as Logs));\n    }\n    if (this.yieldEvery === 'epoch') {\n      ps.push(this.nextFrameFunc());\n    }\n    await Promise.all(ps);\n  }\n\n  override async onBatchBegin(batch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs as Logs);\n    }\n  }\n\n  override async onBatchEnd(batch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs as Logs));\n    }\n    if (this.yieldEvery === 'batch') {\n      ps.push(this.nextFrameFunc());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n    await Promise.all(ps);\n  }\n\n  override async onTrainBegin(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs as Logs);\n    }\n  }\n\n  override async onTrainEnd(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs as Logs);\n    }\n  }\n}\n\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(\n    callbacks: BaseCallback|BaseCallback[]|CustomCallbackArgs|\n    CustomCallbackArgs[],\n    yieldEvery: YieldEveryOptions): BaseCallback[] {\n  if (callbacks == null) {\n    callbacks = {} as BaseCallback;\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks as BaseCallback[];\n  }\n  // Convert custom callback configs to custom callback objects.\n  const callbackConfigs =\n      generic_utils.toList(callbacks) as CustomCallbackArgs[];\n  return callbackConfigs.map(\n      callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n\nexport declare type BaseCallbackConstructor = {\n  new (): BaseCallback\n};\n\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n  private static constructors:\n      {[verbosityLevel: number]: BaseCallbackConstructor[]} = {};\n\n  /**\n   * Blocks public access to constructor.\n   */\n  private constructor() {}\n\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  static registerCallbackConstructor(\n      verbosityLevel: number, callbackConstructor: BaseCallbackConstructor) {\n    util.assert(\n        verbosityLevel >= 0 && Number.isInteger(verbosityLevel),\n        () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(\n        callbackConstructor);\n  }\n\n  private static checkForDuplicate(callbackConstructor:\n                                       BaseCallbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n\n  /**\n   * Clear all registered callback constructors.\n   */\n  protected static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n  static createCallbacks(verbosityLevel: number): BaseCallback[] {\n    const constructors: BaseCallbackConstructor[] = [];\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n    return constructors.map(ctor => new ctor());\n  }\n}\n\nexport function configureCallbacks(\n    callbacks: BaseCallback[], verbose: ModelLoggingVerbosity, epochs: number,\n    initialEpoch: number, numTrainSamples: number, stepsPerEpoch: number,\n    batchSize: number, doValidation: boolean,\n    callbackMetrics: string[]): {callbackList: CallbackList, history: History} {\n  const history = new History();\n  const actualCallbacks: BaseCallback[] = [\n    new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n  ];\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks);\n\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics,\n  });\n  return {callbackList, history};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}