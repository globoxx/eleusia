{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\r\n * @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n  var inputs = args.inputs,\n    attrs = args.attrs,\n    backend = args.backend;\n  var image = inputs.image,\n    transforms = inputs.transforms;\n  var interpolation = attrs.interpolation,\n    fillMode = attrs.fillMode,\n    fillValue = attrs.fillValue,\n    outputShape = attrs.outputShape;\n  var _image$shape = _slicedToArray(image.shape, 4),\n    batch = _image$shape[0],\n    imageHeight = _image$shape[1],\n    imageWidth = _image$shape[2],\n    numChannels = _image$shape[3];\n  var _ref = outputShape != null ? outputShape : [imageHeight, imageWidth],\n    _ref2 = _slicedToArray(_ref, 2),\n    outHeight = _ref2[0],\n    outWidth = _ref2[1];\n  var outShape = [batch, outHeight, outWidth, numChannels];\n  var inStrides = util.computeStrides(image.shape);\n  var batchInStride = inStrides[0];\n  var rowInStride = inStrides[1];\n  var colInStride = inStrides[2];\n  var outStrides = util.computeStrides(outShape);\n  var batchOutStride = outStrides[0];\n  var rowOutStride = outStrides[1];\n  var colOutStride = outStrides[2];\n  var outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n  outVals.fill(fillValue);\n  var imageVals = backend.data.get(image.dataId).values;\n  var transformVals = backend.data.get(transforms.dataId).values;\n  // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n  for (var b = 0; b < batch; ++b) {\n    var _transform = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);\n    for (var outY = 0; outY < outHeight; ++outY) {\n      for (var outX = 0; outX < outWidth; ++outX) {\n        for (var channel = 0; channel < numChannels; ++channel) {\n          var val = void 0;\n          var projection = _transform[6] * outX + _transform[7] * outY + 1;\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n          var inX = (_transform[0] * outX + _transform[1] * outY + _transform[2]) / projection;\n          var inY = (_transform[3] * outX + _transform[4] * outY + _transform[5]) / projection;\n          var x = mapCoord(inX, imageWidth, fillMode);\n          var y = mapCoord(inY, imageHeight, fillMode);\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n            case 'bilinear':\n              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n            default:\n              throw new Error(\"Error in Transform: Expect 'nearest' or \" + \"'bilinear', but got \".concat(interpolation));\n          }\n          var ind = b * batchOutStride + outY * rowOutStride + outX * colOutStride + channel;\n          outVals[ind] = val;\n        }\n      }\n    }\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n  var dataId = backend.write(outVals, outShape, image.dtype);\n  return {\n    dataId: dataId,\n    shape: image.shape,\n    dtype: image.dtype\n  };\n}\nexport var transformConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform\n};\nfunction mapCoord(outCoord, len, mode) {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\nfunction mapCoordReflect(outCoord, len) {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  var inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var sz2 = 2 * len;\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var _sz = 2 * len;\n      inCoord -= _sz * Math.trunc(inCoord / _sz);\n      if (inCoord >= len) {\n        inCoord = _sz - inCoord - 1;\n      }\n    }\n  }\n  // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordWrap(outCoord, len) {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  var inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var _sz2 = len - 1;\n      inCoord -= len * Math.trunc(inCoord / _sz2);\n    }\n  }\n  // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordConstant(outCoord, len) {\n  return outCoord;\n}\nfunction mapCoordNearest(outCoord, len) {\n  return util.clamp(0, outCoord, len - 1);\n}\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  var ind = batch * batchStride + y * rowStride + x * colStride + channel;\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  var $y = Math.round(y);\n  var $x = Math.round(x);\n  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  var yFloor = Math.floor(y);\n  var xFloor = Math.floor(x);\n  var yCeil = yFloor + 1;\n  var xCeil = xFloor + 1;\n  // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n  var valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);\n  // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n  var valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);\n  // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}","map":{"version":3,"names":["Transform","util","transform","args","inputs","attrs","backend","image","transforms","interpolation","fillMode","fillValue","outputShape","_image$shape","_slicedToArray","shape","batch","imageHeight","imageWidth","numChannels","_ref","_ref2","outHeight","outWidth","outShape","inStrides","computeStrides","batchInStride","rowInStride","colInStride","outStrides","batchOutStride","rowOutStride","colOutStride","outVals","getTypedArrayFromDType","dtype","sizeFromShape","fill","imageVals","data","get","dataId","values","transformVals","b","subarray","outY","outX","channel","val","projection","inX","inY","x","mapCoord","y","nearestInterpolation","bilinearInterpolation","Error","concat","ind","makeTensorInfo","write","transformConfig","kernelName","backendName","kernelFunc","outCoord","len","mode","mapCoordReflect","mapCoordWrap","mapCoordNearest","mapCoordConstant","inCoord","sz2","Math","trunc","clamp","sz","readWithFillValue","batchStride","rowStride","colStride","$y","round","$x","yFloor","floor","xFloor","yCeil","xCeil","valueYFloor","valueYCeil"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-cpu\\src\\kernels\\Transform.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, NumericDataType, TensorInfo, Transform, TransformAttrs, TransformInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function transform(args: {\n  inputs: TransformInputs,\n  attrs: TransformAttrs,\n  backend: MathBackendCPU\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {image, transforms} = inputs;\n  const {interpolation, fillMode, fillValue, outputShape} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] =\n      outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n\n  const inStrides = util.computeStrides(image.shape);\n  const batchInStride = inStrides[0];\n  const rowInStride = inStrides[1];\n  const colInStride = inStrides[2];\n\n  const outStrides = util.computeStrides(outShape);\n  const batchOutStride = outStrides[0];\n  const rowOutStride = outStrides[1];\n  const colOutStride = outStrides[2];\n\n  const outVals = util.getTypedArrayFromDType(\n      image.dtype as NumericDataType, util.sizeFromShape(outShape));\n\n  outVals.fill(fillValue);\n\n  const imageVals = backend.data.get(image.dataId).values as TypedArray;\n  const transformVals =\n      backend.data.get(transforms.dataId).values as TypedArray;\n\n  // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ?\n        transformVals :\n        transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX =\n              (transform[0] * outX + transform[1] * outY + transform[2]) /\n              projection;\n          const inY =\n              (transform[3] * outX + transform[4] * outY + transform[5]) /\n              projection;\n\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(\n                  imageVals, imageHeight, imageWidth, batchInStride,\n                  rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n            case 'bilinear':\n              val = bilinearInterpolation(\n                  imageVals, imageHeight, imageWidth, batchInStride,\n                  rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n            default:\n              throw new Error(\n                  `Error in Transform: Expect 'nearest' or ` +\n                  `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind =\n              b * batchOutStride + outY * rowOutStride +\n              outX * colOutStride + channel;\n\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {dataId, shape: image.shape, dtype: image.dtype};\n}\n\nexport const transformConfig: KernelConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform as unknown as KernelFunc\n};\n\nfunction mapCoord(\n    outCoord: number, len: number,\n    mode: 'constant'|'reflect'|'wrap'|'nearest') {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord: number, len: number): number {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  }\n  // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord: number, len: number): number {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  }\n  // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord: number, len: number): number {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord: number, len: number): number {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number): number {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number): number {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n\n  return readWithFillValue(\n      imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride,\n      batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1;\n  // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n  const valueYFloor =\n      (xCeil - x) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yFloor, xFloor, channel, fillValue) +\n      (x - xFloor) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yFloor, xCeil, channel, fillValue);\n  // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n  const valueYCeil =\n      (xCeil - x) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yCeil, xFloor, channel, fillValue) +\n      (x - xFloor) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yCeil, xCeil, channel, fillValue);\n  // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}