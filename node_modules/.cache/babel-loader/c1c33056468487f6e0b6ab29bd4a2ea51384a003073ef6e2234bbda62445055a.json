{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\r\n * @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { tensor1d } from '../tensor1d';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport { slice } from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n/**\r\n * Performs image binarization with corresponding threshold\r\n * (depends on the method)value, which creates a binary image from a grayscale.\r\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\r\n * where imageHeight and imageWidth must be positive.The image color\r\n * range should be [0, 255].\r\n * @param method Optional string from `'binary' | 'otsu'`\r\n * which specifies the method for thresholding. Defaults to 'binary'.\r\n * @param inverted Optional boolean whichspecifies\r\n * if colours should be inverted. Defaults to false.\r\n * @param threshValue Optional number which defines threshold value from 0 to 1.\r\n * Defaults to 0.5.\r\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\r\n * contains binarized image.\r\n */\nfunction threshold_(image) {\n  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';\n  var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var threshValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n  var $image = convertToTensor(image, 'image', 'threshold');\n  /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\r\n  Reference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n  var RED_INTENCITY_COEF = 0.2989;\n  var GREEN_INTENCITY_COEF = 0.5870;\n  var BLUE_INTENCITY_COEF = 0.1140;\n  var totalPixelsInImage = $image.shape[0] * $image.shape[1];\n  var $threshold = mul(tensor1d([threshValue]), 255);\n  var r, g, b, grayscale;\n  util.assert($image.rank === 3, function () {\n    return 'Error in threshold: image must be rank 3,' + \"but got rank \".concat($image.rank, \".\");\n  });\n  util.assert($image.shape[2] === 3 || $image.shape[2] === 1, function () {\n    return 'Error in threshold: ' + 'image color channel must be equal to 3 or 1' + \"but got \".concat($image.shape[2], \".\");\n  });\n  util.assert($image.dtype === 'int32' || $image.dtype === 'float32', function () {\n    return 'Error in dtype: image dtype must be int32 or float32,' + \"but got dtype \".concat($image.dtype, \".\");\n  });\n  util.assert(method === 'otsu' || method === 'binary', function () {\n    return \"Method must be binary or otsu, but was \".concat(method);\n  });\n  if ($image.shape[2] === 3) {\n    var _split = split($image, [1, 1, 1], -1);\n    var _split2 = _slicedToArray(_split, 3);\n    r = _split2[0];\n    g = _split2[1];\n    b = _split2[2];\n    var $r = mul(r, RED_INTENCITY_COEF);\n    var $g = mul(g, GREEN_INTENCITY_COEF);\n    var $b = mul(b, BLUE_INTENCITY_COEF);\n    grayscale = add(add($r, $g), $b);\n  } else {\n    grayscale = image;\n  }\n  if (method === 'otsu') {\n    var $histogram = bincount(cast(round(grayscale), 'int32'), tensor([]), 256);\n    $threshold = otsu($histogram, totalPixelsInImage);\n  }\n  var invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n  var result = cast(mul(invCondition, 255), 'int32');\n  return result;\n}\nfunction otsu(histogram, total) {\n  var bestThresh = tensor1d([-1]);\n  var bestInBetVar = tensor1d([0]);\n  var cInBetVar = tensor1d([0]);\n  var classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;\n  for (var index = 0; index < histogram.size - 1; index++) {\n    classFirst = slice(histogram, 0, index + 1);\n    classSecond = slice(histogram, index + 1);\n    weightForeground = div(sum(classFirst), total);\n    weightBack = div(sum(classSecond), total);\n    var meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n    meanFirst = div(meanFirstDivA, sum(classFirst));\n    var meanSecFill = fill(classSecond.shape, classFirst.size);\n    var meanSecAdd = add(range(0, classSecond.size), meanSecFill);\n    var meanSecMul = mul(classSecond, meanSecAdd);\n    meanSec = div(sum(meanSecMul), sum(classSecond));\n    var cInBetVarSubA = sub(meanFirst, meanSec);\n    var cInBetVarSubB = sub(meanFirst, meanSec);\n    var cInBetVarMul = mul(weightForeground, weightBack);\n    cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);\n    var condition = greater(cInBetVar, bestInBetVar);\n    bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n    bestThresh = where(condition, tensor1d([index]), bestThresh);\n  }\n  return bestThresh;\n}\nexport var threshold = /* @__PURE__ */op({\n  threshold_: threshold_\n});","map":{"version":3,"names":["tensor1d","op","cast","split","bincount","lessEqual","greater","sum","add","mul","div","sub","round","where","fill","slice","range","tensor","util","convertToTensor","threshold_","image","method","arguments","length","undefined","inverted","threshValue","$image","RED_INTENCITY_COEF","GREEN_INTENCITY_COEF","BLUE_INTENCITY_COEF","totalPixelsInImage","shape","$threshold","r","g","b","grayscale","assert","rank","concat","dtype","_split","_split2","_slicedToArray","$r","$g","$b","$histogram","otsu","invCondition","result","histogram","total","bestThresh","bestInBetVar","cInBetVar","classFirst","classSecond","meanFirst","meanSec","weightForeground","weightBack","index","size","meanFirstDivA","meanSecFill","meanSecAdd","meanSecMul","cInBetVarSubA","cInBetVarSubB","cInBetVarMul","condition","threshold"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\ops\\image\\threshold.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { Tensor1D, Tensor3D } from '../../tensor';\nimport { tensor1d } from '../tensor1d';\nimport { TensorLike } from '../../types';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport {slice} from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n\n/**\n * Performs image binarization with corresponding threshold\n * (depends on the method)value, which creates a binary image from a grayscale.\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\n * where imageHeight and imageWidth must be positive.The image color\n * range should be [0, 255].\n * @param method Optional string from `'binary' | 'otsu'`\n * which specifies the method for thresholding. Defaults to 'binary'.\n * @param inverted Optional boolean whichspecifies\n * if colours should be inverted. Defaults to false.\n * @param threshValue Optional number which defines threshold value from 0 to 1.\n * Defaults to 0.5.\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\n * contains binarized image.\n */\n\nfunction threshold_(\n    image: Tensor3D | TensorLike,\n    method = 'binary',\n    inverted = false,\n    threshValue = 0.5\n): Tensor3D {\n    const $image = convertToTensor(image, 'image', 'threshold');\n\n    /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\n\tReference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n\n    const RED_INTENCITY_COEF = 0.2989;\n    const GREEN_INTENCITY_COEF = 0.5870;\n    const BLUE_INTENCITY_COEF = 0.1140;\n    const totalPixelsInImage = $image.shape[0] * $image.shape[1];\n\n    let $threshold = mul(tensor1d([threshValue]), 255);\n    let r, g, b, grayscale;\n\n    util.assert(\n        $image.rank === 3,\n        () => 'Error in threshold: image must be rank 3,' +\n            `but got rank ${$image.rank}.`);\n\n    util.assert(\n        $image.shape[2] === 3 || $image.shape[2]=== 1,\n        () => 'Error in threshold: ' +\n            'image color channel must be equal to 3 or 1' +\n            `but got ${$image.shape[2]}.`);\n\n    util.assert(\n      $image.dtype === 'int32' || $image.dtype === 'float32',\n      () => 'Error in dtype: image dtype must be int32 or float32,' +\n          `but got dtype ${$image.dtype}.`);\n\n    util.assert(\n      method === 'otsu' || method === 'binary',\n      () => `Method must be binary or otsu, but was ${method}`);\n\n    if ($image.shape[2] === 3) {\n        [r, g, b] = split($image, [1, 1, 1], -1);\n        const $r = mul(r,RED_INTENCITY_COEF);\n        const $g = mul(g,GREEN_INTENCITY_COEF);\n        const $b = mul(b,BLUE_INTENCITY_COEF);\n        grayscale = add(add($r, $g), $b);\n    } else {\n        grayscale = image;\n    }\n\n    if (method === 'otsu') {\n        const $histogram = bincount(cast(round(grayscale), 'int32') as Tensor1D,\n            tensor([]),\n            256);\n        $threshold = otsu($histogram, totalPixelsInImage);\n    }\n\n    const invCondition = inverted ?\n        lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n\n    const result = cast(mul(invCondition,255), 'int32');\n\n    return result as Tensor3D;\n}\n\nfunction otsu(histogram: Tensor1D, total: number):Tensor1D {\n\n    let bestThresh = tensor1d([-1]);\n    let bestInBetVar = tensor1d([0]);\n    let cInBetVar = tensor1d([0]);\n    let classFirst, classSecond, meanFirst,\n        meanSec, weightForeground, weightBack;\n\n    for (let index = 0; index < histogram.size-1; index++) {\n\n        classFirst = slice(histogram, 0, index + 1);\n\n        classSecond = slice(histogram,index + 1);\n\n        weightForeground = div(sum(classFirst),total);\n\n        weightBack = div(sum(classSecond),total);\n\n        const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n\n        meanFirst = div(meanFirstDivA, sum(classFirst) );\n\n        const meanSecFill = fill(classSecond.shape, classFirst.size);\n        const meanSecAdd = add(range(0,classSecond.size),meanSecFill);\n        const meanSecMul = mul(classSecond, (meanSecAdd));\n        meanSec = div(sum(meanSecMul), sum(classSecond));\n\n        const cInBetVarSubA = sub(meanFirst, meanSec);\n        const cInBetVarSubB = sub(meanFirst, meanSec);\n        const cInBetVarMul = mul(weightForeground, weightBack);\n        cInBetVar = mul(mul(cInBetVarMul,cInBetVarSubA), cInBetVarSubB);\n\n        const condition = greater(cInBetVar, bestInBetVar);\n\n        bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n\n        bestThresh = where(condition, tensor1d([index]), bestThresh);\n\n    }\n    return bestThresh;\n}\n\nexport const threshold = /* @__PURE__ */ op({ threshold_ });\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}