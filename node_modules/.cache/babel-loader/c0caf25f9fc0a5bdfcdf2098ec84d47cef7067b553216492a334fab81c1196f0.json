{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n  var _backend_util$compute = backend_util.computeOutAndReduceShapes(xShape, reductionAxes),\n    _backend_util$compute2 = _slicedToArray(_backend_util$compute, 2),\n    outShape = _backend_util$compute2[0],\n    reduceShape = _backend_util$compute2[1];\n  var outDtype = upcastType(xDtype, 'int32');\n  var outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n  var reduceSize = util.sizeFromShape(reduceShape);\n  for (var i = 0; i < outVals.length; ++i) {\n    var offset = i * reduceSize;\n    var _prod = 1;\n    for (var j = 0; j < reduceSize; ++j) {\n      _prod *= xVals[offset + j];\n    }\n    outVals[i] = _prod;\n  }\n  return {\n    outVals: outVals,\n    outShape: outShape,\n    outDtype: outDtype\n  };\n}\nexport function prod(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var x = inputs.x;\n  var axis = attrs.axis,\n    keepDims = attrs.keepDims;\n  assertNotComplex(x, 'prod');\n  var xRank = x.shape.length;\n  var axes = util.parseAxisParam(axis, x.shape);\n  var permutation = backend_util.getAxesPermutation(axes, xRank);\n  var reductionAxes = axes;\n  var permutedX = x;\n  var intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x: x\n      },\n      backend: backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n  var xVals = backend.data.get(permutedX.dataId).values;\n  var _prodImpl = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes),\n    outVals = _prodImpl.outVals,\n    outShape = _prodImpl.outShape,\n    outDtype = _prodImpl.outDtype;\n  var resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n  intermediateTensorInfos.forEach(function (t) {\n    return backend.disposeIntermediateTensorInfo(t);\n  });\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport var prodConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod\n};","map":{"version":3,"names":["backend_util","Prod","upcastType","util","assertNotComplex","transpose","prodImpl","xShape","xDtype","xVals","reductionAxes","_backend_util$compute","computeOutAndReduceShapes","_backend_util$compute2","_slicedToArray","outShape","reduceShape","outDtype","outVals","makeZerosTypedArray","sizeFromShape","reduceSize","i","length","offset","prod","j","args","inputs","backend","attrs","x","axis","keepDims","xRank","shape","axes","parseAxisParam","permutation","getAxesPermutation","permutedX","intermediateTensorInfos","perm","push","getInnerMostAxes","data","get","dataId","values","_prodImpl","dtype","resultShape","expandShapeToKeepDim","forEach","t","disposeIntermediateTensorInfo","makeTensorInfo","prodConfig","kernelName","backendName","kernelFunc"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-cpu\\src\\kernels\\Prod.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function prodImpl(\n    xShape: number[], xDtype: DataType, xVals: TypedArray,\n    reductionAxes: number[]):\n    {outVals: TypedArray, outShape: number[], outDtype: DataType} {\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(\n                      util.sizeFromShape(outShape), outDtype) as TypedArray;\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n\n  return {outVals, outShape, outDtype};\n}\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendCPU, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'prod');\n\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  const {outVals, outShape, outDtype} =\n      prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod as unknown as KernelFunc\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}