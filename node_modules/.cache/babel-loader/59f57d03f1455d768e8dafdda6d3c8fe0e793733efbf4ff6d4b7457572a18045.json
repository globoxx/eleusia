{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nfunction validateIndices(indices, indicesShape, numParams) {\n  indices.forEach(function (index, i) {\n    if (index < 0 || index >= numParams) {\n      var locString = util.indexToLoc(i, indicesShape.length, util.computeStrides(indicesShape)).join(',');\n      throw new Error(\"indices[\".concat(locString, \"] = \").concat(index, \" is not in [0, \").concat(numParams, \")\"));\n    }\n  });\n}\nfunction validateSplits(paramsNestedSplits, numParamsDenseValues) {\n  // Validate\n  for (var dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    var splits = paramsNestedSplits[dim];\n    var lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n    for (var i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n}\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {\n  var valueSlices = [];\n  var numValues = 0;\n  var numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  var outSplits = new Array(numSplits).fill(null).map(function () {\n    return [0];\n  });\n  validateSplits(paramsNestedSplits, numParamsDenseValues);\n  // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n  var nrows = 1;\n  for (var dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    var rowLength = indicesShape[dim + 1];\n    for (var i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  }\n  // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n  for (var _i = 0; _i < indices.length; ++_i) {\n    var start = indices[_i];\n    var limit = indices[_i] + 1;\n    // Copy splits.\n    for (var _dim = 0; _dim < paramsNestedSplits.length; ++_dim) {\n      var splits = paramsNestedSplits[_dim];\n      var outDim = _dim + indicesShape.length - 1;\n      if (outDim >= 0) {\n        var outSplitsOutDim = outSplits[outDim];\n        var delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n        for (var j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n      start = splits[start];\n      limit = splits[limit];\n    }\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n  return {\n    outSplits: outSplits,\n    valueSlices: valueSlices,\n    numValues: numValues\n  };\n}\nfunction getSplits(outSplits) {\n  var splitsOut = [];\n  var _loop = function _loop() {\n    var numSplits = outSplits[i].length;\n    var splits = util.getArrayFromDType('int32', numSplits);\n    splitsOut.push(splits);\n    outSplits[i].forEach(function (value, j) {\n      return splits[j] = value;\n    });\n  };\n  for (var i = 0; i < outSplits.length; ++i) {\n    _loop();\n  }\n  return splitsOut;\n}\nfunction computeFlatOuterDims(orig, numOutDims) {\n  var outDims = orig.slice(0, numOutDims);\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n  for (var inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n  return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {\n  var denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  var valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n  var outPos = 0;\n  var _iterator = _createForOfIteratorHelper(valueSlices),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var slice = _step.value;\n      for (var i = slice[0]; i < slice[1]; ++i) {\n        for (var j = 0; j < valueSize; ++j) {\n          values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n        }\n        ++outPos;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {\n  var valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n  var valuesOut = util.getArrayFromDType(paramsDenseValuesDType, util.sizeFromShape(valuesShape));\n  var numElements = paramsDenseValues.length;\n  var valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];\n  writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);\n  return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n  var numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n  var numParamsDenseValues = paramsDenseValuesShape[0];\n  // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n  var _makeSplits = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues),\n    outSplits = _makeSplits.outSplits,\n    valueSlices = _makeSplits.valueSlices,\n    numValues = _makeSplits.numValues;\n  // Write the output tensors.\n  var outputNestedSplits = getSplits(outSplits);\n  var outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}","map":{"version":3,"names":["util","validateIndices","indices","indicesShape","numParams","forEach","index","i","locString","indexToLoc","length","computeStrides","join","Error","concat","validateSplits","paramsNestedSplits","numParamsDenseValues","dim","splits","lastSplit","makeSplits","valueSlices","numValues","numSplits","outSplits","Array","fill","map","nrows","rowLength","push","start","limit","outDim","outSplitsOutDim","delta","j","getSplits","splitsOut","_loop","getArrayFromDType","value","computeFlatOuterDims","orig","numOutDims","outDims","slice","inDim","writeValueSlices","paramsDenseValues","paramsDenseValuesShape","valueSize","values","valuesShape","denseM","valuesM","outPos","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","getValues","paramsDenseValuesDType","valuesOut","sizeFromShape","numElements","raggedGatherImpl","paramsNestedSplitsShapes","outputRaggedRank","_makeSplits","outputNestedSplits","outputDenseValues"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-cpu\\src\\kernels\\RaggedGather_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nfunction validateIndices(\n    indices: TypedArray, indicesShape: number[], numParams: number) {\n  indices.forEach((index: number, i: number) => {\n    if (index < 0 || index >= numParams) {\n      const locString =\n          util.indexToLoc(\n                  i, indicesShape.length, util.computeStrides(indicesShape))\n              .join(',');\n      throw new Error(\n          `indices[${locString}] = ${index} is not in [0, ${numParams})`);\n    }\n  });\n}\n\nfunction validateSplits(\n    paramsNestedSplits: TypedArray[], numParamsDenseValues: number) {\n  // Validate\n  for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    const splits = paramsNestedSplits[dim];\n    const lastSplit = (dim === paramsNestedSplits.length - 1) ?\n        numParamsDenseValues :\n        paramsNestedSplits[dim + 1].length;\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n    for (let i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n}\n\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(\n    indices: TypedArray, indicesShape: number[],\n    paramsNestedSplits: TypedArray[], numParamsDenseValues: number) {\n  const valueSlices: Array<[number, number]> = [];\n  let numValues = 0;\n\n  const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n\n  validateSplits(paramsNestedSplits, numParamsDenseValues);\n\n  // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n  let nrows = 1;\n  for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    const rowLength = indicesShape[dim + 1];\n    for (let i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  }\n\n  // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n  for (let i = 0; i < indices.length; ++i) {\n    let start = indices[i];\n    let limit = indices[i] + 1;\n\n    // Copy splits.\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n      const splits = paramsNestedSplits[dim];\n      const outDim = dim + indicesShape.length - 1;\n      if (outDim >= 0) {\n        const outSplitsOutDim = outSplits[outDim];\n        const delta =\n            outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n        for (let j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n      start = splits[start];\n      limit = splits[limit];\n    }\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n\n  return {outSplits, valueSlices, numValues};\n}\n\nfunction getSplits(outSplits: number[][]) {\n  const splitsOut: TypedArray[] = [];\n  for (let i = 0; i < outSplits.length; ++i) {\n    const numSplits = outSplits[i].length;\n    const splits = util.getArrayFromDType('int32', numSplits) as TypedArray;\n    splitsOut.push(splits);\n\n    outSplits[i].forEach((value, j: number) => splits[j] = value);\n  }\n\n  return splitsOut;\n}\n\nfunction computeFlatOuterDims(orig: number[], numOutDims: number) {\n  const outDims = orig.slice(0, numOutDims);\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n\n  for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n\n  return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    valueSlices: Array<[number, number]>, valueSize: number, values: TypedArray,\n    valuesShape: number[]) {\n  const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n\n  let outPos = 0;\n  for (const slice of valueSlices) {\n    for (let i = slice[0]; i < slice[1]; ++i) {\n      for (let j = 0; j < valueSize; ++j) {\n        values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n      }\n      ++outPos;\n    }\n  }\n}\n\nfunction getValues(\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    paramsDenseValuesDType: DataType, valueSlices: Array<[number, number]>,\n    numValues: number): [TypedArray, number[]] {\n  const valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n\n  const valuesOut = util.getArrayFromDType(\n                        paramsDenseValuesDType,\n                        util.sizeFromShape(valuesShape)) as TypedArray;\n\n  const numElements = paramsDenseValues.length;\n  const valueSize =\n      numElements === 0 ? 0 : (numElements / paramsDenseValuesShape[0]);\n  writeValueSlices(\n      paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize,\n      valuesOut, valuesShape);\n\n  return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(\n    paramsNestedSplits: TypedArray[], paramsNestedSplitsShapes: number[][],\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    paramsDenseValuesDType: DataType, indices: TypedArray,\n    indicesShape: number[],\n    outputRaggedRank: number): [TypedArray[], TypedArray, number[]] {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n  const numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n  const numParamsDenseValues = paramsDenseValuesShape[0];\n\n  // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n  const {outSplits, valueSlices, numValues} = makeSplits(\n      indices, indicesShape, paramsNestedSplits, numParamsDenseValues);\n\n  // Write the output tensors.\n  const outputNestedSplits = getSplits(outSplits);\n  const outputDenseValues = getValues(\n      paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType,\n      valueSlices, numValues);\n\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}