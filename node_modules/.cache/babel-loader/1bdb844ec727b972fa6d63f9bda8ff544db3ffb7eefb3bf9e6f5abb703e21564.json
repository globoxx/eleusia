{"ast":null,"code":"import _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nexport var Pool2DProgram = /*#__PURE__*/_createClass(function Pool2DProgram(convInfo, poolType, computePositions) {\n  var flattenPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var includeBatchInIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  _classCallCheck(this, Pool2DProgram);\n  this.variableNames = ['x'];\n  if (poolType === 'avg' && computePositions) {\n    throw new Error('Cannot compute positions for average pool.');\n  }\n  var filterWidth = convInfo.filterWidth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  this.outputShape = convInfo.outShape;\n  var isAvgPool = poolType === 'avg';\n  var batchFlattenPositionStr = \"((batch  * \".concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + d\");\n  var flattenPositionStr = \"(xR * \".concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + d\");\n  var initializationValue = '0.0';\n  if (!isAvgPool) {\n    // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n    initializationValue = '-1.0 / 1e-20';\n  }\n  if (computePositions) {\n    var _compareOp = '>=';\n    this.userCode = \"\\n        const ivec2 strides = ivec2(\".concat(strideHeight, \", \").concat(strideWidth, \");\\n        const ivec2 pads = ivec2(\").concat(padTop, \", \").concat(padLeft, \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n              wR += \").concat(dilationHeight, \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \").concat(effectiveFilterWidth, \";\\n                wC += \").concat(dilationWidth, \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \").concat(_compareOp, \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = \").concat(flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : \"wR * \".concat(effectiveFilterWidth, \" + wC\"), \";\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \");\n    return;\n  }\n  var compareOp = 'max';\n  var returnValue = \"\".concat(poolType, \"(\").concat(poolType, \"(\").concat(poolType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n  if (poolType === 'avg') {\n    returnValue = \"avgValue / max(count, 1.0)\";\n  }\n  var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n  var filterWidthVec4Remainder = filterWidth % 4;\n  var updateSnippet = \"\\n      if (\".concat(isAvgPool, \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n  this.userCode = \"\\n      const ivec2 strides = ivec2(\".concat(strideHeight, \", \").concat(strideWidth, \");\\n      const ivec2 pads = ivec2(\").concat(padTop, \", \").concat(padLeft, \");\\n      const float initializationValue = \").concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n            wR += \").concat(dilationHeight, \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \").concat(filterWidthNearestVec4, \"; wC += 4) {\\n            int xC = xCCorner + wC * \").concat(dilationWidth, \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 2 * \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 3 * \").concat(dilationWidth, \", d)\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          }\\n\\n          int xC = xCCorner + \").concat(filterWidthNearestVec4, \";\\n          if (\").concat(filterWidthVec4Remainder === 1, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          } else if (\").concat(filterWidthVec4Remainder === 2, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          } else if (\").concat(filterWidthVec4Remainder === 3, \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \").concat(dilationWidth, \", d),\\n              getValue(batch, xR, xC + 2 * \").concat(dilationWidth, \", d),\\n              initializationValue\\n            );\\n\\n            \").concat(updateSnippet, \"\\n          }\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n});\nexport var Pool3DProgram = /*#__PURE__*/_createClass(function Pool3DProgram(convInfo, poolType, computePositions) {\n  var flattenPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var includeBatchInIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  _classCallCheck(this, Pool3DProgram);\n  this.variableNames = ['x'];\n  if (poolType === 'avg' && computePositions) {\n    throw new Error('Cannot compute positions for average pool.');\n  }\n  var filterWidth = convInfo.filterWidth;\n  var strideDepth = convInfo.strideDepth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationDepth = convInfo.dilationDepth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padFront = convInfo.padInfo.front;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  this.outputShape = convInfo.outShape;\n  var isAvgPool = poolType === 'avg';\n  var initializationValue = '0.0';\n  if (!isAvgPool) {\n    // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n    initializationValue = '-1.0 / 1e-20';\n  }\n  if (computePositions) {\n    var _compareOp2 = '>=';\n    this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\".concat(strideDepth, \", \").concat(strideHeight, \", \").concat(strideWidth, \");\\n        const ivec3 pads = ivec3(\").concat(padFront, \", \").concat(padTop, \", \").concat(padLeft, \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \").concat(effectiveFilterDepth, \";\\n              wD += \").concat(dilationDepth, \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \").concat(convInfo.inDepth, \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n                wR += \").concat(dilationHeight, \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \").concat(effectiveFilterWidth, \";\\n                  wC += \").concat(dilationWidth, \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value \").concat(_compareOp2, \" currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition = \").concat(flattenPositions ? includeBatchInIndex ? \"(((batch * \".concat(convInfo.inDepth, \" + xD) * \").concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + ch\") : \"((xD * \".concat(convInfo.inHeight, \" + xR) * \").concat(convInfo.inWidth, \" + xC) * \").concat(convInfo.inChannels, \" + ch\") : \"wD * \".concat(effectiveFilterHeight, \" * \").concat(effectiveFilterWidth, \" +\\n                      wR * \").concat(effectiveFilterWidth, \" + wC\"), \";\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \");\n    return;\n  }\n  var compareOp = 'max';\n  var returnValue = \"\".concat(poolType, \"(\").concat(poolType, \"(\").concat(poolType, \"(\") + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n  if (poolType === 'avg') {\n    // Use `max(count, 1.0)` instead of `count` in case count === 0.0.\n    // If count === 0.0, `avgValue` is always 0.0 and we change `count`'s\n    // value to avoid dividing zero.\n    returnValue = \"avgValue / max(count, 1.0)\";\n  }\n  var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n  var filterWidthVec4Remainder = filterWidth % 4;\n  var updateSnippet = \"\\n      if (\".concat(isAvgPool, \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \").concat(compareOp, \"(values, minMaxValue);\\n      }\\n    \");\n  this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\".concat(strideDepth, \", \").concat(strideHeight, \", \").concat(strideWidth, \");\\n      const ivec3 pads = ivec3(\").concat(padFront, \", \").concat(padTop, \", \").concat(padLeft, \");\\n      const float initializationValue = \").concat(initializationValue, \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \").concat(convInfo.inWidth, \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\").concat(initializationValue, \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \").concat(effectiveFilterDepth, \";\\n            wD += \").concat(dilationDepth, \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \").concat(convInfo.inDepth, \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \").concat(effectiveFilterHeight, \";\\n            wR += \").concat(dilationHeight, \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \").concat(convInfo.inHeight, \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \").concat(filterWidthNearestVec4, \"; wC += 4) {\\n              int xC = xCCorner + wC * \").concat(dilationWidth, \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \").concat(dilationWidth, \", ch)\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            }\\n\\n            int xC = xCCorner + \").concat(filterWidthNearestVec4, \";\\n            if (\").concat(filterWidthVec4Remainder === 1, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            } else if (\").concat(filterWidthVec4Remainder === 2, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            } else if (\").concat(filterWidthVec4Remainder === 3, \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \").concat(dilationWidth, \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \").concat(dilationWidth, \", ch),\\n                initializationValue\\n              );\\n\\n              \").concat(updateSnippet, \"\\n            }\\n          }\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n});","map":{"version":3,"names":["Pool2DProgram","_createClass","convInfo","poolType","computePositions","flattenPositions","arguments","length","undefined","includeBatchInIndex","_classCallCheck","variableNames","Error","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","outputShape","outShape","isAvgPool","batchFlattenPositionStr","concat","inHeight","inWidth","inChannels","flattenPositionStr","initializationValue","compareOp","userCode","returnValue","filterWidthNearestVec4","Math","floor","filterWidthVec4Remainder","updateSnippet","Pool3DProgram","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","inDepth"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\pool_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Pool2DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${\n        convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    const flattenPositionStr =\n        `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${\n          flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                                                    flattenPositionStr) :\n                             `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / max(count, 1.0)`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n\nexport class Pool3DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${\n          flattenPositions ?\n              (includeBatchInIndex ?\n                   `(((batch * ${convInfo.inDepth} + xD) * ${\n                       convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${\n                       convInfo.inChannels} + ch` :\n                   `((xD * ${convInfo.inHeight} + xR) * ${\n                       convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n              `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      // Use `max(count, 1.0)` instead of `count` in case count === 0.0.\n      // If count === 0.0, `avgValue` is always 0.0 and we change `count`'s\n      // value to avoid dividing zero.\n      returnValue = `avgValue / max(count, 1.0)`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}