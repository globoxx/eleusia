{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nvar whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport var MathBackendCPU = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendCPU, _KernelBackend);\n  var _super = _createSuper(MathBackendCPU);\n  function MathBackendCPU() {\n    var _this;\n    _classCallCheck(this, MathBackendCPU);\n    _this = _super.call(this);\n    _this.blockSize = 48;\n    _this.firstUse = true;\n    _this.data = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n  _createClass(MathBackendCPU, [{\n    key: \"nextDataId\",\n    value: function nextDataId() {\n      return MathBackendCPU.nextDataId++;\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (this.firstUse) {\n        this.firstUse = false;\n        if (env().get('IS_NODE')) {\n          backend_util.warn('\\n============================\\n' + 'Hi, looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' + '\\n============================');\n        }\n      }\n      var dataId = {\n        id: this.nextDataId()\n      };\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var outId;\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        outId = this.write(encodedValues, shape, dtype);\n      } else {\n        outId = this.write(values, shape, dtype);\n      }\n      return {\n        dataId: outId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n    /** Return refCount of a `TensorData`. */\n  }, {\n    key: \"refCount\",\n    value: function refCount(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        return tensorData.refCount;\n      }\n      return 0;\n    }\n    /** Increase refCount of a `TensorData`. */\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var tensorData = this.data.get(dataId);\n      tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype, refCount) {\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: refCount\n      });\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.data.numDataIds();\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataId) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.readSync(dataId));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var _this$data$get = this.data.get(dataId),\n        dtype = _this$data$get.dtype,\n        complexTensorInfos = _this$data$get.complexTensorInfos;\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      }\n      return util.convertBackendValuesAndArrayBuffer(this.data.get(dataId).values, dtype);\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          var strings = data.map(function (d) {\n            return util.decodeString(d);\n          });\n          return buffer(t.shape, t.dtype, strings);\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n      return buffer(t.shape, t.dtype, data);\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(values, shape, dtype) {\n      return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released or memory is not managed in this backend, false if memory is\n     * not cleared.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.data.has(dataId)) {\n        this.data.get(dataId).refCount--;\n        if (!force && this.data.get(dataId).refCount > 0) {\n          return false;\n        }\n        var _this$data$get2 = this.data.get(dataId),\n          complexTensorInfos = _this$data$get2.complexTensorInfos;\n        if (complexTensorInfos != null) {\n          this.disposeData(complexTensorInfos.real.dataId, true);\n          this.disposeData(complexTensorInfos.imag.dataId, true);\n        }\n        this.data.delete(dataId);\n      }\n      return true;\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      this.disposeData(tensorInfo.dataId);\n    }\n  }, {\n    key: \"time\",\n    value: function () {\n      var _time = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(f) {\n        var start, kernelMs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              start = util.now();\n              f();\n              kernelMs = util.now() - start;\n              return _context2.abrupt(\"return\", {\n                kernelMs: kernelMs\n              });\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function time(_x2) {\n        return _time.apply(this, arguments);\n      }\n      return time;\n    }()\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        // Unreliable due to automatic gc. The numbers above are cumulative.\n        unreliable: true,\n        reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n      };\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      assertNotComplex([condition], 'where');\n      var condVals = this.readSync(condition.dataId);\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      return 32;\n    }\n    /** Returns the smallest representable number.  */\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return _get(_getPrototypeOf(MathBackendCPU.prototype), \"epsilon\", this).call(this);\n    }\n  }]);\n  return MathBackendCPU;\n}(KernelBackend);\nMathBackendCPU.nextDataId = 0;","map":{"version":3,"names":["backend_util","buffer","DataStorage","engine","env","kernel_impls","KernelBackend","util","whereImpl","assertNotComplex","MathBackendCPU","_KernelBackend","_inherits","_super","_createSuper","_this","_classCallCheck","call","blockSize","firstUse","data","_assertThisInitialized","_createClass","key","value","nextDataId","write","values","shape","dtype","get","warn","dataId","id","set","refCount","makeTensorInfo","outId","length","isString","encodedValues","map","d","encodeString","has","tensorData","incRef","decRef","move","numDataIds","_read","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","readSync","stop","read","_x","apply","arguments","_this$data$get","complexTensorInfos","realValues","real","imagValues","imag","mergeRealAndImagArrays","convertBackendValuesAndArrayBuffer","bufferSync","t","strings","decodeString","_a","Error","makeOutput","makeTensorFromTensorInfo","disposeData","force","undefined","_this$data$get2","delete","disposeIntermediateTensorInfo","tensorInfo","_time","_callee2","f","start","kernelMs","_callee2$","_context2","now","time","_x2","memory","unreliable","reasons","where","condition","condVals","dispose","floatPrecision","epsilon","_get","_getPrototypeOf","prototype"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-cpu\\src\\backend_cpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendTimingInfo, buffer, DataStorage, DataType, engine, env, kernel_impls, KernelBackend, Rank, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nconst whereImpl = kernel_impls.whereImpl;\nimport {assertNotComplex} from './cpu_util';\n\ninterface DataId {}\n\nexport interface TensorData<D extends DataType> {\n  values?: backend_util.BackendValues;\n  dtype: D;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensors, with a parent joining the two with the\n  // complexTensorInfos field.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo};\n  // refCount keeps track of how many tensors reference it. Used for memory\n  // management.\n  refCount: number;\n}\n\nexport class MathBackendCPU extends KernelBackend {\n  public blockSize = 48;\n\n  data: DataStorage<TensorData<DataType>>;\n  private firstUse = true;\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendCPU.nextDataId++;\n  }\n\n  constructor() {\n    super();\n    this.data = new DataStorage(this, engine());\n  }\n\n  override write(\n      values: backend_util.BackendValues, shape: number[],\n      dtype: DataType): DataId {\n    if (this.firstUse) {\n      this.firstUse = false;\n      if (env().get('IS_NODE')) {\n        backend_util.warn(\n            '\\n============================\\n' +\n            'Hi, looks like you are running TensorFlow.js in ' +\n            'Node.js. To speed things up dramatically, install our node ' +\n            'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' +\n            '\\n============================');\n      }\n    }\n    const dataId = {id: this.nextDataId()};\n\n    this.data.set(dataId, {values, dtype, refCount: 1});\n\n    return dataId;\n  }\n\n  /**\n   * Create a data bucket in cpu backend.\n   * @param shape Shape of the `TensorInfo`.\n   * @param dtype DType of the `TensorInfo`.\n   * @param values The value of the `TensorInfo` stored as a flattened array.\n   */\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: backend_util.BackendValues|string[]): TensorInfo {\n    let outId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as unknown as string[]).map(d => util.encodeString(d));\n\n      outId = this.write(encodedValues, shape, dtype);\n    } else {\n      outId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    return {dataId: outId, shape, dtype};\n  }\n\n  /** Return refCount of a `TensorData`. */\n  override refCount(dataId: DataId): number {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TensorData`. */\n  override incRef(dataId: DataId): void {\n    const tensorData = this.data.get(dataId);\n    tensorData.refCount++;\n  }\n\n  /** Decrease refCount of a `TensorData`. */\n  decRef(dataId: DataId): void {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  override move(\n      dataId: DataId, values: backend_util.BackendValues, shape: number[],\n      dtype: DataType, refCount: number): void {\n    this.data.set(dataId, {values, dtype, refCount});\n  }\n\n  override numDataIds(): number {\n    return this.data.numDataIds();\n  }\n\n  override async read(dataId: DataId): Promise<backend_util.BackendValues> {\n    return this.readSync(dataId);\n  }\n  override readSync(dataId: DataId): backend_util.BackendValues {\n    const {dtype, complexTensorInfos} = this.data.get(dataId);\n\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    }\n    return util.convertBackendValuesAndArrayBuffer(\n        this.data.get(dataId).values, dtype);\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  makeOutput<T extends Tensor>(\n      values: backend_util.BackendValues, shape: number[], dtype: DataType): T {\n    return engine().makeTensorFromTensorInfo(\n               this.makeTensorInfo(shape, dtype, values), this) as T;\n  }\n\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or memory is not managed in this backend, false if memory is\n   * not cleared.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  override disposeData(dataId: DataId, force = false): boolean {\n    if (this.data.has(dataId)) {\n      this.data.get(dataId).refCount--;\n      if (!force && this.data.get(dataId).refCount > 0) {\n        return false;\n      }\n\n      const {complexTensorInfos} = this.data.get(dataId);\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, true);\n        this.disposeData(complexTensorInfos.imag.dataId, true);\n      }\n\n      this.data.delete(dataId);\n    }\n    return true;\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  override async time(f: () => void): Promise<BackendTimingInfo> {\n    const start = util.now();\n    f();\n    const kernelMs = util.now() - start;\n    return {kernelMs};\n  }\n\n  override memory() {\n    return {\n      // Unreliable due to automatic gc. The numbers above are cumulative.\n      unreliable: true,\n      reasons:\n          ['The reported memory is an upper bound. Due to automatic garbage ' +\n           'collection, the true allocated memory may be less.']\n    };\n  }\n\n  where(condition: Tensor): Tensor2D {\n    assertNotComplex([condition], 'where');\n\n    const condVals = this.readSync(condition.dataId) as TypedArray;\n    return whereImpl(condition.shape, condVals);\n  }\n\n  override dispose() {}\n\n  override floatPrecision(): 16|32 {\n    return 32;\n  }\n\n  /** Returns the smallest representable number.  */\n  override epsilon(): number {\n    return super.epsilon();\n  }\n}\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,YAAY,EAAqBC,MAAM,EAAEC,WAAW,EAAYC,MAAM,EAAEC,GAAG,EAAEC,YAAY,EAAEC,aAAa,EAA0EC,IAAI,QAAO,uBAAuB;AAE5N,IAAMC,SAAS,GAAGH,YAAY,CAACG,SAAS;AACxC,SAAQC,gBAAgB,QAAO,YAAY;AAgB3C,WAAaC,cAAe,0BAAAC,cAAA;EAAAC,SAAA,CAAAF,cAAA,EAAAC,cAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,cAAA;EAU1B,SAAAA,eAAA;IAAA,IAAAK,KAAA;IAAAC,eAAA,OAAAN,cAAA;IACEK,KAAA,GAAAF,MAAA,CAAAI,IAAA;IAVKF,KAAA,CAAAG,SAAS,GAAG,EAAE;IAGbH,KAAA,CAAAI,QAAQ,GAAG,IAAI;IAQrBJ,KAAA,CAAKK,IAAI,GAAG,IAAIlB,WAAW,CAAAmB,sBAAA,CAAAN,KAAA,GAAOZ,MAAM,EAAE,CAAC;IAAC,OAAAY,KAAA;EAC9C;EAACO,YAAA,CAAAZ,cAAA;IAAAa,GAAA;IAAAC,KAAA,EAPO,SAAAC,WAAA,EAAU;MAChB,OAAOf,cAAc,CAACe,UAAU,EAAE;IACpC;EAAC;IAAAF,GAAA;IAAAC,KAAA,EAOQ,SAAAE,MACLC,MAAkC,EAAEC,KAAe,EACnDC,KAAe;MACjB,IAAI,IAAI,CAACV,QAAQ,EAAE;QACjB,IAAI,CAACA,QAAQ,GAAG,KAAK;QACrB,IAAIf,GAAG,EAAE,CAAC0B,GAAG,CAAC,SAAS,CAAC,EAAE;UACxB9B,YAAY,CAAC+B,IAAI,CACb,kCAAkC,GAClC,kDAAkD,GAClD,6DAA6D,GAC7D,2EAA2E,GAC3E,gCAAgC,CAAC;;;MAGzC,IAAMC,MAAM,GAAG;QAACC,EAAE,EAAE,IAAI,CAACR,UAAU;MAAE,CAAC;MAEtC,IAAI,CAACL,IAAI,CAACc,GAAG,CAACF,MAAM,EAAE;QAACL,MAAM,EAANA,MAAM;QAAEE,KAAK,EAALA,KAAK;QAAEM,QAAQ,EAAE;MAAC,CAAC,CAAC;MAEnD,OAAOH,MAAM;IACf;IAEA;;;;;;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAMA,SAAAY,eACIR,KAAe,EAAEC,KAAe,EAChCF,MAA4C;MAC9C,IAAIU,KAAK;MACT,IAAIR,KAAK,KAAK,QAAQ,IAAIF,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACW,MAAM,GAAG,CAAC,IACzD/B,IAAI,CAACgC,QAAQ,CAACZ,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;QAC5B,IAAMa,aAAa,GACdb,MAA8B,CAACc,GAAG,CAAC,UAAAC,CAAC;UAAA,OAAInC,IAAI,CAACoC,YAAY,CAACD,CAAC,CAAC;QAAA,EAAC;QAElEL,KAAK,GAAG,IAAI,CAACX,KAAK,CAACc,aAAa,EAAEZ,KAAK,EAAEC,KAAK,CAAC;OAChD,MAAM;QACLQ,KAAK,GAAG,IAAI,CAACX,KAAK,CAACC,MAAoB,EAAEC,KAAK,EAAEC,KAAK,CAAC;;MAGxD,OAAO;QAACG,MAAM,EAAEK,KAAK;QAAET,KAAK,EAALA,KAAK;QAAEC,KAAK,EAALA;MAAK,CAAC;IACtC;IAEA;EAAA;IAAAN,GAAA;IAAAC,KAAA,EACS,SAAAW,SAASH,MAAc;MAC9B,IAAI,IAAI,CAACZ,IAAI,CAACwB,GAAG,CAACZ,MAAM,CAAC,EAAE;QACzB,IAAMa,UAAU,GAAG,IAAI,CAACzB,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC;QACxC,OAAOa,UAAU,CAACV,QAAQ;;MAE5B,OAAO,CAAC;IACV;IAEA;EAAA;IAAAZ,GAAA;IAAAC,KAAA,EACS,SAAAsB,OAAOd,MAAc;MAC5B,IAAMa,UAAU,GAAG,IAAI,CAACzB,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC;MACxCa,UAAU,CAACV,QAAQ,EAAE;IACvB;IAEA;EAAA;IAAAZ,GAAA;IAAAC,KAAA,EACA,SAAAuB,OAAOf,MAAc;MACnB,IAAI,IAAI,CAACZ,IAAI,CAACwB,GAAG,CAACZ,MAAM,CAAC,EAAE;QACzB,IAAMa,UAAU,GAAG,IAAI,CAACzB,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC;QACxCa,UAAU,CAACV,QAAQ,EAAE;;IAEzB;EAAC;IAAAZ,GAAA;IAAAC,KAAA,EAEQ,SAAAwB,KACLhB,MAAc,EAAEL,MAAkC,EAAEC,KAAe,EACnEC,KAAe,EAAEM,QAAgB;MACnC,IAAI,CAACf,IAAI,CAACc,GAAG,CAACF,MAAM,EAAE;QAACL,MAAM,EAANA,MAAM;QAAEE,KAAK,EAALA,KAAK;QAAEM,QAAQ,EAARA;MAAQ,CAAC,CAAC;IAClD;EAAC;IAAAZ,GAAA;IAAAC,KAAA,EAEQ,SAAAyB,WAAA,EAAU;MACjB,OAAO,IAAI,CAAC7B,IAAI,CAAC6B,UAAU,EAAE;IAC/B;EAAC;IAAA1B,GAAA;IAAAC,KAAA;MAAA,IAAA0B,KAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAEQ,SAAAC,QAAWtB,MAAc;QAAA,OAAAoB,mBAAA,GAAAG,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAA,OAAAF,QAAA,CAAAG,MAAA,WACzB,IAAI,CAACC,QAAQ,CAAC7B,MAAM,CAAC;YAAA;YAAA;cAAA,OAAAyB,QAAA,CAAAK,IAAA;UAAA;QAAA,GAAAR,OAAA;MAAA,CAC7B;MAAA,SAAAS,KAAAC,EAAA;QAAA,OAAAd,KAAA,CAAAe,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAH,IAAA;IAAA;EAAA;IAAAxC,GAAA;IAAAC,KAAA,EACQ,SAAAqC,SAAS7B,MAAc;MAC9B,IAAAmC,cAAA,GAAoC,IAAI,CAAC/C,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC;QAAlDH,KAAK,GAAAsC,cAAA,CAALtC,KAAK;QAAEuC,kBAAkB,GAAAD,cAAA,CAAlBC,kBAAkB;MAEhC,IAAIvC,KAAK,KAAK,WAAW,EAAE;QACzB,IAAMwC,UAAU,GACZ,IAAI,CAACR,QAAQ,CAACO,kBAAkB,CAACE,IAAI,CAACtC,MAAM,CAAiB;QACjE,IAAMuC,UAAU,GACZ,IAAI,CAACV,QAAQ,CAACO,kBAAkB,CAACI,IAAI,CAACxC,MAAM,CAAiB;QACjE,OAAOhC,YAAY,CAACyE,sBAAsB,CAACJ,UAAU,EAAEE,UAAU,CAAC;;MAEpE,OAAOhE,IAAI,CAACmE,kCAAkC,CAC1C,IAAI,CAACtD,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC,CAACL,MAAM,EAAEE,KAAK,CAAC;IAC1C;EAAC;IAAAN,GAAA;IAAAC,KAAA,EAED,SAAAmD,WAA+CC,CAAa;MAE1D,IAAMxD,IAAI,GAAG,IAAI,CAACyC,QAAQ,CAACe,CAAC,CAAC5C,MAAM,CAAC;MACpC,IAAI4C,CAAC,CAAC/C,KAAK,KAAK,QAAQ,EAAE;QACxB,IAAI;UACF;UACA,IAAMgD,OAAO,GAAIzD,IAAqB,CAACqB,GAAG,CAAC,UAAAC,CAAC;YAAA,OAAInC,IAAI,CAACuE,YAAY,CAACpC,CAAC,CAAC;UAAA,EAAC;UACrE,OAAOzC,MAAM,CAAC2E,CAAC,CAAChD,KAAoB,EAAEgD,CAAC,CAAC/C,KAAK,EAAEgD,OAAO,CAChC;SACvB,CAAC,OAAAE,EAAA,EAAM;UACN,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;;;MAGvE,OAAO/E,MAAM,CAAC2E,CAAC,CAAChD,KAAoB,EAAEgD,CAAC,CAAC/C,KAAK,EAAET,IAAkB,CAC3C;IACxB;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAyD,WACItD,MAAkC,EAAEC,KAAe,EAAEC,KAAe;MACtE,OAAO1B,MAAM,EAAE,CAAC+E,wBAAwB,CAC7B,IAAI,CAAC9C,cAAc,CAACR,KAAK,EAAEC,KAAK,EAAEF,MAAM,CAAC,EAAE,IAAI,CAAM;IAClE;IAEA;;;;;;;EAAA;IAAAJ,GAAA;IAAAC,KAAA,EAOS,SAAA2D,YAAYnD,MAAc,EAAe;MAAA,IAAboD,KAAK,GAAAlB,SAAA,CAAA5B,MAAA,QAAA4B,SAAA,QAAAmB,SAAA,GAAAnB,SAAA,MAAG,KAAK;MAChD,IAAI,IAAI,CAAC9C,IAAI,CAACwB,GAAG,CAACZ,MAAM,CAAC,EAAE;QACzB,IAAI,CAACZ,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC,CAACG,QAAQ,EAAE;QAChC,IAAI,CAACiD,KAAK,IAAI,IAAI,CAAChE,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC,CAACG,QAAQ,GAAG,CAAC,EAAE;UAChD,OAAO,KAAK;;QAGd,IAAAmD,eAAA,GAA6B,IAAI,CAAClE,IAAI,CAACU,GAAG,CAACE,MAAM,CAAC;UAA3CoC,kBAAkB,GAAAkB,eAAA,CAAlBlB,kBAAkB;QAEzB,IAAIA,kBAAkB,IAAI,IAAI,EAAE;UAC9B,IAAI,CAACe,WAAW,CAACf,kBAAkB,CAACE,IAAI,CAACtC,MAAM,EAAE,IAAI,CAAC;UACtD,IAAI,CAACmD,WAAW,CAACf,kBAAkB,CAACI,IAAI,CAACxC,MAAM,EAAE,IAAI,CAAC;;QAGxD,IAAI,CAACZ,IAAI,CAACmE,MAAM,CAACvD,MAAM,CAAC;;MAE1B,OAAO,IAAI;IACb;EAAC;IAAAT,GAAA;IAAAC,KAAA,EAED,SAAAgE,8BAA8BC,UAAsB;MAClD,IAAI,CAACN,WAAW,CAACM,UAAU,CAACzD,MAAM,CAAC;IACrC;EAAC;IAAAT,GAAA;IAAAC,KAAA;MAAA,IAAAkE,KAAA,GAAAvC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAEQ,SAAAsC,SAAWC,CAAa;QAAA,IAAAC,KAAA,EAAAC,QAAA;QAAA,OAAA1C,mBAAA,GAAAG,IAAA,UAAAwC,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAtC,IAAA,GAAAsC,SAAA,CAAArC,IAAA;YAAA;cACzBkC,KAAK,GAAGtF,IAAI,CAAC0F,GAAG,EAAE;cACxBL,CAAC,EAAE;cACGE,QAAQ,GAAGvF,IAAI,CAAC0F,GAAG,EAAE,GAAGJ,KAAK;cAAA,OAAAG,SAAA,CAAApC,MAAA,WAC5B;gBAACkC,QAAQ,EAARA;cAAQ,CAAC;YAAA;YAAA;cAAA,OAAAE,SAAA,CAAAlC,IAAA;UAAA;QAAA,GAAA6B,QAAA;MAAA,CAClB;MAAA,SAAAO,KAAAC,GAAA;QAAA,OAAAT,KAAA,CAAAzB,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAgC,IAAA;IAAA;EAAA;IAAA3E,GAAA;IAAAC,KAAA,EAEQ,SAAA4E,OAAA,EAAM;MACb,OAAO;QACL;QACAC,UAAU,EAAE,IAAI;QAChBC,OAAO,EACH,CAAC,kEAAkE,GAClE,oDAAoD;OAC1D;IACH;EAAC;IAAA/E,GAAA;IAAAC,KAAA,EAED,SAAA+E,MAAMC,SAAiB;MACrB/F,gBAAgB,CAAC,CAAC+F,SAAS,CAAC,EAAE,OAAO,CAAC;MAEtC,IAAMC,QAAQ,GAAG,IAAI,CAAC5C,QAAQ,CAAC2C,SAAS,CAACxE,MAAM,CAAe;MAC9D,OAAOxB,SAAS,CAACgG,SAAS,CAAC5E,KAAK,EAAE6E,QAAQ,CAAC;IAC7C;EAAC;IAAAlF,GAAA;IAAAC,KAAA,EAEQ,SAAAkF,QAAA,EAAO,CAAI;EAAC;IAAAnF,GAAA;IAAAC,KAAA,EAEZ,SAAAmF,eAAA,EAAc;MACrB,OAAO,EAAE;IACX;IAEA;EAAA;IAAApF,GAAA;IAAAC,KAAA,EACS,SAAAoF,QAAA,EAAO;MACd,OAAAC,IAAA,CAAAC,eAAA,CAAApG,cAAA,CAAAqG,SAAA,oBAAA9F,IAAA;IACF;EAAC;EAAA,OAAAP,cAAA;AAAA,EAnMiCJ,aAAa;AAKhCI,cAAA,CAAAe,UAAU,GAAG,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}