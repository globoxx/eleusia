{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n  var inputParam = node.inputParams[paramName];\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    var start = inputParam.inputIndexStart;\n    var end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n    var shiftedStart = start < 0 ? node.inputNames.length + start : start;\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[shiftedStart], tensorMap, context, resourceManager);\n    }\n    if (inputParam.type === 'tensors') {\n      // TODO(mattSoulanille): This filters out NoOp nodes during execution, but\n      // these should really never be in the execution graph in the first place.\n      // They're necessary for ordering the graph, but should not be visible\n      // during execution. Perhaps have different sets of children, one for\n      // control dependencies and another for real dependencies.\n      var inputs = node.inputs.slice(start, end);\n      var inputNames = node.inputNames.slice(start, end).filter(function (_name, index) {\n        var _a;\n        return ((_a = inputs[index]) === null || _a === void 0 ? void 0 : _a.op) !== 'NoOp';\n      });\n      return inputNames.map(function (name) {\n        return getTensor(name, tensorMap, context, resourceManager);\n      });\n    }\n    var tensor = getTensor(node.inputNames[shiftedStart], tensorMap, context, resourceManager);\n    var data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : util.toNestedArray(tensor.shape, data);\n  }\n  var attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\r\n * Retrieve the tensor from tensorsMap based on input name.\r\n * @param name Node input name\r\n * @param tensorsMap Tensors map keyed by the node\r\n * @param context contains tensors and information for running the current node.\r\n * @param resourceManager Optional. Contains global resources of the model.\r\n */\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n  var _parseNodeName = parseNodeName(name, context),\n    _parseNodeName2 = _slicedToArray(_parseNodeName, 2),\n    nodeName = _parseNodeName2[0],\n    index = _parseNodeName2[1];\n  if (resourceManager != null) {\n    var tensor = resourceManager.getHashTableHandleByName(nodeName);\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n  var contextId = context.currentContextIds.find(function (contextId) {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\r\n * Retrieve the tensors based on input name for current context.\r\n * @param name Node input name\r\n * @param tensorsMap Tensors map keyed by the node\r\n */\nexport function getTensorsForCurrentContext(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\r\n * Returns the node name, outputName and index from the Node input name.\r\n * @param inputName The input name of the node, in format of\r\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\r\n * default to 0.\r\n * If the input name contains output name i.e. StringSplit:indices:0, it will\r\n * return ['StringSplit', 0, 'indices'].\r\n */\nexport function getNodeNameAndIndex(inputName, context) {\n  var _parseNodeName3 = parseNodeName(inputName, context),\n    _parseNodeName4 = _slicedToArray(_parseNodeName3, 3),\n    nodeName = _parseNodeName4[0],\n    index = _parseNodeName4[1],\n    outputName = _parseNodeName4[2];\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index, outputName];\n}\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? \"\".concat(name, \"-\").concat(contextId) : name;\n}\nexport function parseNodeName(name, context) {\n  if (name === '') {\n    return ['', 0, undefined];\n  }\n  var isCacheEnabled = context != null && context.parseNodeNameCache != null;\n  if (isCacheEnabled) {\n    var cachedResult = context.parseNodeNameCache.get(name);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n  }\n  var parts = name.split(':');\n  var result;\n  if (parts.length === 1) {\n    result = [name, 0, undefined];\n  } else {\n    var nodeName = parts[0];\n    var outputName = parts.length === 3 ? parts[1] : undefined;\n    var index = Number(parts[parts.length - 1]);\n    result = [nodeName, index, outputName];\n  }\n  if (isCacheEnabled) {\n    context.parseNodeNameCache.set(name, result);\n  }\n  return result;\n}\nexport function split(arr, size) {\n  var res = [];\n  for (var i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  var pad = getParamValue('pad', node, tensorMap, context);\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    var explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    for (var i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n    return explicitPadding;\n  }\n  return pad;\n}\n/**\r\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\r\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\r\n *  internally they use a tensor as the id for TensorArray and TensorList, and\r\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\r\n * These id tensors have been marked as kept in the backend, we need avoid clone\r\n * them in order to create new Tensor.id.\r\n * @param tensor\r\n */\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : clone(tensor);\n}","map":{"version":3,"names":["clone","util","getParamValue","paramName","node","tensorMap","context","resourceManager","inputParam","inputParams","inputIndexStart","undefined","start","end","inputIndexEnd","shiftedStart","inputNames","length","type","getTensor","inputs","slice","filter","_name","index","_a","op","map","name","tensor","data","dataSync","toNestedArray","shape","attrParam","attrParams","value","tensorsMap","_parseNodeName","parseNodeName","_parseNodeName2","_slicedToArray","nodeName","getHashTableHandleByName","contextId","currentContextIds","find","getNodeNameWithContextId","getTensorsForCurrentContext","currentContextId","getNodeNameAndIndex","inputName","_parseNodeName3","_parseNodeName4","outputName","concat","isCacheEnabled","parseNodeNameCache","cachedResult","get","parts","split","result","Number","set","arr","size","res","i","push","getPadding","pad","explicitPadding","cloneTensor","kept"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\operations\\executors\\utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {clone, Tensor, util} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {ResourceManager} from '../../executor/resource_manager';\nimport {Node, ValueType} from '../types';\n\nexport function getParamValue(\n    paramName: string, node: Node, tensorMap: NamedTensorsMap,\n    context: ExecutionContext, resourceManager?: ResourceManager): ValueType {\n  const inputParam = node.inputParams[paramName];\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ?\n        undefined :\n        (inputParam.inputIndexEnd === undefined ? start + 1 :\n                                                  inputParam.inputIndexEnd);\n    const shiftedStart = start < 0 ? node.inputNames.length + start : start;\n    if (inputParam.type === 'tensor') {\n      return getTensor(\n          node.inputNames[shiftedStart], tensorMap, context, resourceManager);\n    }\n    if (inputParam.type === 'tensors') {\n      // TODO(mattSoulanille): This filters out NoOp nodes during execution, but\n      // these should really never be in the execution graph in the first place.\n      // They're necessary for ordering the graph, but should not be visible\n      // during execution. Perhaps have different sets of children, one for\n      // control dependencies and another for real dependencies.\n      const inputs = node.inputs.slice(start, end);\n      const inputNames = node.inputNames.slice(start, end)\n        .filter((_name, index) => inputs[index]?.op !== 'NoOp');\n\n      return inputNames.map(\n          name => getTensor(name, tensorMap, context, resourceManager));\n    }\n    const tensor = getTensor(\n        node.inputNames[shiftedStart], tensorMap, context, resourceManager);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ?\n        data[0] :\n        util.toNestedArray(tensor.shape, data);\n  }\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nexport function getTensor(\n    name: string, tensorsMap: NamedTensorsMap, context: ExecutionContext,\n    resourceManager?: ResourceManager): Tensor {\n  const [nodeName, index] = parseNodeName(name, context);\n\n  if (resourceManager != null) {\n    const tensor = resourceManager.getHashTableHandleByName(nodeName);\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n\n  return contextId !== undefined ?\n      tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :\n      undefined;\n}\n\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nexport function getTensorsForCurrentContext(\n    name: string, tensorsMap: NamedTensorsMap,\n    context: ExecutionContext): Tensor[] {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n\n/**\n * Returns the node name, outputName and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n * If the input name contains output name i.e. StringSplit:indices:0, it will\n * return ['StringSplit', 0, 'indices'].\n */\nexport function getNodeNameAndIndex(\n    inputName: string, context?: ExecutionContext): [string, number, string] {\n  const [nodeName, index, outputName] = parseNodeName(inputName, context);\n\n  return [\n    getNodeNameWithContextId(nodeName, context && context.currentContextId),\n    index, outputName\n  ];\n}\n\nfunction getNodeNameWithContextId(name: string, contextId?: string): string {\n  return !!contextId ? `${name}-${contextId}` : name;\n}\n\nexport function parseNodeName(\n    name: string, context?: ExecutionContext): [string, number, string?] {\n  if (name === '') {\n    return ['', 0, undefined];\n  }\n\n  const isCacheEnabled = context != null && context.parseNodeNameCache != null;\n  if (isCacheEnabled) {\n    const cachedResult = context.parseNodeNameCache.get(name);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n  }\n  const parts = name.split(':');\n  let result: [string, number, string?];\n  if (parts.length === 1) {\n    result = [name, 0, undefined];\n  } else {\n    const nodeName = parts[0];\n    const outputName = parts.length === 3 ? parts[1] : undefined;\n    const index = Number(parts[parts.length - 1]);\n    result = [nodeName, index, outputName];\n  }\n  if (isCacheEnabled) {\n    context.parseNodeNameCache.set(name, result);\n  }\n  return result;\n}\n\nexport function split(arr: number[], size: number) {\n  const res = [];\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n  return res;\n}\nexport function getPadding(\n    node: Node, tensorMap: NamedTensorsMap,\n    context: ExecutionContext): ValueType {\n  let pad = getParamValue('pad', node, tensorMap, context);\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding: [\n      [number, number], [number, number], [number, number], [number, number]\n    ] = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = (pad as number[])[i * 2];\n      explicitPadding[i][1] = (pad as number[])[i * 2 + 1];\n    }\n    return explicitPadding;\n  }\n  return pad;\n}\n\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\nexport function cloneTensor(tensor: Tensor): Tensor {\n  return tensor.kept ? tensor : clone(tensor);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}