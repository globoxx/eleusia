{"ast":null,"code":"import _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nvar PassthroughLoader = /*#__PURE__*/function () {\n  function PassthroughLoader(modelArtifacts) {\n    _classCallCheck(this, PassthroughLoader);\n    this.modelArtifacts = modelArtifacts;\n  }\n  _createClass(PassthroughLoader, [{\n    key: \"load\",\n    value: function load() {\n      return this.modelArtifacts;\n    }\n  }]);\n  return PassthroughLoader;\n}();\nvar PassthroughSaver = /*#__PURE__*/function () {\n  function PassthroughSaver(saveHandler) {\n    _classCallCheck(this, PassthroughSaver);\n    this.saveHandler = saveHandler;\n  }\n  _createClass(PassthroughSaver, [{\n    key: \"save\",\n    value: function save(modelArtifacts) {\n      return this.saveHandler(modelArtifacts);\n    }\n  }]);\n  return PassthroughSaver;\n}();\nvar PassthroughAsync = /*#__PURE__*/_createClass(function PassthroughAsync(handler) {\n  _classCallCheck(this, PassthroughAsync);\n  if (handler.load) {\n    this.load = function () {\n      return Promise.resolve(handler.load());\n    };\n  }\n  if (handler.save) {\n    this.save = function (modelArtifacts) {\n      return Promise.resolve(handler.save(modelArtifacts));\n    };\n  }\n});\n/**\r\n * Creates an IOHandler that loads model artifacts from memory.\r\n *\r\n * When used in conjunction with `tf.loadLayersModel`, an instance of\r\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\r\n *\r\n * ```js\r\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\r\n *     modelTopology, weightSpecs, weightData));\r\n * ```\r\n *\r\n * @param modelArtifacts a object containing model topology (i.e., parsed from\r\n *   the JSON format).\r\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\r\n *   names, shapes, types, and quantization of the weight data. Optional.\r\n * @param weightData A single `ArrayBuffer` containing the weight data,\r\n *   concatenated in the order described by the weightSpecs. Optional.\r\n * @param trainingConfig Model training configuration. Optional.\r\n *\r\n * @returns A passthrough `IOHandler` that simply loads the provided data.\r\n */\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  var args = arguments;\n  return new PassthroughAsync(fromMemorySync.apply(void 0, _toConsumableArray(args)));\n}\n/**\r\n * Creates an IOHandler that loads model artifacts from memory.\r\n *\r\n * When used in conjunction with `tf.loadLayersModel`, an instance of\r\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\r\n *\r\n * ```js\r\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\r\n *     modelTopology, weightSpecs, weightData));\r\n * ```\r\n *\r\n * @param modelArtifacts a object containing model topology (i.e., parsed from\r\n *   the JSON format).\r\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\r\n *   names, shapes, types, and quantization of the weight data. Optional.\r\n * @param weightData A single `ArrayBuffer` containing the weight data,\r\n *   concatenated in the order described by the weightSpecs. Optional.\r\n * @param trainingConfig Model training configuration. Optional.\r\n *\r\n * @returns A passthrough `IOHandlerSync` that simply loads the provided data.\r\n */\nexport function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  if (arguments.length === 1) {\n    var isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({\n        modelTopology: modelArtifacts\n      });\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts,\n      weightSpecs: weightSpecs,\n      weightData: weightData,\n      trainingConfig: trainingConfig\n    });\n  }\n}\n/**\r\n * Creates an IOHandler that passes saved model artifacts to a callback.\r\n *\r\n * ```js\r\n * function handleSave(artifacts) {\r\n *   // ... do something with the artifacts ...\r\n *   return {modelArtifactsInfo: {...}, ...};\r\n * }\r\n *\r\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\r\n * ```\r\n *\r\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\r\n *     promise that resolves to a `SaveResult`.\r\n */\nexport function withSaveHandler(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}\n/**\r\n * Creates an IOHandlerSync that passes saved model artifacts to a callback.\r\n *\r\n * ```js\r\n * function handleSave(artifacts) {\r\n *   // ... do something with the artifacts ...\r\n *   return {modelArtifactsInfo: {...}, ...};\r\n * }\r\n *\r\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\r\n * ```\r\n *\r\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\r\n *     `SaveResult`.\r\n */\nexport function withSaveHandlerSync(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}","map":{"version":3,"names":["PassthroughLoader","modelArtifacts","_classCallCheck","_createClass","key","value","load","PassthroughSaver","saveHandler","save","PassthroughAsync","handler","Promise","resolve","fromMemory","weightSpecs","weightData","trainingConfig","args","arguments","fromMemorySync","apply","_toConsumableArray","length","isModelArtifacts","modelTopology","console","warn","withSaveHandler","withSaveHandlerSync"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\io\\passthrough.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * IOHandlers that pass through the in-memory ModelArtifacts format.\n */\n\nimport {IOHandler, IOHandlerSync, LoadHandler, ModelArtifacts, SaveHandler, SaveResult, TrainingConfig, WeightData, WeightsManifestEntry} from './types';\n\nclass PassthroughLoader implements IOHandlerSync {\n  constructor(private readonly modelArtifacts?: ModelArtifacts) {}\n\n  load(): ModelArtifacts {\n    return this.modelArtifacts;\n  }\n}\n\nclass PassthroughSaver<R extends SaveResult | Promise<SaveResult>> {\n  constructor(\n    private readonly saveHandler: (artifacts: ModelArtifacts) => R) {}\n\n  save(modelArtifacts: ModelArtifacts): R {\n    return this.saveHandler(modelArtifacts);\n  }\n}\n\nclass PassthroughAsync implements IOHandler {\n  load?: LoadHandler;\n  save?: SaveHandler;\n\n  constructor(handler: IOHandlerSync) {\n    if (handler.load) {\n      this.load = () => Promise.resolve(handler.load());\n    }\n    if (handler.save) {\n      this.save = (modelArtifacts: ModelArtifacts) =>\n        Promise.resolve(handler.save(modelArtifacts));\n    }\n  }\n}\n\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data. Optional.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs. Optional.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\nexport function fromMemory(\n    modelArtifacts: {}|ModelArtifacts, weightSpecs?: WeightsManifestEntry[],\n    weightData?: WeightData, trainingConfig?: TrainingConfig): IOHandler {\n\n  const args = arguments as unknown as Parameters<typeof fromMemory>;\n  return new PassthroughAsync(fromMemorySync(...args));\n}\n\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data. Optional.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs. Optional.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandlerSync` that simply loads the provided data.\n */\nexport function fromMemorySync(\n    modelArtifacts: {}|ModelArtifacts, weightSpecs?: WeightsManifestEntry[],\n    weightData?: WeightData, trainingConfig?: TrainingConfig): IOHandlerSync {\n  if (arguments.length === 1) {\n    const isModelArtifacts =\n        (modelArtifacts as ModelArtifacts).modelTopology != null ||\n        (modelArtifacts as ModelArtifacts).weightSpecs != null;\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts as ModelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn(\n          'Please call tf.io.fromMemory() with only one argument. ' +\n          'The argument should be of type ModelArtifacts. ' +\n          'The multi-argument signature of tf.io.fromMemory() has been ' +\n          'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({modelTopology: modelArtifacts as {}});\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn(\n        'Please call tf.io.fromMemory() with only one argument. ' +\n        'The argument should be of type ModelArtifacts. ' +\n        'The multi-argument signature of tf.io.fromMemory() has been ' +\n        'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts as {},\n      weightSpecs,\n      weightData,\n      trainingConfig\n    });\n  }\n}\n\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     promise that resolves to a `SaveResult`.\n */\nexport function withSaveHandler(\n    saveHandler: (artifacts: ModelArtifacts) =>\n        Promise<SaveResult>): IOHandler {\n  return new PassthroughSaver(saveHandler);\n}\n\n/**\n * Creates an IOHandlerSync that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\nexport function withSaveHandlerSync(\n    saveHandler: (artifacts: ModelArtifacts) => SaveResult): IOHandlerSync {\n  return new PassthroughSaver<SaveResult>(saveHandler);\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;AAAA,IAuBMA,iBAAiB;EACrB,SAAAA,kBAA6BC,cAA+B;IAAAC,eAAA,OAAAF,iBAAA;IAA/B,KAAAC,cAAc,GAAdA,cAAc;EAAoB;EAACE,YAAA,CAAAH,iBAAA;IAAAI,GAAA;IAAAC,KAAA,EAEhE,SAAAC,KAAA,EAAI;MACF,OAAO,IAAI,CAACL,cAAc;IAC5B;EAAC;EAAA,OAAAD,iBAAA;AAAA;AAAA,IAGGO,gBAAgB;EACpB,SAAAA,iBACmBC,WAA6C;IAAAN,eAAA,OAAAK,gBAAA;IAA7C,KAAAC,WAAW,GAAXA,WAAW;EAAqC;EAACL,YAAA,CAAAI,gBAAA;IAAAH,GAAA;IAAAC,KAAA,EAEpE,SAAAI,KAAKR,cAA8B;MACjC,OAAO,IAAI,CAACO,WAAW,CAACP,cAAc,CAAC;IACzC;EAAC;EAAA,OAAAM,gBAAA;AAAA;AAAA,IAGGG,gBAAgB,gBAAAP,YAAA,CAIpB,SAAAO,iBAAYC,OAAsB;EAAAT,eAAA,OAAAQ,gBAAA;EAChC,IAAIC,OAAO,CAACL,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,GAAG;MAAA,OAAMM,OAAO,CAACC,OAAO,CAACF,OAAO,CAACL,IAAI,EAAE,CAAC;IAAA;;EAEnD,IAAIK,OAAO,CAACF,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,GAAG,UAACR,cAA8B;MAAA,OACzCW,OAAO,CAACC,OAAO,CAACF,OAAO,CAACF,IAAI,CAACR,cAAc,CAAC,CAAC;IAAA;;AAEnD,CAAC;AAGH;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUa,UAAUA,CACtBb,cAAiC,EAAEc,WAAoC,EACvEC,UAAuB,EAAEC,cAA+B;EAE1D,IAAMC,IAAI,GAAGC,SAAqD;EAClE,OAAO,IAAIT,gBAAgB,CAACU,cAAc,CAAAC,KAAA,SAAAC,kBAAA,CAAIJ,IAAI,EAAC,CAAC;AACtD;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUE,cAAcA,CAC1BnB,cAAiC,EAAEc,WAAoC,EACvEC,UAAuB,EAAEC,cAA+B;EAC1D,IAAIE,SAAS,CAACI,MAAM,KAAK,CAAC,EAAE;IAC1B,IAAMC,gBAAgB,GACjBvB,cAAiC,CAACwB,aAAa,IAAI,IAAI,IACvDxB,cAAiC,CAACc,WAAW,IAAI,IAAI;IAC1D,IAAIS,gBAAgB,EAAE;MACpB,OAAO,IAAIxB,iBAAiB,CAACC,cAAgC,CAAC;KAC/D,MAAM;MACL;MACA;MACAyB,OAAO,CAACC,IAAI,CACR,yDAAyD,GACzD,iDAAiD,GACjD,8DAA8D,GAC9D,qDAAqD,CAAC;MAC1D,OAAO,IAAI3B,iBAAiB,CAAC;QAACyB,aAAa,EAAExB;MAAoB,CAAC,CAAC;;GAEtE,MAAM;IACL;IACA;IACAyB,OAAO,CAACC,IAAI,CACR,yDAAyD,GACzD,iDAAiD,GACjD,8DAA8D,GAC9D,qDAAqD,CAAC;IAC1D,OAAO,IAAI3B,iBAAiB,CAAC;MAC3ByB,aAAa,EAAExB,cAAoB;MACnCc,WAAW,EAAXA,WAAW;MACXC,UAAU,EAAVA,UAAU;MACVC,cAAc,EAAdA;KACD,CAAC;;AAEN;AAEA;;;;;;;;;;;;;;;AAeA,OAAM,SAAUW,eAAeA,CAC3BpB,WACuB;EACzB,OAAO,IAAID,gBAAgB,CAACC,WAAW,CAAC;AAC1C;AAEA;;;;;;;;;;;;;;;AAeA,OAAM,SAAUqB,mBAAmBA,CAC/BrB,WAAsD;EACxD,OAAO,IAAID,gBAAgB,CAAaC,WAAW,CAAC;AACtD"},"metadata":{},"sourceType":"module","externalDependencies":[]}