{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\r\n * Print the summary of a LayersModel object.\r\n *\r\n * @param model tf.LayersModel instance.\r\n * @param lineLength Total length of printed lines. Set this to adapt to the\r\n *   display to different terminal or console sizes.\r\n * @param positions Relative or absolute positions of log elements in each\r\n *   line. Each number corresponds to right-most (i.e., ending) position of a\r\n *   column.\r\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\r\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\r\n * @param printFn Print function to use.\r\n *   It will be called on each line of the summary. You can provide a custom\r\n *   function in order to capture the string summary. Defaults to `console.log`.\r\n */\nexport function printSummary(model, lineLength, positions) {\n  var printFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;\n  var sequentialLike = isModelSequentialLike(model);\n  // Header names for different log elements.\n  var toDisplay = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n  if (sequentialLike) {\n    lineLength = lineLength || 90;\n    positions = positions || [0.32, 0.61, 0.89, 1];\n  } else {\n    lineLength = lineLength || 115;\n    positions = positions || [0.24, 0.48, 0.70, 0.80, 1];\n    // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(function (p) {\n      return Math.floor(lineLength * p);\n    });\n  }\n  var relevantNodes;\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n    for (var depth in model.nodesByDepth) {\n      var _relevantNodes;\n      (_relevantNodes = relevantNodes).push.apply(_relevantNodes, _toConsumableArray(model.nodesByDepth[depth]));\n    }\n  }\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n  var layers = model.layers;\n  for (var i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n    }\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  }\n  // tslint:disable-next-line:no-any\n  model.checkTrainableWeightsConsistency();\n  var trainableCount = countTrainableParams(model);\n  var nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n  printFn(\"Total params: \".concat(trainableCount + nonTrainableCount));\n  printFn(\"Trainable params: \".concat(trainableCount));\n  printFn(\"Non-trainable params: \".concat(nonTrainableCount));\n  printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n  var trainableCount;\n  // tslint:disable:no-any\n  if (model.collectedTrainableWeights != null) {\n    trainableCount = countParamsInWeights(model.collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  }\n  // tslint:enable:no-any\n  return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n  var sequentialLike = true;\n  var nodesByDepth = [];\n  var nodes = [];\n  for (var depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n  for (var _i = 0, _nodesByDepth = nodesByDepth; _i < _nodesByDepth.length; _i++) {\n    var depthNodes = _nodesByDepth[_i];\n    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n    nodes.push.apply(nodes, _toConsumableArray(depthNodes));\n  }\n  if (sequentialLike) {\n    // Search for shared layers.\n    var _iterator = _createForOfIteratorHelper(model.layers),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var layer = _step.value;\n        var flag = false;\n        var _iterator2 = _createForOfIteratorHelper(layer.inboundNodes),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var node = _step2.value;\n            if (nodes.indexOf(node) !== -1) {\n              if (flag) {\n                sequentialLike = false;\n                break;\n              } else {\n                flag = true;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (!sequentialLike) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return sequentialLike;\n}\nfunction printRow(fields, positions) {\n  var printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n  var line = '';\n  for (var i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n  printFn(line);\n}\n/**\r\n * Prints a summary for a single Layer, without connectivity information.\r\n *\r\n * @param layer: Layer instance to print.\r\n */\nfunction printLayerSummary(layer, positions,\n// tslint:disable-next-line:no-any\nprintFn) {\n  var outputShape;\n  var inputShape;\n  try {\n    inputShape = layer.inboundNodes.map(function (x) {\n      return JSON.stringify(x.inputShapes);\n    }).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n  var name = layer.name;\n  var className = layer.getClassName();\n  var fields = [\"\".concat(name, \" (\").concat(className, \")\"), inputShape, outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n/**\r\n * Prints a summary for a single Layer, with connectivity information.\r\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes,\n// tslint:disable-next-line:no-any\nprintFn) {\n  var outputShape;\n  var inputShape;\n  try {\n    inputShape = layer.inboundNodes.map(function (x) {\n      return JSON.stringify(x.inputShapes);\n    }).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n  var connections = [];\n  var _iterator3 = _createForOfIteratorHelper(layer.inboundNodes),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var node = _step3.value;\n      if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {\n        continue;\n      }\n      for (var _i2 = 0; _i2 < node.inboundLayers.length; ++_i2) {\n        var inboundLayer = node.inboundLayers[_i2].name;\n        var inboundLayerIndex = node.nodeIndices[_i2];\n        var inboundTensorIndex = node.tensorIndices[_i2];\n        connections.push(\"\".concat(inboundLayer, \"[\").concat(inboundLayerIndex, \"][\").concat(inboundTensorIndex, \"]\"));\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var name = layer.name;\n  var className = layer.getClassName();\n  var firstConnection = connections.length === 0 ? '' : connections[0];\n  var fields = [\"\".concat(name, \" (\").concat(className, \")\"), inputShape, outputShape, layer.countParams().toString(), firstConnection];\n  printRow(fields, positions, printFn);\n  for (var i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', '', connections[i]], positions, printFn);\n  }\n}","map":{"version":3,"names":["countParamsInWeights","printSummary","model","lineLength","positions","printFn","arguments","length","undefined","console","log","sequentialLike","isModelSequentialLike","toDisplay","map","p","Math","floor","relevantNodes","push","depth","nodesByDepth","_relevantNodes","apply","_toConsumableArray","repeat","printRow","layers","i","printLayerSummary","printLayerSummaryWithConnections","checkTrainableWeightsConsistency","trainableCount","countTrainableParams","nonTrainableCount","nonTrainableWeights","concat","collectedTrainableWeights","trainableWeights","nodes","_i","_nodesByDepth","depthNodes","inboundLayers","_iterator","_createForOfIteratorHelper","_step","s","n","done","layer","value","flag","_iterator2","inboundNodes","_step2","node","indexOf","err","e","f","fields","line","slice","outputShape","inputShape","x","JSON","stringify","inputShapes","join","name","className","getClassName","countParams","toString","connections","_iterator3","_step3","inboundLayer","inboundLayerIndex","nodeIndices","inboundTensorIndex","tensorIndices","firstConnection"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-layers\\src\\utils\\layer_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {Container} from '../engine/container';\nimport {Layer, Node} from '../engine/topology';\nimport {countParamsInWeights} from './variable_utils';\n\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(\n    model: Container, lineLength?: number, positions?: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void =\n        console.log): void {\n  const sequentialLike = isModelSequentialLike(model);\n\n  // Header names for different log elements.\n  const toDisplay: string[] = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n  if (sequentialLike) {\n    lineLength = lineLength || 90;\n    positions = positions || [0.32, 0.61, 0.89, 1];\n  } else {\n    lineLength = lineLength || 115;\n    positions = positions || [0.24, 0.48, 0.70, 0.80, 1];\n    // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(p => Math.floor(lineLength * p));\n  }\n\n  let relevantNodes: Node[];\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n    for (const depth in model.nodesByDepth) {\n      relevantNodes.push(...model.nodesByDepth[depth]);\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n\n  const layers = model.layers;\n  for (let i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(\n          layers[i], positions, relevantNodes, printFn);\n    }\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  }\n\n  // tslint:disable-next-line:no-any\n  (model as any).checkTrainableWeightsConsistency();\n\n  const trainableCount = countTrainableParams(model);\n  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n\n  printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n  printFn(`Trainable params: ${trainableCount}`);\n  printFn(`Non-trainable params: ${nonTrainableCount}`);\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model: Container): number {\n  let trainableCount: number;\n  // tslint:disable:no-any\n  if ((model as any).collectedTrainableWeights != null) {\n    trainableCount =\n        countParamsInWeights((model as any).collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  }\n  // tslint:enable:no-any\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model: Container): boolean {\n  let sequentialLike = true;\n  const nodesByDepth: Node[][] = [];\n  const nodes: Node[] = [];\n  for (const depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n  for (const depthNodes of nodesByDepth) {\n    if (depthNodes.length > 1 ||\n        depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n    nodes.push(...depthNodes);\n  }\n  if (sequentialLike) {\n    // Search for shared layers.\n    for (const layer of model.layers) {\n      let flag = false;\n      for (const node of layer.inboundNodes) {\n        if (nodes.indexOf(node) !== -1) {\n          if (flag) {\n            sequentialLike = false;\n            break;\n          } else {\n            flag = true;\n          }\n        }\n      }\n      if (!sequentialLike) {\n        break;\n      }\n    }\n  }\n  return sequentialLike;\n}\n\nfunction printRow(\n    fields: string[], positions: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void = console.log) {\n  let line = '';\n  for (let i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n  printFn(line);\n}\n\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(\n    layer: Layer, positions: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void) {\n  let outputShape: string;\n  let inputShape: string;\n\n  try {\n    inputShape = (layer.inboundNodes.map(\n      x => JSON.stringify(x.inputShapes)\n    )).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const fields: string[] =\n      [`${name} (${className})`, inputShape,\n      outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(\n    layer: Layer, positions: number[], relevantNodes: Node[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void) {\n  let outputShape: string;\n  let inputShape: string;\n\n  try {\n    inputShape = (layer.inboundNodes.map(\n      x => JSON.stringify(x.inputShapes)\n    )).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const connections: string[] = [];\n  for (const node of layer.inboundNodes) {\n    if (relevantNodes != null && relevantNodes.length > 0 &&\n        relevantNodes.indexOf(node) === -1) {\n      continue;\n    }\n    for (let i = 0; i < node.inboundLayers.length; ++i) {\n      const inboundLayer = node.inboundLayers[i].name;\n      const inboundLayerIndex = node.nodeIndices[i];\n      const inboundTensorIndex = node.tensorIndices[i];\n      connections.push(\n          `${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n    }\n  }\n  const name = layer.name;\n  const className = layer.getClassName();\n  const firstConnection = connections.length === 0 ? '' : connections[0];\n  const fields: string[] = [\n    `${name} (${className})`, inputShape,\n    outputShape, layer.countParams().toString(),\n    firstConnection\n  ];\n\n  printRow(fields, positions, printFn);\n  for (let i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', '', connections[i]], positions, printFn);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}