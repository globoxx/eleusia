{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nfunction inTopKAsync_(_x, _x2) {\n  return _inTopKAsync_.apply(this, arguments);\n}\nfunction _inTopKAsync_() {\n  _inTopKAsync_ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(predictions, targets) {\n    var k,\n      $predictions,\n      $targets,\n      lastDim,\n      predictionsVals,\n      targetsVals,\n      batch,\n      size,\n      precision,\n      b,\n      offset,\n      vals,\n      valAndInd,\n      i,\n      _i,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          k = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;\n          $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n          $targets = convertToTensor(targets, 'targets', 'inTopK');\n          assert($predictions.rank > 1, function () {\n            return 'inTopK() expects the predictions to be of rank 2 or higher, ' + \"but got \".concat($predictions.rank);\n          });\n          assert($predictions.rank - 1 === $targets.rank, function () {\n            return \"predictions rank should be 1 larger than \" + \"targets rank, but got predictions rank \" + \"\".concat($predictions.rank, \" and targets rank \").concat($targets.rank);\n          });\n          assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, \"predictions's shape should be align with the targets' shape, \" + 'except the last dimension.');\n          lastDim = $predictions.shape[$predictions.shape.length - 1];\n          assert(k > 0 && k <= lastDim, function () {\n            return \"'k' passed to inTopK() must be > 0 && <= the predictions last \" + \"dimension (\".concat(lastDim, \"), but got \").concat(k);\n          });\n          _context.next = 10;\n          return $predictions.data();\n        case 10:\n          predictionsVals = _context.sent;\n          _context.next = 13;\n          return $targets.data();\n        case 13:\n          targetsVals = _context.sent;\n          // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n          // and look up topK along lastDim.\n          batch = predictionsVals.length / lastDim, size = lastDim;\n          precision = getTypedArrayFromDType('bool', batch);\n          b = 0;\n        case 17:\n          if (!(b < batch)) {\n            _context.next = 35;\n            break;\n          }\n          offset = b * size;\n          vals = predictionsVals.subarray(offset, offset + size);\n          valAndInd = [];\n          for (i = 0; i < vals.length; i++) {\n            valAndInd.push({\n              value: vals[i],\n              index: i\n            });\n          }\n          valAndInd.sort(function (a, b) {\n            return b.value - a.value;\n          });\n          precision[b] = 0;\n          _i = 0;\n        case 25:\n          if (!(_i < k)) {\n            _context.next = 32;\n            break;\n          }\n          if (!(valAndInd[_i].index === targetsVals[b])) {\n            _context.next = 29;\n            break;\n          }\n          precision[b] = 1;\n          return _context.abrupt(\"break\", 32);\n        case 29:\n          _i++;\n          _context.next = 25;\n          break;\n        case 32:\n          b++;\n          _context.next = 17;\n          break;\n        case 35:\n          if (predictions !== $predictions) {\n            $predictions.dispose();\n          }\n          if (targets !== $targets) {\n            $targets.dispose();\n          }\n          // Output precision has the same shape as targets.\n          return _context.abrupt(\"return\", tensor(precision, $targets.shape, 'bool'));\n        case 38:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _inTopKAsync_.apply(this, arguments);\n}\nexport var inTopKAsync = inTopKAsync_;","map":{"version":3,"names":["convertToTensor","assert","assertShapesMatch","getTypedArrayFromDType","tensor","inTopKAsync_","_x","_x2","_inTopKAsync_","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","predictions","targets","k","$predictions","$targets","lastDim","predictionsVals","targetsVals","batch","size","precision","b","offset","vals","valAndInd","i","_i","_args","wrap","_callee$","_context","prev","next","length","undefined","rank","concat","shape","slice","data","sent","subarray","push","value","index","sort","a","abrupt","dispose","stop","inTopKAsync"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\ops\\in_top_k.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, assertShapesMatch, getTypedArrayFromDType} from '../util';\nimport {tensor} from './tensor';\n\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_<T extends Tensor, U extends Tensor>(\n    predictions: T|TensorLike, targets: U|TensorLike, k = 1): Promise<U> {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n\n  assert(\n      $predictions.rank > 1,\n      () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n          `but got ${$predictions.rank}`);\n  assert(\n      $predictions.rank - 1 === $targets.rank,\n      () => `predictions rank should be 1 larger than ` +\n          `targets rank, but got predictions rank ` +\n          `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch(\n      $predictions.shape.slice(0, $predictions.shape.length - 1),\n      $targets.shape,\n      `predictions's shape should be align with the targets' shape, ` +\n          'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(\n      k > 0 && k <= lastDim,\n      () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n          `dimension (${lastDim}), but got ${k}`);\n\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data();\n\n  // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd: Array<{value: number, index: number}> = [];\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({value: vals[i], index: i});\n    }\n    valAndInd.sort((a, b) => b.value - a.value);\n\n    precision[b] = 0;\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n  if (targets !== $targets) {\n    $targets.dispose();\n  }\n\n  // Output precision has the same shape as targets.\n  return tensor(precision, $targets.shape, 'bool') as U;\n}\n\nexport const inTopKAsync = inTopKAsync_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}