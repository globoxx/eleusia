{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import webgl flags.\nimport './flags_webgl';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, nextFrame, scalar, tidy, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { DecodeMatrixProgram } from './decode_matrix_gpu';\nimport { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';\nimport { EncodeFloatProgram } from './encode_float_gpu';\nimport { EncodeFloatPackedProgram } from './encode_float_packed_gpu';\nimport { EncodeMatrixProgram } from './encode_matrix_gpu';\nimport { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';\nimport { GPGPUContext } from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport { getUniformLocations as _getUniformLocations } from './gpgpu_math';\nimport { simpleAbsImplCPU } from './kernel_utils/shared';\nimport { PackProgram } from './pack_gpu';\nimport { ReshapePackedProgram } from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport { TextureUsage } from './tex_util';\nimport { TextureManager } from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport { UnaryOpProgram } from './unaryop_gpu';\nimport { UnaryOpPackedProgram } from './unaryop_packed_gpu';\nimport { UnpackProgram } from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nvar whereImpl = kernel_impls.whereImpl;\nexport var EPSILON_FLOAT32 = 1e-7;\nexport var EPSILON_FLOAT16 = 1e-4;\nvar binaryCaches = {};\nexport function getBinaryCache(webGLVersion) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nvar CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nvar BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning() {\n  if (env().global.screen == null) {\n    return 1024; // 1 GB.\n  }\n\n  return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\nexport var MathBackendWebGL = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendWebGL, _KernelBackend);\n  var _super = _createSuper(MathBackendWebGL);\n  function MathBackendWebGL(gpuResource) {\n    var _this;\n    _classCallCheck(this, MathBackendWebGL);\n    _this = _super.call(this);\n    // Maps data ids that have a pending read operation, to list of subscribers.\n    _this.pendingRead = new WeakMap();\n    // List of data ids that are scheduled for disposal, but are waiting on a\n    // pending read operation.\n    _this.pendingDisposal = new WeakSet();\n    // Used to count the number of 'shallow' sliced tensors that point to the\n    // same data id.\n    _this.dataRefCount = new WeakMap();\n    _this.numBytesInGPU = 0;\n    // Accumulated time spent (including blocking) in uploading data to webgl.\n    _this.uploadWaitMs = 0;\n    // Accumulated time spent (including blocking in downloading data from webgl.\n    _this.downloadWaitMs = 0;\n    // record the last manual GL Flush time.\n    _this.lastGlFlushTime = 0;\n    _this.warnedAboutMemory = false;\n    _this.pendingDeletes = 0;\n    _this.disposed = false;\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n    var newGPGPU;\n    if (gpuResource != null) {\n      if (gpuResource instanceof GPGPUContext) {\n        newGPGPU = gpuResource;\n      } else {\n        var gl = getWebGLContext(env().getNumber('WEBGL_VERSION'), gpuResource);\n        newGPGPU = new GPGPUContext(gl);\n      }\n      _this.binaryCache = {};\n      _this.gpgpuCreatedLocally = false;\n    } else {\n      var _gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      newGPGPU = new GPGPUContext(_gl);\n      _this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      _this.gpgpuCreatedLocally = true;\n    }\n    _this.gpgpu = newGPGPU;\n    _this.canvas = _this.gpgpu.gl.canvas;\n    _this.textureManager = new TextureManager(_this.gpgpu);\n    _this.numMBBeforeWarning = numMBBeforeWarning();\n    _this.texData = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n  _createClass(MathBackendWebGL, [{\n    key: \"nextDataId\",\n    value: function nextDataId() {\n      return MathBackendWebGL.nextDataId++;\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.texData.numDataIds() - this.pendingDeletes;\n    }\n    // Writes a new entry to the data store with a WebGL texture, and registers it\n    // to the texture manager.\n  }, {\n    key: \"writeTexture\",\n    value: function writeTexture(texture, shape, dtype, texHeight, texWidth, channels) {\n      // Temporarily create an tensor info to make the texture compatible with\n      // the runWebGLProgram's input.\n      var input = this.makeTensorInfo(shape, dtype);\n      var inData = this.texData.get(input.dataId);\n      // Even though the input texture could be unpacked or dense packed, it is\n      // always considered as unpacked for EncodeMatrixProgram.\n      inData.isPacked = false;\n      // Bind texture to the input tensor.\n      inData.texture = {\n        texture: texture,\n        texShape: [texHeight, texWidth]\n      };\n      inData.texShape = [texHeight, texWidth];\n      var shapeAs3D = webgl_util.getShapeAs3D(shape);\n      var program = new EncodeMatrixProgram(shapeAs3D, false /* isByteArray */, channels);\n      var output = this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);\n      output.shape = shape;\n      // Unbind the texture from the input tensor to avoid the texture being\n      // released.\n      inData.texture = null;\n      this.disposeIntermediateTensorInfo(input);\n      return output.dataId;\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') || env().getBool('DEBUG')) {\n        this.checkNumericalProblems(values);\n      }\n      if (dtype === 'complex64' && values != null) {\n        throw new Error(\"Cannot write to a complex64 dtype. \" + \"Please use tf.complex(real, imag).\");\n      }\n      var dataId = {\n        id: this.nextDataId()\n      };\n      this.texData.set(dataId, {\n        shape: shape,\n        dtype: dtype,\n        values: values,\n        usage: TextureUsage.UPLOAD,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /** Return refCount of a `TensorData`. */\n  }, {\n    key: \"refCount\",\n    value: function refCount(dataId) {\n      if (this.texData.has(dataId)) {\n        var tensorData = this.texData.get(dataId);\n        return tensorData.refCount;\n      }\n      return 0;\n    }\n    /** Increase refCount of a `TextureData`. */\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var texData = this.texData.get(dataId);\n      texData.refCount++;\n    }\n    /** Decrease refCount of a `TextureData`. */\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.texData.has(dataId)) {\n        var texData = this.texData.get(dataId);\n        texData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype, refCount) {\n      if (env().getBool('DEBUG')) {\n        this.checkNumericalProblems(values);\n      }\n      if (dtype === 'complex64') {\n        throw new Error(\"Cannot write to a complex64 dtype. \" + \"Please use tf.complex(real, imag).\");\n      }\n      this.texData.set(dataId, {\n        shape: shape,\n        dtype: dtype,\n        values: values,\n        usage: TextureUsage.UPLOAD,\n        refCount: refCount\n      });\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      this.disposeData(tensorInfo.dataId);\n    }\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var texData = this.texData.get(dataId);\n      var values = texData.values,\n        dtype = texData.dtype,\n        complexTensorInfos = texData.complexTensorInfos,\n        slice = texData.slice,\n        shape = texData.shape,\n        isPacked = texData.isPacked;\n      // The presence of `slice` indicates this tensor is a shallow slice of a\n      // different tensor, and is using that original tensor's texture. Run\n      // `clone` in order to copy that texture and read from it.\n      if (slice != null) {\n        var program;\n        if (isPacked) {\n          program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n        } else {\n          program = new UnaryOpProgram(shape, unary_op.CLONE);\n        }\n        var res = this.runWebGLProgram(program, [{\n          dataId: dataId,\n          shape: shape,\n          dtype: dtype\n        }], dtype);\n        var data = this.readSync(res.dataId);\n        this.disposeIntermediateTensorInfo(res);\n        return data;\n      }\n      if (values != null) {\n        return this.convertAndCacheOnCPU(dataId);\n      }\n      if (dtype === 'string') {\n        return values;\n      }\n      var shouldTimeProgram = this.activeTimers != null;\n      var start;\n      if (shouldTimeProgram) {\n        start = util.now();\n      }\n      var result;\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      } else {\n        result = this.getValuesFromTexture(dataId);\n      }\n      if (shouldTimeProgram) {\n        this.downloadWaitMs += util.now() - start;\n      }\n      return this.convertAndCacheOnCPU(dataId, result);\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataId) {\n        var _subscribers, texData, values, shape, slice, dtype, complexTensorInfos, isPacked, program, res, data, buffer, tmpDownloadTarget, _this$gpgpu, tmpData, vals, ps, realValues, imagValues, size, gl, dTypeVals, subscribers;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.pendingRead.has(dataId)) {\n                _context.next = 3;\n                break;\n              }\n              _subscribers = this.pendingRead.get(dataId);\n              return _context.abrupt(\"return\", new Promise(function (resolve) {\n                return _subscribers.push(resolve);\n              }));\n            case 3:\n              texData = this.texData.get(dataId);\n              values = texData.values, shape = texData.shape, slice = texData.slice, dtype = texData.dtype, complexTensorInfos = texData.complexTensorInfos, isPacked = texData.isPacked; // The presence of `slice` indicates this tensor is a shallow slice of a\n              // different tensor, and is using that original tensor's texture. Run\n              // `clone` in order to copy that texture and read from it.\n              if (!(slice != null)) {\n                _context.next = 11;\n                break;\n              }\n              if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n              } else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n              }\n              res = this.runWebGLProgram(program, [{\n                dataId: dataId,\n                shape: shape,\n                dtype: dtype\n              }], dtype);\n              data = this.read(res.dataId);\n              this.disposeIntermediateTensorInfo(res);\n              return _context.abrupt(\"return\", data);\n            case 11:\n              if (!(values != null)) {\n                _context.next = 13;\n                break;\n              }\n              return _context.abrupt(\"return\", this.convertAndCacheOnCPU(dataId));\n            case 13:\n              if (!env().getBool('DEBUG')) {\n                _context.next = 16;\n                break;\n              }\n              if (!(!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') && env().getNumber('WEBGL_VERSION') === 2)) {\n                _context.next = 16;\n                break;\n              }\n              throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and \" + \"WEBGL_VERSION=2 not yet supported.\");\n            case 16:\n              buffer = null;\n              if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n                // Possibly copy the texture into a buffer before inserting a fence.\n                tmpDownloadTarget = this.decode(dataId);\n                tmpData = this.texData.get(tmpDownloadTarget.dataId);\n                buffer = (_this$gpgpu = this.gpgpu).createBufferFromTexture.apply(_this$gpgpu, [tmpData.texture.texture].concat(_toConsumableArray(tex_util.getDenseTexShape(shape))));\n              }\n              this.pendingRead.set(dataId, []);\n              if (!(dtype !== 'complex64')) {\n                _context.next = 22;\n                break;\n              }\n              _context.next = 22;\n              return this.gpgpu.createAndWaitForFence();\n            case 22:\n              if (!(dtype === 'complex64')) {\n                _context.next = 31;\n                break;\n              }\n              _context.next = 25;\n              return Promise.all([this.read(complexTensorInfos.real.dataId), this.read(complexTensorInfos.imag.dataId)]);\n            case 25:\n              ps = _context.sent;\n              realValues = ps[0];\n              imagValues = ps[1];\n              vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n              _context.next = 32;\n              break;\n            case 31:\n              if (buffer == null) {\n                vals = this.getValuesFromTexture(dataId);\n              } else {\n                size = util.sizeFromShape(shape);\n                vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n              }\n            case 32:\n              if (tmpDownloadTarget != null) {\n                this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n              }\n              if (buffer != null) {\n                gl = this.gpgpu.gl;\n                webgl_util.callAndCheck(gl, function () {\n                  return gl.deleteBuffer(buffer);\n                });\n              }\n              dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n              subscribers = this.pendingRead.get(dataId);\n              this.pendingRead.delete(dataId);\n              // Notify all pending reads.\n              subscribers.forEach(function (resolve) {\n                return resolve(dTypeVals);\n              });\n              if (this.pendingDisposal.has(dataId)) {\n                this.pendingDisposal.delete(dataId);\n                if (this.disposeData(dataId)) {\n                  engine().removeDataId(dataId, this);\n                }\n                this.pendingDeletes--;\n              }\n              return _context.abrupt(\"return\", dTypeVals);\n            case 40:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n    /**\n     * Read tensor to a new texture that is densely packed for ease of use.\n     * @param dataId The source tensor.\n     * @param options\n     *     customTexShape: Optional. If set, will use the user defined texture\n     *     shape to create the texture.\n     */\n  }, {\n    key: \"readToGPU\",\n    value: function readToGPU(dataId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var texData = this.texData.get(dataId);\n      var values = texData.values,\n        shape = texData.shape,\n        slice = texData.slice,\n        dtype = texData.dtype,\n        isPacked = texData.isPacked,\n        texture = texData.texture;\n      if (dtype === 'complex64') {\n        throw new Error('Does not support reading texture for complex64 dtype.');\n      }\n      // The presence of `slice` indicates this tensor is a shallow slice of a\n      // different tensor, and is using that original tensor's texture. Run\n      // `clone` in order to copy that texture and read from it.\n      if (slice != null) {\n        var program;\n        if (isPacked) {\n          program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n        } else {\n          program = new UnaryOpProgram(shape, unary_op.CLONE);\n        }\n        var res = this.runWebGLProgram(program, [{\n          dataId: dataId,\n          shape: shape,\n          dtype: dtype\n        }], dtype);\n        var gpuResouorce = this.readToGPU(res, options);\n        this.disposeIntermediateTensorInfo(res);\n        return gpuResouorce;\n      }\n      if (texture == null) {\n        if (values != null) {\n          throw new Error('Data is not on GPU but on CPU.');\n        } else {\n          throw new Error('There is no data on GPU or CPU.');\n        }\n      }\n      // Decode the texture so that it is stored densely (using four channels).\n      var tmpTarget = this.decode(dataId, options.customTexShape);\n      // Make engine track this tensor, so that we can dispose it later.\n      var tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);\n      var tmpData = this.texData.get(tmpTarget.dataId);\n      return Object.assign({\n        tensorRef: tensorRef\n      }, tmpData.texture);\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          var strings = data.map(function (d) {\n            return util.decodeString(d);\n          });\n          return buffer(t.shape, t.dtype, strings);\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n      return buffer(t.shape, t.dtype, data);\n    }\n  }, {\n    key: \"checkNumericalProblems\",\n    value: function checkNumericalProblems(values) {\n      if (values == null) {\n        return;\n      }\n      for (var i = 0; i < values.length; i++) {\n        var num = values[i];\n        if (!webgl_util.canBeRepresented(num)) {\n          if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n            throw Error(\"The value \".concat(num, \" cannot be represented with your \") + \"current settings. Consider enabling float32 rendering: \" + \"'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n          }\n          throw Error(\"The value \".concat(num, \" cannot be represented on this device.\"));\n        }\n      }\n    }\n  }, {\n    key: \"getValuesFromTexture\",\n    value: function getValuesFromTexture(dataId) {\n      var _this$texData$get = this.texData.get(dataId),\n        shape = _this$texData$get.shape,\n        dtype = _this$texData$get.dtype,\n        isPacked = _this$texData$get.isPacked;\n      var size = util.sizeFromShape(shape);\n      if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n        var _this$gpgpu2;\n        var tmpTarget = this.decode(dataId);\n        var _tmpData = this.texData.get(tmpTarget.dataId);\n        var _vals = (_this$gpgpu2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(_this$gpgpu2, [_tmpData.texture.texture].concat(_toConsumableArray(tex_util.getDenseTexShape(shape)))).subarray(0, size);\n        this.disposeIntermediateTensorInfo(tmpTarget);\n        return _vals;\n      }\n      var shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;\n      var outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n      var program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);\n      var output = this.runWebGLProgram(program, [{\n        shape: outputShape,\n        dtype: dtype,\n        dataId: dataId\n      }], 'float32');\n      var tmpData = this.texData.get(output.dataId);\n      var vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);\n      this.disposeIntermediateTensorInfo(output);\n      return vals;\n    }\n  }, {\n    key: \"timerAvailable\",\n    value: function timerAvailable() {\n      return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n    }\n  }, {\n    key: \"time\",\n    value: function time(f) {\n      var _this2 = this;\n      var oldActiveTimers = this.activeTimers;\n      var newActiveTimers = [];\n      var outerMostTime = false;\n      if (this.programTimersStack == null) {\n        this.programTimersStack = newActiveTimers;\n        outerMostTime = true;\n      } else {\n        this.activeTimers.push(newActiveTimers);\n      }\n      this.activeTimers = newActiveTimers;\n      f();\n      // needing to split these up because util.flatten only accepts certain types\n      var flattenedActiveTimerQueries = util.flatten(this.activeTimers.map(function (d) {\n        return d.query;\n      })).filter(function (d) {\n        return d != null;\n      });\n      var flattenedActiveTimerNames = util.flatten(this.activeTimers.map(function (d) {\n        return d.name;\n      })).filter(function (d) {\n        return d != null;\n      });\n      this.activeTimers = oldActiveTimers;\n      if (outerMostTime) {\n        this.programTimersStack = null;\n      }\n      var res = {\n        uploadWaitMs: this.uploadWaitMs,\n        downloadWaitMs: this.downloadWaitMs,\n        kernelMs: null,\n        wallMs: null // will be filled by the engine\n      };\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var kernelMs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) {\n                _context2.next = 8;\n                break;\n              }\n              _context2.next = 3;\n              return Promise.all(flattenedActiveTimerQueries);\n            case 3:\n              kernelMs = _context2.sent;\n              res['kernelMs'] = util.sum(kernelMs);\n              res['getExtraProfileInfo'] = function () {\n                return kernelMs.map(function (d, i) {\n                  return {\n                    name: flattenedActiveTimerNames[i],\n                    ms: d\n                  };\n                }).map(function (d) {\n                  return \"\".concat(d.name, \": \").concat(d.ms);\n                }).join(', ');\n              };\n              _context2.next = 9;\n              break;\n            case 8:\n              res['kernelMs'] = {\n                error: 'WebGL query timers are not supported in this environment.'\n              };\n            case 9:\n              _this2.uploadWaitMs = 0;\n              _this2.downloadWaitMs = 0;\n              return _context2.abrupt(\"return\", res);\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    }\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        unreliable: false,\n        numBytesInGPU: this.numBytesInGPU,\n        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n        numBytesInGPUFree: this.textureManager.numBytesFree\n      };\n    }\n  }, {\n    key: \"startTimer\",\n    value: function startTimer() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n        return this.gpgpu.beginQuery();\n      }\n      return {\n        startMs: util.now(),\n        endMs: null\n      };\n    }\n  }, {\n    key: \"endTimer\",\n    value: function endTimer(query) {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n        this.gpgpu.endQuery();\n        return query;\n      }\n      query.endMs = util.now();\n      return query;\n    }\n  }, {\n    key: \"getQueryTime\",\n    value: function () {\n      var _getQueryTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(query) {\n        var timerQuery;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.gpgpu.waitForQueryAndGetTime(query));\n            case 2:\n              timerQuery = query;\n              return _context3.abrupt(\"return\", timerQuery.endMs - timerQuery.startMs);\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getQueryTime(_x2) {\n        return _getQueryTime.apply(this, arguments);\n      }\n      return getQueryTime;\n    }()\n    /**\n     * Decrease the RefCount on the dataId and dispose the memory if the dataId\n     * has 0 refCount. If there are pending read on the data, the disposal would\n     * added to the pending delete queue. Return true if the dataId is removed\n     * from backend or the backend does not contain the dataId, false if the\n     * dataId is not removed. Memory may or may not be released even when dataId\n     * is removed, which also depends on dataRefCount, see `releaseGPU`.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.pendingDisposal.has(dataId)) {\n        return false;\n      }\n      // No-op if already disposed.\n      if (!this.texData.has(dataId)) {\n        return true;\n      }\n      // if force flag is set, change refCount to 0, this would ensure disposal\n      // when added to the pendingDisposal queue. Memory may or may not be\n      // released, which also depends on dataRefCount, see `releaseGPU`.\n      if (force) {\n        this.texData.get(dataId).refCount = 0;\n      } else {\n        this.texData.get(dataId).refCount--;\n      }\n      if (!force && this.texData.get(dataId).refCount > 0) {\n        return false;\n      }\n      if (this.pendingRead.has(dataId)) {\n        this.pendingDisposal.add(dataId);\n        this.pendingDeletes++;\n        return false;\n      }\n      this.releaseGPUData(dataId);\n      var _this$texData$get2 = this.texData.get(dataId),\n        complexTensorInfos = _this$texData$get2.complexTensorInfos;\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, force);\n        this.disposeData(complexTensorInfos.imag.dataId, force);\n      }\n      this.texData.delete(dataId);\n      return true;\n    }\n  }, {\n    key: \"releaseGPUData\",\n    value: function releaseGPUData(dataId) {\n      var _this$texData$get3 = this.texData.get(dataId),\n        texture = _this$texData$get3.texture,\n        dtype = _this$texData$get3.dtype,\n        texShape = _this$texData$get3.texShape,\n        usage = _this$texData$get3.usage,\n        isPacked = _this$texData$get3.isPacked,\n        slice = _this$texData$get3.slice;\n      var key = slice && slice.origDataId || dataId;\n      var refCount = this.dataRefCount.get(key);\n      if (refCount > 1) {\n        this.dataRefCount.set(key, refCount - 1);\n      } else {\n        this.dataRefCount.delete(key);\n        if (texture != null) {\n          this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n        }\n      }\n      var texData = this.texData.get(dataId);\n      texData.texture = null;\n      texData.texShape = null;\n      texData.isPacked = false;\n      texData.slice = null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(dataId) {\n      this.uploadToGPU(dataId);\n      return this.texData.get(dataId).texture.texture;\n    }\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n  }, {\n    key: \"getDataInfo\",\n    value: function getDataInfo(dataId) {\n      return this.texData.get(dataId);\n    }\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n  }, {\n    key: \"shouldExecuteOnCPU\",\n    value: function shouldExecuteOnCPU(inputs) {\n      var _this3 = this;\n      var sizeThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CPU_HANDOFF_SIZE_THRESHOLD;\n      return env().getBool('WEBGL_CPU_FORWARD') && inputs.every(function (input) {\n        return _this3.texData.get(input.dataId).texture == null && util.sizeFromShape(input.shape) < sizeThreshold;\n      });\n    }\n  }, {\n    key: \"getGPGPUContext\",\n    value: function getGPGPUContext() {\n      return this.gpgpu;\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      backend_util.warn('tf.where() in webgl locks the UI thread. ' + 'Call tf.whereAsync() instead');\n      var condVals = condition.dataSync();\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"packedUnaryOp\",\n    value: function packedUnaryOp(x, op, dtype) {\n      var program = new UnaryOpPackedProgram(x.shape, op);\n      var outInfo = this.compileAndRun(program, [x], dtype);\n      return engine().makeTensorFromTensorInfo(outInfo);\n    }\n    // TODO(msoulanille) remove this once the backend has been modularized\n    // a copy is needed here to break a circular dependency.\n    // Also remove the op from unary_op.\n  }, {\n    key: \"abs\",\n    value: function abs(x) {\n      // TODO: handle cases when x is complex.\n      if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n        var outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);\n        return this.makeOutput(x.shape, x.dtype, outValues);\n      }\n      if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        return this.packedUnaryOp(x, unary_op.ABS, x.dtype);\n      }\n      var program = new UnaryOpProgram(x.shape, unary_op.ABS);\n      var outInfo = this.compileAndRun(program, [x]);\n      return engine().makeTensorFromTensorInfo(outInfo);\n    }\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var dataId;\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        dataId = this.write(encodedValues, shape, dtype);\n      } else {\n        dataId = this.write(values, shape, dtype);\n      }\n      this.texData.get(dataId).usage = null;\n      return {\n        dataId: dataId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(shape, dtype, values) {\n      return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);\n    }\n  }, {\n    key: \"unpackTensor\",\n    value: function unpackTensor(input) {\n      var program = new UnpackProgram(input.shape);\n      return this.runWebGLProgram(program, [input], input.dtype);\n    }\n  }, {\n    key: \"packTensor\",\n    value: function packTensor(input) {\n      var program = new PackProgram(input.shape);\n      var preventEagerUnpackingOutput = true;\n      return this.runWebGLProgram(program, [input], input.dtype, null /* customUniformValues */, preventEagerUnpackingOutput);\n    }\n  }, {\n    key: \"packedReshape\",\n    value: function packedReshape(input, afterShape) {\n      var input3DShape = [webgl_util.getBatchDim(input.shape)].concat(_toConsumableArray(webgl_util.getRowsCols(input.shape)));\n      var input3D = {\n        dtype: input.dtype,\n        shape: input3DShape,\n        dataId: input.dataId\n      };\n      var afterShapeAs3D = [webgl_util.getBatchDim(afterShape)].concat(_toConsumableArray(webgl_util.getRowsCols(afterShape)));\n      var program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n      var preventEagerUnpackingOfOutput = true;\n      var customValues = [input3DShape];\n      var output = this.runWebGLProgram(program, [input3D], input.dtype, customValues, preventEagerUnpackingOfOutput);\n      return {\n        dataId: output.dataId,\n        shape: afterShape,\n        dtype: output.dtype\n      };\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(dataId, customTexShape) {\n      var texData = this.texData.get(dataId);\n      var isPacked = texData.isPacked,\n        shape = texData.shape,\n        dtype = texData.dtype;\n      if (customTexShape != null) {\n        var size = util.sizeFromShape(shape);\n        var texSize = customTexShape[0] * customTexShape[1] * 4;\n        util.assert(size <= texSize, function () {\n          return 'customTexShape is too small. ' + 'Row * Column * 4 should be equal or larger than the ' + 'size of the tensor data.';\n        });\n      }\n      var shapeAs3D = webgl_util.getShapeAs3D(shape);\n      var program;\n      if (isPacked) {\n        program = new DecodeMatrixPackedProgram(shapeAs3D);\n      } else {\n        program = new DecodeMatrixProgram(shapeAs3D);\n      }\n      var preventEagerUnpackingOfOutput = true;\n      var customValues = [customTexShape != null ? customTexShape : tex_util.getDenseTexShape(shapeAs3D)];\n      var out = this.runWebGLProgram(program, [{\n        shape: shapeAs3D,\n        dtype: dtype,\n        dataId: dataId\n      }], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);\n      return {\n        dtype: dtype,\n        shape: shape,\n        dataId: out.dataId\n      };\n    }\n  }, {\n    key: \"runWebGLProgram\",\n    value: function runWebGLProgram(program, inputs, outputDtype, customUniformValues) {\n      var _this4 = this;\n      var preventEagerUnpackingOfOutput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var customTexShape = arguments.length > 5 ? arguments[5] : undefined;\n      var output = this.makeTensorInfo(program.outputShape, outputDtype);\n      var outData = this.texData.get(output.dataId);\n      if (program.packedOutput) {\n        outData.isPacked = true;\n      }\n      if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n        var texelShape = customTexShape != null ? customTexShape : tex_util.getDenseTexShape(program.outputShape);\n        // For a densely packed output, we explicitly set texShape\n        // so it doesn't get assigned later according to our typical packing\n        // scheme wherein a single texel can only contain values from adjacent\n        // rows/cols.\n        outData.texShape = texelShape.map(function (d) {\n          return d * 2;\n        });\n      }\n      if (program.outTexUsage != null) {\n        outData.usage = program.outTexUsage;\n      }\n      if (util.sizeFromShape(output.shape) === 0) {\n        // Short-circuit the computation since the result is empty (has 0 in its\n        // shape).\n        outData.values = util.getTypedArrayFromDType(output.dtype, 0);\n        return output;\n      }\n      var dataToDispose = [];\n      var inputsData = inputs.map(function (input) {\n        if (input.dtype === 'complex64') {\n          throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 \" + \"dtypes, please separate the program into real and imaginary \" + \"parts.\");\n        }\n        var texData = _this4.texData.get(input.dataId);\n        if (texData.texture == null) {\n          if (!program.packedInputs && util.sizeFromShape(input.shape) <= env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n            // Upload small tensors that live on the CPU as uniforms, not as\n            // textures. Do this only when the environment supports 32bit floats\n            // due to problems when comparing 16bit floats with 32bit floats.\n            // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n            // possible for packed shaders to sample from uniforms.\n            return {\n              shape: input.shape,\n              texData: null,\n              isUniform: true,\n              uniformValues: texData.values\n            };\n          }\n          // This ensures that if a packed program's inputs have not yet been\n          // uploaded to the GPU, they get uploaded as packed right off the bat.\n          if (program.packedInputs) {\n            texData.isPacked = true;\n            texData.shape = input.shape;\n          }\n        }\n        _this4.uploadToGPU(input.dataId);\n        if (!!texData.isPacked !== !!program.packedInputs) {\n          input = texData.isPacked ? _this4.unpackTensor(input) : _this4.packTensor(input);\n          dataToDispose.push(input);\n          texData = _this4.texData.get(input.dataId);\n        } else if (texData.isPacked && !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n          // This is a special case where a texture exists for a tensor\n          // but the shapes are incompatible (due to packing constraints) because\n          // the tensor did not have a chance to go through the packed reshape\n          // shader. This only happens when we reshape the *same* tensor to form\n          // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n          // case will disappear once packed uploading is the default.\n          var savedInput = input;\n          var targetShape = input.shape;\n          input.shape = texData.shape;\n          input = _this4.packedReshape(input, targetShape);\n          dataToDispose.push(input);\n          texData = _this4.texData.get(input.dataId);\n          savedInput.shape = targetShape;\n        }\n        return {\n          shape: input.shape,\n          texData: texData,\n          isUniform: false\n        };\n      });\n      this.uploadToGPU(output.dataId);\n      var outputData = {\n        shape: output.shape,\n        texData: outData,\n        isUniform: false\n      };\n      var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n      var binary = this.getAndSaveBinary(key, function () {\n        return gpgpu_math.compileProgram(_this4.gpgpu, program, inputsData, outputData);\n      });\n      var shouldTimeProgram = this.activeTimers != null;\n      var query;\n      if (shouldTimeProgram) {\n        query = this.startTimer();\n      }\n      if (!env().get('ENGINE_COMPILE_ONLY')) {\n        gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);\n      }\n      dataToDispose.forEach(function (info) {\n        return _this4.disposeIntermediateTensorInfo(info);\n      });\n      if (shouldTimeProgram) {\n        query = this.endTimer(query);\n        this.activeTimers.push({\n          name: program.constructor.name,\n          query: this.getQueryTime(query)\n        });\n      }\n      var glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n      // Manually GL flush requested\n      if (glFlushThreshold > 0) {\n        var time = util.now();\n        if (time - this.lastGlFlushTime > glFlushThreshold) {\n          this.gpgpu.gl.flush();\n          this.lastGlFlushTime = time;\n        }\n      }\n      if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked && preventEagerUnpackingOfOutput === false) {\n        var unpacked = this.unpackTensor(output);\n        this.disposeIntermediateTensorInfo(output);\n        return unpacked;\n      }\n      return output;\n    }\n  }, {\n    key: \"compileAndRun\",\n    value: function compileAndRun(program, inputs, outputDtype, customUniformValues) {\n      var preventEagerUnpackingOfOutput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      outputDtype = outputDtype || inputs[0].dtype;\n      var outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);\n      return outInfo;\n    }\n  }, {\n    key: \"getAndSaveBinary\",\n    value: function getAndSaveBinary(key, getBinary) {\n      if (!(key in this.binaryCache)) {\n        this.binaryCache[key] = getBinary();\n      }\n      return this.binaryCache[key];\n    }\n  }, {\n    key: \"getTextureManager\",\n    value: function getTextureManager() {\n      return this.textureManager;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this5 = this;\n      if (this.disposed) {\n        return;\n      }\n      // Avoid disposing the compiled webgl programs during unit testing because\n      // it slows down test execution.\n      if (!env().getBool('IS_TEST')) {\n        var allKeys = Object.keys(this.binaryCache);\n        allKeys.forEach(function (key) {\n          _this5.gpgpu.deleteProgram(_this5.binaryCache[key].webGLProgram);\n          delete _this5.binaryCache[key];\n        });\n      }\n      this.textureManager.dispose();\n      if (this.canvas != null && typeof HTMLCanvasElement !== 'undefined' && this.canvas instanceof HTMLCanvasElement) {\n        this.canvas.remove();\n      } else {\n        this.canvas = null;\n      }\n      if (this.gpgpuCreatedLocally) {\n        this.gpgpu.program = null;\n        this.gpgpu.dispose();\n      }\n      this.disposed = true;\n    }\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      var _this6 = this;\n      if (this.floatPrecisionValue == null) {\n        this.floatPrecisionValue = tidy(function () {\n          if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n            // Momentarily switching DEBUG flag to false so we don't throw an\n            // error trying to upload a small value.\n            var debugFlag = env().getBool('DEBUG');\n            env().set('DEBUG', false);\n            var underflowCheckValue = _this6.abs(scalar(1e-8)).dataSync()[0];\n            env().set('DEBUG', debugFlag);\n            if (underflowCheckValue > 0) {\n              return 32;\n            }\n          }\n          return 16;\n        });\n      }\n      return this.floatPrecisionValue;\n    }\n    /** Returns the smallest representable number.  */\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n  }, {\n    key: \"uploadToGPU\",\n    value: function uploadToGPU(dataId) {\n      var texData = this.texData.get(dataId);\n      var shape = texData.shape,\n        dtype = texData.dtype,\n        values = texData.values,\n        texture = texData.texture,\n        usage = texData.usage,\n        isPacked = texData.isPacked;\n      if (texture != null) {\n        // Array is already on GPU. No-op.\n        return;\n      }\n      var shouldTimeProgram = this.activeTimers != null;\n      var start;\n      if (shouldTimeProgram) {\n        start = util.now();\n      }\n      var texShape = texData.texShape;\n      if (texShape == null) {\n        // This texShape may not be the final texture shape. For packed or dense\n        // textures, the texShape will be changed when textures are created.\n        texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n        texData.texShape = texShape;\n      }\n      if (values != null) {\n        var shapeAs3D = webgl_util.getShapeAs3D(shape);\n        var program;\n        var width = texShape[1],\n          height = texShape[0];\n        var isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;\n        // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we\n        // need to make sure the upload uses the same packed size\n        if (isPacked || !isByteArray) {\n          var _tex_util$getPackedMa = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);\n          var _tex_util$getPackedMa2 = _slicedToArray(_tex_util$getPackedMa, 2);\n          width = _tex_util$getPackedMa2[0];\n          height = _tex_util$getPackedMa2[1];\n        }\n        if (isPacked) {\n          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);\n        } else {\n          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);\n        }\n        // TexShape for float array needs to be the original shape, which byte\n        // array needs to be packed size. This allow the data upload shape to be\n        // matched with texture creation logic.\n        var tempDenseInputTexShape = isByteArray ? [height, width] : texShape;\n        var tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);\n        var tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);\n        if (isByteArray) {\n          tempDenseInputTexData.usage = TextureUsage.PIXELS;\n        } else {\n          tempDenseInputTexData.usage = TextureUsage.UPLOAD;\n        }\n        tempDenseInputTexData.texShape = tempDenseInputTexShape;\n        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n        var customValues = [[height, width]];\n        // We want the output to remain packed regardless of the value of\n        // WEBGL_PACK.\n        var preventEagerUnpacking = true;\n        var encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);\n        // Have the original texture assume the identity of the encoded output.\n        var outputTexData = this.texData.get(encodedOutputTarget.dataId);\n        texData.texShape = outputTexData.texShape;\n        texData.isPacked = outputTexData.isPacked;\n        texData.usage = outputTexData.usage;\n        if (!env().get('ENGINE_COMPILE_ONLY')) {\n          texData.texture = outputTexData.texture;\n          // Once uploaded, don't store the values on cpu.\n          texData.values = null;\n          this.texData.delete(encodedOutputTarget.dataId);\n        } else {\n          this.disposeData(encodedOutputTarget.dataId);\n        }\n        this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n        if (shouldTimeProgram) {\n          this.uploadWaitMs += util.now() - start;\n        }\n      } else {\n        var newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n        texData.texture = newTexture;\n      }\n    }\n  }, {\n    key: \"convertAndCacheOnCPU\",\n    value: function convertAndCacheOnCPU(dataId, float32Values) {\n      var texData = this.texData.get(dataId);\n      var dtype = texData.dtype;\n      if (float32Values != null) {\n        texData.values = float32ToTypedArray(float32Values, dtype);\n      }\n      return texData.values;\n    }\n  }, {\n    key: \"acquireTexture\",\n    value: function acquireTexture(texShape, texType, dtype, isPacked) {\n      this.numBytesInGPU += this.computeBytes(texShape, dtype);\n      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n        var mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n        this.warnedAboutMemory = true;\n        console.warn(\"High memory usage in GPU: \".concat(mb, \" MB, \") + \"most likely due to a memory leak\");\n      }\n      return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    }\n  }, {\n    key: \"computeBytes\",\n    value: function computeBytes(shape, dtype) {\n      return shape[0] * shape[1] * util.bytesPerElement(dtype);\n    }\n  }, {\n    key: \"checkCompileCompletion\",\n    value: function checkCompileCompletion() {\n      for (var _i = 0, _Object$entries = Object.entries(this.binaryCache); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          binary = _Object$entries$_i[1];\n        this.checkCompletion_(binary);\n      }\n    }\n  }, {\n    key: \"checkCompileCompletionAsync\",\n    value: function () {\n      var _checkCompileCompletionAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this7 = this;\n        var ps, _i2, _Object$entries2, _Object$entries2$_i, binary, _loop, _i3, _Object$entries3;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              ps = [];\n              if (!this.gpgpu.parallelCompilationExtension) {\n                _context5.next = 6;\n                break;\n              }\n              for (_i2 = 0, _Object$entries2 = Object.entries(this.binaryCache); _i2 < _Object$entries2.length; _i2++) {\n                _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), binary = _Object$entries2$_i[1];\n                ps.push(this.checkCompletionAsync_(binary));\n              }\n              return _context5.abrupt(\"return\", Promise.all(ps));\n            case 6:\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var _Object$entries3$_i, binary, p;\n                return _regeneratorRuntime().wrap(function _loop$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2), binary = _Object$entries3$_i[1];\n                      p = new Promise(function (resolve) {\n                        try {\n                          _this7.checkCompletion_(binary);\n                          resolve(true);\n                        } catch (error) {\n                          throw error;\n                        }\n                      });\n                      ps.push(p);\n                    case 3:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _loop);\n              });\n              _i3 = 0, _Object$entries3 = Object.entries(this.binaryCache);\n            case 8:\n              if (!(_i3 < _Object$entries3.length)) {\n                _context5.next = 13;\n                break;\n              }\n              return _context5.delegateYield(_loop(), \"t0\", 10);\n            case 10:\n              _i3++;\n              _context5.next = 8;\n              break;\n            case 13:\n              return _context5.abrupt(\"return\", Promise.all(ps));\n            case 14:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function checkCompileCompletionAsync() {\n        return _checkCompileCompletionAsync.apply(this, arguments);\n      }\n      return checkCompileCompletionAsync;\n    }()\n  }, {\n    key: \"checkCompletionAsync_\",\n    value: function () {\n      var _checkCompletionAsync_ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(binary) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {\n                _context6.next = 4;\n                break;\n              }\n              return _context6.abrupt(\"return\", this.checkCompletion_(binary));\n            case 4:\n              _context6.next = 6;\n              return nextFrame();\n            case 6:\n              return _context6.abrupt(\"return\", this.checkCompletionAsync_(binary));\n            case 7:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function checkCompletionAsync_(_x3) {\n        return _checkCompletionAsync_.apply(this, arguments);\n      }\n      return checkCompletionAsync_;\n    }()\n  }, {\n    key: \"checkCompletion_\",\n    value: function checkCompletion_(binary) {\n      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {\n        console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));\n        if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {\n          webgl_util.logShaderSourceAndInfoLog(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));\n          throw new Error('Failed to compile fragment shader.');\n        }\n        throw new Error('Failed to link vertex and fragment shaders.');\n      }\n      return true;\n    }\n  }, {\n    key: \"getUniformLocations\",\n    value: function getUniformLocations() {\n      for (var _i4 = 0, _Object$values = Object.values(this.binaryCache); _i4 < _Object$values.length; _i4++) {\n        var binary = _Object$values[_i4];\n        // TODO: Iterating through all binaries to build VAOs is supposed to be in\n        // a seperate function, like 'setVaos'. However, to avoid breaking changes\n        // for the users using parallel compile feature now, buildVao is silently\n        // added here.\n        this.gpgpu.buildVao(binary.webGLProgram);\n        var _getUniformLocations2 = _getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram),\n          variablesLocations = _getUniformLocations2.variablesLocations,\n          customUniformLocations = _getUniformLocations2.customUniformLocations,\n          infLoc = _getUniformLocations2.infLoc,\n          nanLoc = _getUniformLocations2.nanLoc,\n          outShapeLocation = _getUniformLocations2.outShapeLocation,\n          outShapeStridesLocation = _getUniformLocations2.outShapeStridesLocation,\n          outTexShapeLocation = _getUniformLocations2.outTexShapeLocation;\n        binary.variablesLocations = variablesLocations;\n        binary.customUniformLocations = customUniformLocations;\n        binary.infLoc = infLoc;\n        binary.nanLoc = nanLoc;\n        binary.outShapeLocation = outShapeLocation;\n        binary.outShapeStridesLocation = outShapeStridesLocation;\n        binary.outTexShapeLocation = outTexShapeLocation;\n      }\n    }\n    /**\n     * Create a TF.js tensor out of an existing WebGL texture. A new texture will\n     * be created.\n     */\n  }, {\n    key: \"createTensorFromGPUData\",\n    value: function createTensorFromGPUData(values, shape, dtype) {\n      values.channels = values.channels || 'RGBA';\n      var texture = values.texture,\n        height = values.height,\n        width = values.width,\n        channels = values.channels;\n      var backend = engine().backend;\n      // Have to throw an error, otherwise WebGL just warns and returns wrong\n      // values.\n      if (!backend.gpgpu.gl.isTexture(texture)) {\n        throw new Error(\"The texture is invalid. Also, please make sure the texture and \" + \"the TFJS WebGL backend are using the same canvas. If you want to \" + \"use your own custom canvas, you have to create and use the custom \" + \"TFJS WebGL backend created from the canvas through \" + \"'new tf.MathBackendWebGL(customCanvas)'.\");\n      }\n      var dataId = backend.writeTexture(texture, shape, dtype, height, width, channels);\n      return engine().makeTensorFromDataId(dataId, shape, dtype, backend);\n    }\n  }]);\n  return MathBackendWebGL;\n}(KernelBackend);\nMathBackendWebGL.nextDataId = 0;\nfunction float32ToTypedArray(a, dtype) {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a;\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    var result = dtype === 'int32' ? new Int32Array(a.length) : new Uint8Array(a.length);\n    for (var i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result;\n  } else {\n    throw new Error(\"Unknown dtype \".concat(dtype));\n  }\n}","map":{"version":3,"names":["backend_util","buffer","DataStorage","engine","env","kernel_impls","KernelBackend","nextFrame","scalar","tidy","util","getWebGLContext","DecodeMatrixProgram","DecodeMatrixPackedProgram","EncodeFloatProgram","EncodeFloatPackedProgram","EncodeMatrixProgram","EncodeMatrixPackedProgram","GPGPUContext","gpgpu_math","getUniformLocations","simpleAbsImplCPU","PackProgram","ReshapePackedProgram","tex_util","TextureUsage","TextureManager","unary_op","UnaryOpProgram","UnaryOpPackedProgram","UnpackProgram","webgl_util","whereImpl","EPSILON_FLOAT32","EPSILON_FLOAT16","binaryCaches","getBinaryCache","webGLVersion","CPU_HANDOFF_SIZE_THRESHOLD","getNumber","BEFORE_PAGING_CONSTANT","numMBBeforeWarning","global","screen","height","width","window","devicePixelRatio","MathBackendWebGL","_KernelBackend","_inherits","_super","_createSuper","gpuResource","_this","_classCallCheck","call","pendingRead","WeakMap","pendingDisposal","WeakSet","dataRefCount","numBytesInGPU","uploadWaitMs","downloadWaitMs","lastGlFlushTime","warnedAboutMemory","pendingDeletes","disposed","getBool","Error","newGPGPU","gl","binaryCache","gpgpuCreatedLocally","gpgpu","canvas","textureManager","texData","_assertThisInitialized","_createClass","key","value","nextDataId","numDataIds","writeTexture","texture","shape","dtype","texHeight","texWidth","channels","input","makeTensorInfo","inData","get","dataId","isPacked","texShape","shapeAs3D","getShapeAs3D","program","output","runWebGLProgram","disposeIntermediateTensorInfo","write","values","checkNumericalProblems","id","set","usage","UPLOAD","refCount","has","tensorData","incRef","decRef","move","tensorInfo","disposeData","readSync","complexTensorInfos","slice","CLONE","res","data","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","start","now","result","realValues","real","imagValues","imag","mergeRealAndImagArrays","getValuesFromTexture","_read","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_subscribers","tmpDownloadTarget","_this$gpgpu","tmpData","vals","ps","size","dTypeVals","subscribers","wrap","_callee$","_context","prev","next","abrupt","Promise","resolve","push","read","decode","createBufferFromTexture","apply","concat","_toConsumableArray","getDenseTexShape","createAndWaitForFence","all","sent","sizeFromShape","downloadFloat32MatrixFromBuffer","callAndCheck","deleteBuffer","delete","forEach","removeDataId","stop","_x","arguments","readToGPU","options","length","undefined","gpuResouorce","tmpTarget","customTexShape","tensorRef","makeTensorFromTensorInfo","Object","assign","bufferSync","t","strings","map","d","decodeString","_a","i","num","canBeRepresented","_this$texData$get","_this$gpgpu2","downloadMatrixFromPackedTexture","subarray","shouldUsePackedProgram","outputShape","downloadByteEncodedFloatMatrixFromOutputTexture","timerAvailable","time","f","_this2","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","flatten","query","filter","flattenedActiveTimerNames","name","kernelMs","wallMs","_callee2","_callee2$","_context2","sum","ms","join","error","memory","unreliable","numBytesInGPUAllocated","numBytesAllocated","numBytesInGPUFree","numBytesFree","startTimer","beginQuery","startMs","endMs","endTimer","endQuery","_getQueryTime","_callee3","timerQuery","_callee3$","_context3","waitForQueryAndGetTime","getQueryTime","_x2","force","add","releaseGPUData","_this$texData$get2","_this$texData$get3","origDataId","computeBytes","releaseTexture","getTexture","uploadToGPU","getDataInfo","shouldExecuteOnCPU","inputs","_this3","sizeThreshold","every","getGPGPUContext","where","condition","warn","condVals","dataSync","packedUnaryOp","x","op","outInfo","compileAndRun","abs","outValues","makeOutput","ABS","isString","encodedValues","encodeString","unpackTensor","packTensor","preventEagerUnpackingOutput","packedReshape","afterShape","input3DShape","getBatchDim","getRowsCols","input3D","afterShapeAs3D","preventEagerUnpackingOfOutput","customValues","texSize","assert","out","outputDtype","customUniformValues","_this4","outData","packedOutput","outPackingScheme","PackingScheme","DENSE","texelShape","outTexUsage","getTypedArrayFromDType","dataToDispose","inputsData","packedInputs","isUniform","uniformValues","isReshapeFree","savedInput","targetShape","outputData","makeShaderKey","binary","getAndSaveBinary","compileProgram","runProgram","info","constructor","glFlushThreshold","flush","unpacked","getBinary","getTextureManager","dispose","_this5","allKeys","keys","deleteProgram","webGLProgram","HTMLCanvasElement","remove","floatPrecision","_this6","floatPrecisionValue","debugFlag","underflowCheckValue","epsilon","getTextureShapeFromLogicalShape","isByteArray","Uint8Array","Uint8ClampedArray","_tex_util$getPackedMa","getPackedMatrixTextureShapeWidthHeight","_tex_util$getPackedMa2","_slicedToArray","tempDenseInputTexShape","tempDenseInputHandle","tempDenseInputTexData","PIXELS","uploadDenseMatrixToTexture","preventEagerUnpacking","encodedOutputTarget","outputTexData","newTexture","acquireTexture","float32Values","float32ToTypedArray","texType","mb","toFixed","console","bytesPerElement","checkCompileCompletion","_i","_Object$entries","entries","_Object$entries$_i","checkCompletion_","_checkCompileCompletionAsync","_callee4","_this7","_i2","_Object$entries2","_Object$entries2$_i","_loop","_i3","_Object$entries3","_callee4$","_context5","parallelCompilationExtension","checkCompletionAsync_","_Object$entries3$_i","p","_loop$","_context4","delegateYield","checkCompileCompletionAsync","_checkCompletionAsync_","_callee5","_callee5$","_context6","getProgramParameter","COMPLETION_STATUS_KHR","_x3","LINK_STATUS","log","getProgramInfoLog","getShaderParameter","fragmentShader","COMPILE_STATUS","logShaderSourceAndInfoLog","source","getShaderInfoLog","_i4","_Object$values","buildVao","_getUniformLocations2","variablesLocations","customUniformLocations","infLoc","nanLoc","outShapeLocation","outShapeStridesLocation","outTexShapeLocation","createTensorFromGPUData","backend","isTexture","makeTensorFromDataId","a","Int32Array","Math","round"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\backend_webgl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import webgl flags.\nimport './flags_webgl';\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {backend_util, BackendValues, buffer, DataId, DataStorage, DataToGPUWebGLOption, DataType, engine, env, GPUData, kernel_impls, KernelBackend, MemoryInfo, nextFrame, NumericDataType, Rank, RecursiveArray, scalar, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, tidy, TimingInfo, TypedArray, util, WebGLData} from '@tensorflow/tfjs-core';\nimport {getWebGLContext} from './canvas_util';\nimport {DecodeMatrixProgram} from './decode_matrix_gpu';\nimport {DecodeMatrixPackedProgram} from './decode_matrix_packed_gpu';\nimport {EncodeFloatProgram} from './encode_float_gpu';\nimport {EncodeFloatPackedProgram} from './encode_float_packed_gpu';\nimport {EncodeMatrixProgram} from './encode_matrix_gpu';\nimport {EncodeMatrixPackedProgram} from './encode_matrix_packed_gpu';\nimport {GPGPUContext} from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport {getUniformLocations, GPGPUBinary, GPGPUProgram, TensorData} from './gpgpu_math';\nimport {simpleAbsImplCPU} from './kernel_utils/shared';\nimport {PackProgram} from './pack_gpu';\nimport {ReshapePackedProgram} from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureData, TextureUsage} from './tex_util';\nimport {TextureManager} from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport {UnaryOpProgram} from './unaryop_gpu';\nimport {UnaryOpPackedProgram} from './unaryop_packed_gpu';\nimport {UnpackProgram} from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\n\nconst whereImpl = kernel_impls.whereImpl;\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\ntype KernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<KernelInfo>|KernelInfo;\nexport interface CPUTimerQuery {\n  startMs: number;\n  endMs?: number;\n}\n\nexport interface WebGLMemoryInfo extends MemoryInfo {\n  numBytesInGPU: number;\n  // Tracks the total number of bytes allocated on the GPU, accounting for the\n  // physical texture type.\n  numBytesInGPUAllocated: number;\n  // Tracks byte size of textures that were created and then made available for\n  // reuse (disposed).\n  numBytesInGPUFree: number;\n  unreliable: boolean;\n}\n\nexport interface WebGLTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\nconst binaryCaches: {[webGLVersion: string]: {[key: string]: GPGPUBinary}} = {};\n\nexport function getBinaryCache(webGLVersion: number) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD =\n    env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');\n\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning(): number {\n  if (env().global.screen == null) {\n    return 1024;  // 1 GB.\n  }\n  return (env().global.screen.height * env().global.screen.width *\n          window.devicePixelRatio) *\n      BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\nexport class MathBackendWebGL extends KernelBackend {\n  texData: DataStorage<TextureData>;\n  gpgpu: GPGPUContext;\n\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendWebGL.nextDataId++;\n  }\n  // Maps data ids that have a pending read operation, to list of subscribers.\n  private pendingRead = new WeakMap<DataId, Array<(arr: TypedArray) => void>>();\n  // List of data ids that are scheduled for disposal, but are waiting on a\n  // pending read operation.\n  private pendingDisposal = new WeakSet<DataId>();\n\n  // Used to count the number of 'shallow' sliced tensors that point to the\n  // same data id.\n  dataRefCount = new WeakMap<DataId, number>();\n  private numBytesInGPU = 0;\n\n  private canvas: HTMLCanvasElement|OffscreenCanvas;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  // Accumulated time spent (including blocking) in uploading data to webgl.\n  private uploadWaitMs = 0;\n  // Accumulated time spent (including blocking in downloading data from webgl.\n  private downloadWaitMs = 0;\n\n  // record the last manual GL Flush time.\n  private lastGlFlushTime = 0;\n\n  // Number of bits of precision of this backend.\n  private floatPrecisionValue: 32|16;\n\n  private textureManager: TextureManager;\n  private binaryCache: {[key: string]: GPGPUBinary};\n  private gpgpuCreatedLocally: boolean;\n  private numMBBeforeWarning: number;\n  private warnedAboutMemory = false;\n\n  constructor(gpuResource?: GPGPUContext|HTMLCanvasElement|OffscreenCanvas) {\n    super();\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    let newGPGPU;\n    if (gpuResource != null) {\n      if (gpuResource instanceof GPGPUContext) {\n        newGPGPU = gpuResource;\n      } else {\n        const gl =\n            getWebGLContext(env().getNumber('WEBGL_VERSION'), gpuResource);\n        newGPGPU = new GPGPUContext(gl);\n      }\n      this.binaryCache = {};\n      this.gpgpuCreatedLocally = false;\n    } else {\n      const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      newGPGPU = new GPGPUContext(gl);\n      this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      this.gpgpuCreatedLocally = true;\n    }\n\n    this.gpgpu = newGPGPU;\n    this.canvas = this.gpgpu.gl.canvas;\n    this.textureManager = new TextureManager(this.gpgpu);\n    this.numMBBeforeWarning = numMBBeforeWarning();\n    this.texData = new DataStorage(this, engine());\n  }\n\n  override numDataIds() {\n    return this.texData.numDataIds() - this.pendingDeletes;\n  }\n\n  // Writes a new entry to the data store with a WebGL texture, and registers it\n  // to the texture manager.\n  writeTexture(\n      texture: WebGLTexture, shape: number[], dtype: DataType,\n      texHeight: number, texWidth: number, channels: string): DataId {\n    // Temporarily create an tensor info to make the texture compatible with\n    // the runWebGLProgram's input.\n    const input = this.makeTensorInfo(shape, dtype);\n    const inData = this.texData.get(input.dataId);\n    // Even though the input texture could be unpacked or dense packed, it is\n    // always considered as unpacked for EncodeMatrixProgram.\n    inData.isPacked = false;\n\n    // Bind texture to the input tensor.\n    inData.texture = {texture, texShape: [texHeight, texWidth]};\n    inData.texShape = [texHeight, texWidth];\n\n    const shapeAs3D = webgl_util.getShapeAs3D(shape);\n    const program =\n        new EncodeMatrixProgram(shapeAs3D, false /* isByteArray */, channels);\n    const output =\n        this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);\n    output.shape = shape;\n\n    // Unbind the texture from the input tensor to avoid the texture being\n    // released.\n    inData.texture = null;\n    this.disposeIntermediateTensorInfo(input);\n\n    return output.dataId;\n  }\n\n  override write(values: BackendValues, shape: number[], dtype: DataType):\n      DataId {\n    if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n        env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {id: this.nextDataId()};\n    this.texData.set(\n        dataId,\n        {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1});\n    return dataId;\n  }\n\n  /** Return refCount of a `TensorData`. */\n  override refCount(dataId: DataId): number {\n    if (this.texData.has(dataId)) {\n      const tensorData = this.texData.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TextureData`. */\n  override incRef(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    texData.refCount++;\n  }\n\n  /** Decrease refCount of a `TextureData`. */\n  decRef(dataId: DataId): void {\n    if (this.texData.has(dataId)) {\n      const texData = this.texData.get(dataId);\n      texData.refCount--;\n    }\n  }\n\n  override move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.texData.set(\n        dataId, {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount});\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  override readSync(dataId: DataId): BackendValues {\n    const texData = this.texData.get(dataId);\n    const {values, dtype, complexTensorInfos, slice, shape, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.readSync(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n    if (dtype === 'string') {\n      return values;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let result: Float32Array;\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      result = this.getValuesFromTexture(dataId);\n    }\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += util.now() - start;\n    }\n    return this.convertAndCacheOnCPU(dataId, result);\n  }\n\n  override async read(dataId: DataId): Promise<BackendValues> {\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<TypedArray>(resolve => subscribers.push(resolve));\n    }\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, complexTensorInfos, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.read(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n\n    if (env().getBool('DEBUG')) {\n      // getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') caused a blocking GPU call.\n      // For performance reason, only check it for debugging. In production,\n      // it doesn't handle this use case anyway, so behavior is not changed.\n      if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n          env().getNumber('WEBGL_VERSION') === 2) {\n        throw new Error(\n            `tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n            `WEBGL_VERSION=2 not yet supported.`);\n      }\n    }\n\n    let buffer: WebGLBuffer = null;\n    let tmpDownloadTarget: TensorInfo;\n\n    if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n      // Possibly copy the texture into a buffer before inserting a fence.\n      tmpDownloadTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n\n      buffer = this.gpgpu.createBufferFromTexture(\n          tmpData.texture.texture, ...tex_util.getDenseTexShape(shape));\n    }\n\n    this.pendingRead.set(dataId, []);\n\n    if (dtype !== 'complex64') {\n      // Create a fence and wait for it to resolve.\n      await this.gpgpu.createAndWaitForFence();\n    }\n\n    // Download the values from the GPU.\n    let vals: Float32Array;\n    if (dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(complexTensorInfos.real.dataId),\n        this.read(complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else if (buffer == null) {\n      vals = this.getValuesFromTexture(dataId);\n    } else {\n      const size = util.sizeFromShape(shape);\n      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n    }\n    if (tmpDownloadTarget != null) {\n      this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n    }\n    if (buffer != null) {\n      const gl = this.gpgpu.gl;\n      webgl_util.callAndCheck(gl, () => gl.deleteBuffer(buffer));\n    }\n    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n\n    const subscribers = this.pendingRead.get(dataId);\n    this.pendingRead.delete(dataId);\n\n    // Notify all pending reads.\n    subscribers.forEach(resolve => resolve(dTypeVals));\n    if (this.pendingDisposal.has(dataId)) {\n      this.pendingDisposal.delete(dataId);\n      if (this.disposeData(dataId)) {\n        engine().removeDataId(dataId, this);\n      }\n      this.pendingDeletes--;\n    }\n    return dTypeVals;\n  }\n\n  /**\n   * Read tensor to a new texture that is densely packed for ease of use.\n   * @param dataId The source tensor.\n   * @param options\n   *     customTexShape: Optional. If set, will use the user defined texture\n   *     shape to create the texture.\n   */\n  override readToGPU(dataId: DataId, options: DataToGPUWebGLOption = {}):\n      GPUData {\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, isPacked, texture} = texData;\n\n    if (dtype === 'complex64') {\n      throw new Error('Does not support reading texture for complex64 dtype.');\n    }\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const gpuResouorce = this.readToGPU(res, options);\n      this.disposeIntermediateTensorInfo(res);\n      return gpuResouorce;\n    }\n\n    if (texture == null) {\n      if (values != null) {\n        throw new Error('Data is not on GPU but on CPU.');\n      } else {\n        throw new Error('There is no data on GPU or CPU.');\n      }\n    }\n\n    // Decode the texture so that it is stored densely (using four channels).\n    const tmpTarget = this.decode(dataId, options.customTexShape);\n\n    // Make engine track this tensor, so that we can dispose it later.\n    const tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);\n\n    const tmpData = this.texData.get(tmpTarget.dataId);\n    return {tensorRef, ...tmpData.texture};\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  private checkNumericalProblems(values: BackendValues): void {\n    if (values == null) {\n      return;\n    }\n    for (let i = 0; i < values.length; i++) {\n      const num = values[i] as number;\n      if (!webgl_util.canBeRepresented(num)) {\n        if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n          throw Error(\n              `The value ${num} cannot be represented with your ` +\n              `current settings. Consider enabling float32 rendering: ` +\n              `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n        }\n        throw Error(`The value ${num} cannot be represented on this device.`);\n      }\n    }\n  }\n\n  private getValuesFromTexture(dataId: DataId): Float32Array {\n    const {shape, dtype, isPacked} = this.texData.get(dataId);\n    const size = util.sizeFromShape(shape);\n    if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n      const tmpTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpTarget.dataId);\n      const vals =\n          this.gpgpu\n              .downloadMatrixFromPackedTexture(\n                  tmpData.texture.texture, ...tex_util.getDenseTexShape(shape))\n              .subarray(0, size);\n\n      this.disposeIntermediateTensorInfo(tmpTarget);\n\n      return vals;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK') && isPacked === true;\n    const outputShape =\n        shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n    const program = shouldUsePackedProgram ?\n        new EncodeFloatPackedProgram(outputShape as [number, number, number]) :\n        new EncodeFloatProgram(outputShape);\n    const output = this.runWebGLProgram(\n        program, [{shape: outputShape, dtype, dataId}], 'float32');\n    const tmpData = this.texData.get(output.dataId);\n    const vals = this.gpgpu\n                     .downloadByteEncodedFloatMatrixFromOutputTexture(\n                         tmpData.texture.texture, tmpData.texShape[0],\n                         tmpData.texShape[1])\n                     .subarray(0, size);\n    this.disposeIntermediateTensorInfo(output);\n\n    return vals;\n  }\n\n  override timerAvailable(): boolean {\n    return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n  }\n\n  override time(f: () => void): Promise<WebGLTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    // needing to split these up because util.flatten only accepts certain types\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n\n    const res: WebGLTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null  // will be filled by the engine\n    };\n\n    return (async () => {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') >\n          0) {\n        const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n\n        res['kernelMs'] = util.sum(kernelMs);\n        res['getExtraProfileInfo'] = () =>\n            kernelMs\n                .map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n                .map(d => `${d.name}: ${d.ms}`)\n                .join(', ');\n      } else {\n        res['kernelMs'] = {\n          error: 'WebGL query timers are not supported in this environment.'\n        };\n      }\n\n      this.uploadWaitMs = 0;\n      this.downloadWaitMs = 0;\n      return res;\n    })();\n  }\n  override memory(): WebGLMemoryInfo {\n    return {\n      unreliable: false,\n      numBytesInGPU: this.numBytesInGPU,\n      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n      numBytesInGPUFree: this.textureManager.numBytesFree\n    } as WebGLMemoryInfo;\n  }\n\n  private startTimer(): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n    return {startMs: util.now(), endMs: null};\n  }\n\n  private endTimer(query: WebGLQuery|CPUTimerQuery): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n    (query as CPUTimerQuery).endMs = util.now();\n    return query;\n  }\n\n  private async getQueryTime(query: WebGLQuery|CPUTimerQuery): Promise<number> {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.waitForQueryAndGetTime(query as WebGLQuery);\n    }\n    const timerQuery = query as CPUTimerQuery;\n    return timerQuery.endMs - timerQuery.startMs;\n  }\n\n  private pendingDeletes = 0;\n\n  /**\n   * Decrease the RefCount on the dataId and dispose the memory if the dataId\n   * has 0 refCount. If there are pending read on the data, the disposal would\n   * added to the pending delete queue. Return true if the dataId is removed\n   * from backend or the backend does not contain the dataId, false if the\n   * dataId is not removed. Memory may or may not be released even when dataId\n   * is removed, which also depends on dataRefCount, see `releaseGPU`.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  override disposeData(dataId: DataId, force = false): boolean {\n    if (this.pendingDisposal.has(dataId)) {\n      return false;\n    }\n\n    // No-op if already disposed.\n    if (!this.texData.has(dataId)) {\n      return true;\n    }\n\n    // if force flag is set, change refCount to 0, this would ensure disposal\n    // when added to the pendingDisposal queue. Memory may or may not be\n    // released, which also depends on dataRefCount, see `releaseGPU`.\n    if (force) {\n      this.texData.get(dataId).refCount = 0;\n    } else {\n      this.texData.get(dataId).refCount--;\n    }\n\n    if (!force && this.texData.get(dataId).refCount > 0) {\n      return false;\n    }\n\n    if (this.pendingRead.has(dataId)) {\n      this.pendingDisposal.add(dataId);\n      this.pendingDeletes++;\n      return false;\n    }\n\n    this.releaseGPUData(dataId);\n    const {complexTensorInfos} = this.texData.get(dataId);\n    if (complexTensorInfos != null) {\n      this.disposeData(complexTensorInfos.real.dataId, force);\n      this.disposeData(complexTensorInfos.imag.dataId, force);\n    }\n\n    this.texData.delete(dataId);\n\n    return true;\n  }\n\n  private releaseGPUData(dataId: DataId): void {\n    const {texture, dtype, texShape, usage, isPacked, slice} =\n        this.texData.get(dataId);\n    const key = slice && slice.origDataId || dataId;\n    const refCount = this.dataRefCount.get(key);\n\n    if (refCount > 1) {\n      this.dataRefCount.set(key, refCount - 1);\n    } else {\n      this.dataRefCount.delete(key);\n      if (texture != null) {\n        this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n      }\n    }\n\n    const texData = this.texData.get(dataId);\n    texData.texture = null;\n    texData.texShape = null;\n    texData.isPacked = false;\n    texData.slice = null;\n  }\n\n  getTexture(dataId: DataId): WebGLTexture {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture.texture;\n  }\n\n  /**\n   * Returns internal information for the specific data bucket. Used in unit\n   * tests.\n   */\n  getDataInfo(dataId: DataId): TextureData {\n    return this.texData.get(dataId);\n  }\n\n  /*\n  Tests whether all the inputs to an op are small and on the CPU. This heuristic\n  determines when it would be faster to execute a kernel on the CPU. WebGL\n  kernels opt into running this check and forwarding when appropriate.\n  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n  sustainable strategy for optimizing backend execution of ops.\n   */\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return env().getBool('WEBGL_CPU_FORWARD') &&\n        inputs.every(\n            input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  getGPGPUContext(): GPGPUContext {\n    return this.gpgpu;\n  }\n\n  where(condition: Tensor): Tensor2D {\n    backend_util.warn(\n        'tf.where() in webgl locks the UI thread. ' +\n        'Call tf.whereAsync() instead');\n    const condVals = condition.dataSync();\n    return whereImpl(condition.shape, condVals);\n  }\n\n  private packedUnaryOp(x: TensorInfo, op: string, dtype: DataType) {\n    const program = new UnaryOpPackedProgram(x.shape, op);\n    const outInfo = this.compileAndRun(program, [x], dtype);\n    return engine().makeTensorFromTensorInfo(outInfo);\n  }\n\n  // TODO(msoulanille) remove this once the backend has been modularized\n  // a copy is needed here to break a circular dependency.\n  // Also remove the op from unary_op.\n  abs<T extends Tensor>(x: T): T {\n    // TODO: handle cases when x is complex.\n    if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n      const outValues =\n          simpleAbsImplCPU(this.texData.get(x.dataId).values as TypedArray);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.ABS, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n    const outInfo = this.compileAndRun(program, [x]);\n    return engine().makeTensorFromTensorInfo(outInfo) as T;\n  }\n\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: BackendValues|string[]): TensorInfo {\n    let dataId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as unknown as string[]).map(d => util.encodeString(d));\n\n      dataId = this.write(encodedValues, shape, dtype);\n    } else {\n      dataId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    this.texData.get(dataId).usage = null;\n    return {dataId, shape, dtype};\n  }\n\n  private makeOutput<T extends Tensor>(\n      shape: number[], dtype: DataType, values?: BackendValues): T {\n    return engine().makeTensorFromTensorInfo(\n               this.makeTensorInfo(shape, dtype, values), this) as T;\n  }\n\n  unpackTensor(input: TensorInfo): TensorInfo {\n    const program = new UnpackProgram(input.shape);\n    return this.runWebGLProgram(program, [input], input.dtype);\n  }\n\n  packTensor(input: TensorInfo): TensorInfo {\n    const program = new PackProgram(input.shape);\n    const preventEagerUnpackingOutput = true;\n    return this.runWebGLProgram(\n        program, [input], input.dtype, null /* customUniformValues */,\n        preventEagerUnpackingOutput);\n  }\n\n  private packedReshape(input: TensorInfo, afterShape: number[]): TensorInfo {\n    const input3DShape = [\n      webgl_util.getBatchDim(input.shape),\n      ...webgl_util.getRowsCols(input.shape)\n    ] as [number, number, number];\n    const input3D: TensorInfo = {\n      dtype: input.dtype,\n      shape: input3DShape,\n      dataId: input.dataId\n    };\n    const afterShapeAs3D = [\n      webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n    ] as [number, number, number];\n\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const customValues = [input3DShape];\n    const output = this.runWebGLProgram(\n        program, [input3D], input.dtype, customValues,\n        preventEagerUnpackingOfOutput);\n    return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n  }\n\n  private decode(dataId: DataId, customTexShape?: [number, number]):\n      TensorInfo {\n    const texData = this.texData.get(dataId);\n    const {isPacked, shape, dtype} = texData;\n    if (customTexShape != null) {\n      const size = util.sizeFromShape(shape);\n      const texSize = customTexShape[0] * customTexShape[1] * 4;\n      util.assert(\n          size <= texSize,\n          () => 'customTexShape is too small. ' +\n              'Row * Column * 4 should be equal or larger than the ' +\n              'size of the tensor data.');\n    }\n    const shapeAs3D =\n        webgl_util.getShapeAs3D(shape) as [number, number, number];\n    let program;\n    if (isPacked) {\n      program = new DecodeMatrixPackedProgram(shapeAs3D);\n    } else {\n      program = new DecodeMatrixProgram(shapeAs3D);\n    }\n    const preventEagerUnpackingOfOutput = true;\n    const customValues =\n        [customTexShape != null ? customTexShape :\n                                  tex_util.getDenseTexShape(shapeAs3D)];\n    const out = this.runWebGLProgram(\n        program, [{shape: shapeAs3D, dtype, dataId}], dtype, customValues,\n        preventEagerUnpackingOfOutput, customTexShape);\n    return {dtype, shape, dataId: out.dataId};\n  }\n\n  runWebGLProgram(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype: DataType,\n      customUniformValues?: number[][], preventEagerUnpackingOfOutput = false,\n      customTexShape?: [number, number]): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.texData.get(output.dataId);\n    if (program.packedOutput) {\n      outData.isPacked = true;\n    }\n    if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n      const texelShape = customTexShape != null ?\n          customTexShape :\n          tex_util.getDenseTexShape(program.outputShape);\n      // For a densely packed output, we explicitly set texShape\n      // so it doesn't get assigned later according to our typical packing\n      // scheme wherein a single texel can only contain values from adjacent\n      // rows/cols.\n      outData.texShape = texelShape.map(d => d * 2) as [number, number];\n    }\n    if (program.outTexUsage != null) {\n      outData.usage = program.outTexUsage;\n    }\n\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    const dataToDispose: TensorInfo[] = [];\n    const inputsData: TensorData[] = inputs.map(input => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n\n      let texData = this.texData.get(input.dataId);\n\n      if (texData.texture == null) {\n        if (!program.packedInputs &&\n            util.sizeFromShape(input.shape) <=\n                env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n          // Upload small tensors that live on the CPU as uniforms, not as\n          // textures. Do this only when the environment supports 32bit floats\n          // due to problems when comparing 16bit floats with 32bit floats.\n          // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n          // possible for packed shaders to sample from uniforms.\n          return {\n            shape: input.shape,\n            texData: null,\n            isUniform: true,\n            uniformValues: texData.values as TypedArray\n          };\n        }\n\n        // This ensures that if a packed program's inputs have not yet been\n        // uploaded to the GPU, they get uploaded as packed right off the bat.\n        if (program.packedInputs) {\n          texData.isPacked = true;\n          texData.shape = input.shape;\n        }\n      }\n\n      this.uploadToGPU(input.dataId);\n      if (!!texData.isPacked !== !!program.packedInputs) {\n        input = texData.isPacked ? this.unpackTensor(input) :\n                                   this.packTensor(input);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n      } else if (\n          texData.isPacked &&\n          !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n        // This is a special case where a texture exists for a tensor\n        // but the shapes are incompatible (due to packing constraints) because\n        // the tensor did not have a chance to go through the packed reshape\n        // shader. This only happens when we reshape the *same* tensor to form\n        // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n        // case will disappear once packed uploading is the default.\n\n        const savedInput = input;\n        const targetShape = input.shape;\n\n        input.shape = texData.shape;\n        input = this.packedReshape(input as Tensor, targetShape);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n\n        savedInput.shape = targetShape;\n      }\n\n      return {shape: input.shape, texData, isUniform: false};\n    });\n\n    this.uploadToGPU(output.dataId);\n    const outputData:\n        TensorData = {shape: output.shape, texData: outData, isUniform: false};\n    const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    const binary = this.getAndSaveBinary(key, () => {\n      return gpgpu_math.compileProgram(\n          this.gpgpu, program, inputsData, outputData);\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    let query: WebGLQuery|CPUTimerQuery;\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    if (!env().get('ENGINE_COMPILE_ONLY')) {\n      gpgpu_math.runProgram(\n          this.gpgpu, binary, inputsData, outputData, customUniformValues);\n    }\n\n    dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(\n          {name: program.constructor.name, query: this.getQueryTime(query)});\n    }\n\n    const glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n    // Manually GL flush requested\n    if (glFlushThreshold > 0) {\n      const time = util.now();\n      if ((time - this.lastGlFlushTime) > glFlushThreshold) {\n        this.gpgpu.gl.flush();\n        this.lastGlFlushTime = time;\n      }\n    }\n\n    if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n        preventEagerUnpackingOfOutput === false) {\n      const unpacked = this.unpackTensor(output);\n      this.disposeIntermediateTensorInfo(output);\n      return unpacked;\n    }\n    return output;\n  }\n\n  compileAndRun(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype?: DataType,\n      customUniformValues?: number[][],\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    outputDtype = outputDtype || inputs[0].dtype;\n    const outInfo = this.runWebGLProgram(\n        program, inputs, outputDtype, customUniformValues,\n        preventEagerUnpackingOfOutput);\n    return outInfo;\n  }\n\n  private getAndSaveBinary(key: string, getBinary: () => GPGPUBinary):\n      GPGPUBinary {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n    return this.binaryCache[key];\n  }\n\n  getTextureManager(): TextureManager {\n    return this.textureManager;\n  }\n\n  private disposed = false;\n\n  override dispose() {\n    if (this.disposed) {\n      return;\n    }\n    // Avoid disposing the compiled webgl programs during unit testing because\n    // it slows down test execution.\n    if (!env().getBool('IS_TEST')) {\n      const allKeys = Object.keys(this.binaryCache);\n      allKeys.forEach(key => {\n        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        delete this.binaryCache[key];\n      });\n    }\n    this.textureManager.dispose();\n    if (this.canvas != null &&\n        (typeof (HTMLCanvasElement) !== 'undefined' &&\n         this.canvas instanceof HTMLCanvasElement)) {\n      this.canvas.remove();\n    } else {\n      this.canvas = null;\n    }\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.program = null;\n      this.gpgpu.dispose();\n    }\n    this.disposed = true;\n  }\n\n  override floatPrecision(): 16|32 {\n    if (this.floatPrecisionValue == null) {\n      this.floatPrecisionValue = tidy(() => {\n        if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n          // Momentarily switching DEBUG flag to false so we don't throw an\n          // error trying to upload a small value.\n          const debugFlag = env().getBool('DEBUG');\n          env().set('DEBUG', false);\n          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n          env().set('DEBUG', debugFlag);\n\n          if (underflowCheckValue > 0) {\n            return 32;\n          }\n        }\n        return 16;\n      });\n    }\n    return this.floatPrecisionValue;\n  }\n\n  /** Returns the smallest representable number.  */\n  override epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  uploadToGPU(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    const {shape, dtype, values, texture, usage, isPacked} = texData;\n\n    if (texture != null) {\n      // Array is already on GPU. No-op.\n      return;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let texShape = texData.texShape;\n    if (texShape == null) {\n      // This texShape may not be the final texture shape. For packed or dense\n      // textures, the texShape will be changed when textures are created.\n      texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n      texData.texShape = texShape;\n    }\n\n    if (values != null) {\n      const shapeAs3D = webgl_util.getShapeAs3D(shape);\n\n      let program;\n      let width = texShape[1], height = texShape[0];\n      const isByteArray =\n          values instanceof Uint8Array || values instanceof Uint8ClampedArray;\n\n      // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we\n      // need to make sure the upload uses the same packed size\n      if (isPacked || !isByteArray) {\n        [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(\n            texShape[0], texShape[1]);\n      }\n\n      if (isPacked) {\n        program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);\n      } else {\n        program = new EncodeMatrixProgram(shapeAs3D, isByteArray);\n      }\n\n      // TexShape for float array needs to be the original shape, which byte\n      // array needs to be packed size. This allow the data upload shape to be\n      // matched with texture creation logic.\n      const tempDenseInputTexShape: [number, number] =\n          isByteArray ? [height, width] : texShape;\n      const tempDenseInputHandle =\n          this.makeTensorInfo(tempDenseInputTexShape, dtype);\n      const tempDenseInputTexData =\n          this.texData.get(tempDenseInputHandle.dataId);\n      if (isByteArray) {\n        tempDenseInputTexData.usage = TextureUsage.PIXELS;\n      } else {\n        tempDenseInputTexData.usage = TextureUsage.UPLOAD;\n      }\n      tempDenseInputTexData.texShape = tempDenseInputTexShape;\n      this.gpgpu.uploadDenseMatrixToTexture(\n          this.getTexture(tempDenseInputHandle.dataId), width, height,\n          values as TypedArray);\n\n      const customValues = [[height, width]];\n      // We want the output to remain packed regardless of the value of\n      // WEBGL_PACK.\n      const preventEagerUnpacking = true;\n      const encodedOutputTarget = this.runWebGLProgram(\n          program, [tempDenseInputHandle], dtype, customValues,\n          preventEagerUnpacking);\n\n      // Have the original texture assume the identity of the encoded output.\n      const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n      texData.texShape = outputTexData.texShape;\n      texData.isPacked = outputTexData.isPacked;\n      texData.usage = outputTexData.usage;\n\n      if (!env().get('ENGINE_COMPILE_ONLY')) {\n        texData.texture = outputTexData.texture;\n        // Once uploaded, don't store the values on cpu.\n        texData.values = null;\n        this.texData.delete(encodedOutputTarget.dataId);\n      } else {\n        this.disposeData(encodedOutputTarget.dataId);\n      }\n\n      this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += util.now() - start;\n      }\n    } else {\n      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n      texData.texture = newTexture;\n    }\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, float32Values?: Float32Array):\n      TypedArray {\n    const texData = this.texData.get(dataId);\n    const {dtype} = texData;\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype as 'float32');\n    }\n    return texData.values as TypedArray;\n  }\n\n  private acquireTexture(\n      texShape: [number, number], texType: TextureUsage, dtype: DataType,\n      isPacked: boolean): Texture {\n    this.numBytesInGPU += this.computeBytes(texShape, dtype);\n    if (!this.warnedAboutMemory &&\n        this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n      this.warnedAboutMemory = true;\n      console.warn(\n          `High memory usage in GPU: ${mb} MB, ` +\n          `most likely due to a memory leak`);\n    }\n    return this.textureManager.acquireTexture(texShape, texType, isPacked);\n  }\n\n  private computeBytes(shape: [number, number], dtype: DataType) {\n    return shape[0] * shape[1] * util.bytesPerElement(dtype);\n  }\n\n  checkCompileCompletion() {\n    for (const [, binary] of Object.entries(this.binaryCache)) {\n      this.checkCompletion_(binary);\n    }\n  }\n\n  async checkCompileCompletionAsync(): Promise<boolean[]> {\n    const ps = [];\n    if (this.gpgpu.parallelCompilationExtension) {\n      for (const [, binary] of Object.entries(this.binaryCache)) {\n        ps.push(this.checkCompletionAsync_(binary));\n      }\n      return Promise.all(ps);\n    } else {\n      for (const [, binary] of Object.entries(this.binaryCache)) {\n        const p: Promise<boolean> = new Promise((resolve) => {\n          try {\n            this.checkCompletion_(binary);\n            resolve(true);\n          } catch (error) {\n            throw error;\n          }\n        });\n        ps.push(p);\n      }\n      return Promise.all(ps);\n    }\n  }\n\n  private async checkCompletionAsync_(binary: GPGPUBinary): Promise<boolean> {\n    if (this.gpgpu.gl.getProgramParameter(\n            binary.webGLProgram,\n            this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {\n      return this.checkCompletion_(binary);\n    } else {\n      await nextFrame();\n      return this.checkCompletionAsync_(binary);\n    }\n  }\n\n  private checkCompletion_(binary: GPGPUBinary): boolean {\n    if (this.gpgpu.gl.getProgramParameter(\n            binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {\n      console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));\n      if (this.gpgpu.gl.getShaderParameter(\n              binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {\n        webgl_util.logShaderSourceAndInfoLog(\n            binary.source,\n            this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n      }\n      throw new Error('Failed to link vertex and fragment shaders.');\n    }\n    return true;\n  }\n\n  getUniformLocations() {\n    for (const binary of Object.values(this.binaryCache)) {\n      // TODO: Iterating through all binaries to build VAOs is supposed to be in\n      // a seperate function, like 'setVaos'. However, to avoid breaking changes\n      // for the users using parallel compile feature now, buildVao is silently\n      // added here.\n      this.gpgpu.buildVao(binary.webGLProgram);\n\n      const {\n        variablesLocations,\n        customUniformLocations,\n        infLoc,\n        nanLoc,\n        outShapeLocation,\n        outShapeStridesLocation,\n        outTexShapeLocation\n      } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);\n      binary.variablesLocations = variablesLocations;\n      binary.customUniformLocations = customUniformLocations;\n      binary.infLoc = infLoc;\n      binary.nanLoc = nanLoc;\n      binary.outShapeLocation = outShapeLocation;\n      binary.outShapeStridesLocation = outShapeStridesLocation;\n      binary.outTexShapeLocation = outTexShapeLocation;\n    }\n  }\n\n  /**\n   * Create a TF.js tensor out of an existing WebGL texture. A new texture will\n   * be created.\n   */\n  override createTensorFromGPUData(\n      values: WebGLData, shape: number[], dtype: DataType): Tensor {\n    values.channels = values.channels || 'RGBA';\n    const {texture, height, width, channels} = values;\n    const backend = engine().backend as MathBackendWebGL;\n\n    // Have to throw an error, otherwise WebGL just warns and returns wrong\n    // values.\n    if (!backend.gpgpu.gl.isTexture(texture)) {\n      throw new Error(\n          `The texture is invalid. Also, please make sure the texture and ` +\n          `the TFJS WebGL backend are using the same canvas. If you want to ` +\n          `use your own custom canvas, you have to create and use the custom ` +\n          `TFJS WebGL backend created from the canvas through ` +\n          `'new tf.MathBackendWebGL(customCanvas)'.`);\n    }\n\n    const dataId =\n        backend.writeTexture(texture, shape, dtype, height, width, channels);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, backend);\n  }\n}\n\nfunction float32ToTypedArray<D extends NumericDataType>(\n    a: Float32Array, dtype: D): tf.DataTypeMap[D] {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a as tf.DataTypeMap[D];\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    const result = (dtype === 'int32') ? new Int32Array(a.length) :\n                                         new Uint8Array(a.length);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result as tf.DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}