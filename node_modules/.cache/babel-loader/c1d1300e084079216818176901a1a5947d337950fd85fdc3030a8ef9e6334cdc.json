{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport var TextureManager = /*#__PURE__*/function () {\n  function TextureManager(gpgpu) {\n    _classCallCheck(this, TextureManager);\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    // Number of bytes that have been allocated and available for reuse.\n    this._numBytesFree = 0;\n    this.freeTextures = {};\n    this.usedTextures = {};\n    this.logEnabled = false;\n  }\n  _createClass(TextureManager, [{\n    key: \"acquireTexture\",\n    value: function acquireTexture(shapeRC, usage, isPacked) {\n      var physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n      var shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n      if (!(shapeKey in this.freeTextures)) {\n        this.freeTextures[shapeKey] = [];\n      }\n      if (!(shapeKey in this.usedTextures)) {\n        this.usedTextures[shapeKey] = [];\n      }\n      var texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n      if (this.freeTextures[shapeKey].length > 0) {\n        this.numFreeTextures--;\n        this.numUsedTextures++;\n        this._numBytesFree -= texBytes;\n        this.log();\n        var _newTexture = this.freeTextures[shapeKey].pop();\n        this.usedTextures[shapeKey].push(_newTexture);\n        return _newTexture;\n      }\n      var newTexture;\n      if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n        newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n        newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n        newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n        newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n      } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n        newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n      }\n      this.usedTextures[shapeKey].push(newTexture);\n      this.numUsedTextures++;\n      this._numBytesAllocated += texBytes;\n      this.log();\n      return newTexture;\n    }\n  }, {\n    key: \"releaseTexture\",\n    value: function releaseTexture(texture, shape, logicalTexType, isPacked) {\n      if (this.freeTextures == null) {\n        // Already disposed.\n        return;\n      }\n      var physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n      var shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n      if (!(shapeKey in this.freeTextures)) {\n        this.freeTextures[shapeKey] = [];\n      }\n      var texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n      var deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n      if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n        this.gpgpu.deleteMatrixTexture(texture.texture);\n        this._numBytesAllocated -= texBytes;\n      } else {\n        this.freeTextures[shapeKey].push(texture);\n        this.numFreeTextures++;\n        this._numBytesFree += texBytes;\n      }\n      this.numUsedTextures--;\n      var texList = this.usedTextures[shapeKey];\n      var texIndex = texList && texList.indexOf(texture);\n      if (texIndex == null || texIndex < 0) {\n        throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n      }\n      texList[texIndex] = texList[texList.length - 1];\n      texList.pop();\n      this.log();\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (!this.logEnabled) {\n        return;\n      }\n      var total = this.numFreeTextures + this.numUsedTextures;\n      console.log('Free/Used', \"\".concat(this.numFreeTextures, \" / \").concat(this.numUsedTextures), \"(\".concat(total, \")\"));\n      var freeRatio = this._numBytesFree / this._numBytesAllocated;\n      console.log(\"Bytes allocated: \".concat(this._numBytesAllocated));\n      console.log(\"Bytes unused: \".concat(this._numBytesFree, \" (\").concat(Math.round(100 * freeRatio), \"%)\"));\n    }\n  }, {\n    key: \"numBytesAllocated\",\n    get: function get() {\n      return this._numBytesAllocated;\n    }\n  }, {\n    key: \"numBytesFree\",\n    get: function get() {\n      return this._numBytesFree;\n    }\n  }, {\n    key: \"getNumUsedTextures\",\n    value: function getNumUsedTextures() {\n      return this.numUsedTextures;\n    }\n  }, {\n    key: \"getNumFreeTextures\",\n    value: function getNumFreeTextures() {\n      return this.numFreeTextures;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this = this;\n      if (this.freeTextures == null) {\n        // Already disposed.\n        return;\n      }\n      for (var texShape in this.freeTextures) {\n        this.freeTextures[texShape].forEach(function (tex) {\n          _this.gpgpu.deleteMatrixTexture(tex.texture);\n        });\n      }\n      for (var _texShape in this.usedTextures) {\n        this.usedTextures[_texShape].forEach(function (tex) {\n          _this.gpgpu.deleteMatrixTexture(tex.texture);\n        });\n      }\n      // TODO: Assign non-null value (empty object) to textures after disposed.\n      this.freeTextures = null;\n      this.usedTextures = null;\n      this.numUsedTextures = 0;\n      this.numFreeTextures = 0;\n      this._numBytesAllocated = 0;\n      this._numBytesFree = 0;\n    }\n  }]);\n  return TextureManager;\n}();\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  var glany = gl;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n  throw new Error(\"Unknown internal format \".concat(internalFormat));\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  var internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  var numElements;\n  if (isPacked) {\n    var _getPackedMatrixTextu = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]),\n      _getPackedMatrixTextu2 = _slicedToArray(_getPackedMatrixTextu, 2),\n      packedWidth = _getPackedMatrixTextu2[0],\n      packedHeight = _getPackedMatrixTextu2[1];\n    numElements = packedWidth * packedHeight;\n  } else {\n    var _getUnpackedMatrixTex = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]),\n      _getUnpackedMatrixTex2 = _slicedToArray(_getUnpackedMatrixTex, 2),\n      width = _getUnpackedMatrixTex2[0],\n      height = _getUnpackedMatrixTex2[1];\n    numElements = width * height;\n  }\n  var bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(\"Unknown physical texture type \".concat(physicalTexType));\n  }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(\"Unknown logical texture type \".concat(logicalTexType));\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return \"\".concat(shapeRowsCol[0], \"_\").concat(shapeRowsCol[1], \"_\").concat(physicalTexType, \"_\").concat(isPacked);\n}","map":{"version":3,"names":["env","getInternalFormatForFloat16MatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","getInternalFormatForFloat32MatrixTexture","getInternalFormatForPackedMatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","getPackedMatrixTextureShapeWidthHeight","getUnpackedMatrixTextureShapeWidthHeight","PhysicalTextureType","TextureUsage","TextureManager","gpgpu","_classCallCheck","numUsedTextures","numFreeTextures","_numBytesAllocated","_numBytesFree","freeTextures","usedTextures","logEnabled","_createClass","key","value","acquireTexture","shapeRC","usage","isPacked","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","texBytes","computeBytes","gl","textureConfig","length","log","newTexture","pop","push","PACKED_2X2_FLOAT32","createPackedMatrixTexture","PACKED_2X2_FLOAT16","createFloat16PackedMatrixTexture","UNPACKED_FLOAT32","createFloat32MatrixTexture","UNPACKED_FLOAT16","createFloat16MatrixTexture","PACKED_4X1_UNSIGNED_BYTE","createUnsignedBytesMatrixTexture","releaseTexture","texture","shape","logicalTexType","deleteTexThreshold","get","deleteMatrixTexture","texList","texIndex","indexOf","Error","total","console","concat","freeRatio","Math","round","getNumUsedTextures","getNumFreeTextures","dispose","_this","texShape","forEach","tex","numBytesForInternalFormat","internalFormat","glany","R32F","R16F","RGBA32F","RGBA","RGBA16F","RGBA8","internalFormatForPhysicalTexType","numElements","_getPackedMatrixTextu","_getPackedMatrixTextu2","_slicedToArray","packedWidth","packedHeight","_getUnpackedMatrixTex","_getUnpackedMatrixTex2","width","height","bytesPerElement","getPhysicalTextureForRendering","getBool","UPLOAD","RENDER","DOWNLOAD","PIXELS","shapeRowsCol"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\texture_manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture} from './gpgpu_util';\nimport {getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, Texture, TextureConfig, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private _numBytesAllocated = 0;\n  // Number of bytes that have been allocated and available for reuse.\n  private _numBytesFree = 0;\n  private freeTextures: Record<string, Texture[]> = {};\n  private usedTextures: Record<string, Texture[]> = {};\n  private logEnabled = false;\n\n  constructor(private readonly gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): Texture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].pop();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture: Texture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: Texture, shape: [number, number], logicalTexType: TextureUsage,\n      isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 &&\n        this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList && texList.indexOf(texture);\n    if (texIndex == null || texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList[texIndex] = texList[texList.length - 1];\n    texList.pop();\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${\n        Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated(): number {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree(): number {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    // TODO: Assign non-null value (empty object) to textures after disposed.\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\n\nfunction numBytesForInternalFormat(\n    gl: WebGLRenderingContext, internalFormat: number): number {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(\n    shape: [number, number], physicalTexType: PhysicalTextureType,\n    gl: WebGLRenderingContext, textureConfig: TextureConfig,\n    isPacked: boolean): number {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat =\n      internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n\n  let numElements: number;\n  if (isPacked) {\n    const [packedWidth, packedHeight] =\n        getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n\n  } else {\n    const [width, height] =\n        getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(\n    physicalTexType: PhysicalTextureType,\n    textureConfig: TextureConfig): number {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}