{"ast":null,"code":"import _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\n/**\r\n * Padding Layers.\r\n */\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\r\n * Pads the middle dimension of a 3D tensor.\r\n *\r\n * @param x Input `tf.Tensor` to be padded.\r\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\r\n *   end of the middle dimension (i.e., dimension 1).\r\n * @return A padded 3D `tf.Tensor`.\r\n */\nexport function temporalPadding(x, padding) {\n  return tidy(function () {\n    if (x.rank !== 3) {\n      throw new ValueError(\"temporalPadding expects input tensor to be 3-D, but received a \" + \"\".concat(x.rank, \"-D tensor.\"));\n    }\n    if (padding == null) {\n      padding = [1, 1];\n    }\n    if (padding.length !== 2) {\n      throw new ValueError(\"temporalPadding expects input padding pattern to be a length-2 \" + \"array, but received a length-\".concat(padding.length, \" array.\"));\n    }\n    var pattern = [[0, 0], padding, [0, 0]];\n    return tfc.pad(x, pattern);\n  });\n}\n/**\r\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\r\n *\r\n * @param x Input `tf.Tensor` to be padded.\r\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\r\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\r\n *   dimensions, respectively.\r\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\r\n * @return Padded 4D `tf.Tensor`.\r\n */\nexport function spatial2dPadding(x, padding, dataFormat) {\n  return tidy(function () {\n    if (x.rank !== 4) {\n      throw new ValueError(\"temporalPadding expects input tensor to be 4-D, but received a \" + \"\".concat(x.rank, \"-D tensor.\"));\n    }\n    if (padding == null) {\n      padding = [[1, 1], [1, 1]];\n    }\n    if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {\n      throw new ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' + 'each of which is an Array of two integers.');\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n      throw new ValueError(\"Unknown data format: \".concat(dataFormat, \". \") + \"Supported data formats are 'channelsLast' and 'channelsFirst.\");\n    }\n    var pattern;\n    if (dataFormat === 'channelsFirst') {\n      pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n    } else {\n      pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n    }\n    return tfc.pad(x, pattern);\n  });\n}\nexport var ZeroPadding2D = /*#__PURE__*/function (_Layer) {\n  _inherits(ZeroPadding2D, _Layer);\n  var _super = _createSuper(ZeroPadding2D);\n  function ZeroPadding2D(args) {\n    var _this;\n    _classCallCheck(this, ZeroPadding2D);\n    if (args == null) {\n      args = {};\n    }\n    _this = _super.call(this, args);\n    _this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat;\n    // TODO(cais): Maybe refactor the following logic surrounding `padding`\n    //   into a helper method.\n    if (args.padding == null) {\n      _this.padding = [[1, 1], [1, 1]];\n    } else if (typeof args.padding === 'number') {\n      _this.padding = [[args.padding, args.padding], [args.padding, args.padding]];\n    } else {\n      args.padding = args.padding;\n      if (args.padding.length !== 2) {\n        throw new ValueError(\"ZeroPadding2D expects padding to be a length-2 array, but \" + \"received a length-\".concat(args.padding.length, \" array.\"));\n      }\n      var heightPadding;\n      var widthPadding;\n      if (typeof args.padding[0] === 'number') {\n        heightPadding = [args.padding[0], args.padding[0]];\n        widthPadding = [args.padding[1], args.padding[1]];\n      } else {\n        args.padding = args.padding;\n        if (args.padding[0].length !== 2) {\n          throw new ValueError(\"ZeroPadding2D expects height padding to be a length-2 array, \" + \"but received a length-\".concat(args.padding[0].length, \" array.\"));\n        }\n        heightPadding = args.padding[0];\n        if (args.padding[1].length !== 2) {\n          throw new ValueError(\"ZeroPadding2D expects width padding to be a length-2 array, \" + \"but received a length-\".concat(args.padding[1].length, \" array.\"));\n        }\n        widthPadding = args.padding[1];\n      }\n      _this.padding = [heightPadding, widthPadding];\n    }\n    _this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n    return _this;\n  }\n  _createClass(ZeroPadding2D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var rows;\n      var cols;\n      if (this.dataFormat === 'channelsFirst') {\n        if (inputShape[2] != null && inputShape[2] >= 0) {\n          rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n        } else {\n          rows = null;\n        }\n        if (inputShape[3] != null && inputShape[3] >= 0) {\n          cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n        } else {\n          cols = null;\n        }\n        return [inputShape[0], inputShape[1], rows, cols];\n      } else {\n        if (inputShape[1] != null && inputShape[1] >= 0) {\n          rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n        } else {\n          rows = null;\n        }\n        if (inputShape[2] != null && inputShape[2] >= 0) {\n          cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n        } else {\n          cols = null;\n        }\n        return [inputShape[0], rows, cols, inputShape[3]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this2 = this;\n      return tidy(function () {\n        return spatial2dPadding(getExactlyOneTensor(inputs), _this2.padding, _this2.dataFormat);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        padding: this.padding,\n        dataFormat: this.dataFormat\n      };\n      var baseConfig = _get(_getPrototypeOf(ZeroPadding2D.prototype), \"getConfig\", this).call(this);\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n  return ZeroPadding2D;\n}(Layer);\n/** @nocollapse */\nZeroPadding2D.className = 'ZeroPadding2D';\nserialization.registerClass(ZeroPadding2D);","map":{"version":3,"names":["tfc","serialization","tidy","imageDataFormat","InputSpec","Layer","ValueError","getExactlyOneShape","getExactlyOneTensor","temporalPadding","x","padding","rank","concat","length","pattern","pad","spatial2dPadding","dataFormat","ZeroPadding2D","_Layer","_inherits","_super","_createSuper","args","_this","_classCallCheck","call","heightPadding","widthPadding","inputSpec","ndim","_createClass","key","value","computeOutputShape","inputShape","rows","cols","inputs","kwargs","_this2","getConfig","config","baseConfig","_get","_getPrototypeOf","prototype","Object","assign","className","registerClass"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-layers\\src\\layers\\padding.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Padding Layers.\n */\n\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, tidy} from '@tensorflow/tfjs-core';\n\nimport {imageDataFormat} from '../backend/common';\nimport {InputSpec, Layer, LayerArgs} from '../engine/topology';\nimport {ValueError} from '../errors';\nimport {DataFormat, Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../utils/types_utils';\n\n/**\n * Pads the middle dimension of a 3D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\n *   end of the middle dimension (i.e., dimension 1).\n * @return A padded 3D `tf.Tensor`.\n */\nexport function temporalPadding(x: Tensor, padding?: [number, number]): Tensor {\n  return tidy(() => {\n    if (x.rank !== 3) {\n      throw new ValueError(\n          `temporalPadding expects input tensor to be 3-D, but received a ` +\n          `${x.rank}-D tensor.`);\n    }\n\n    if (padding == null) {\n      padding = [1, 1];\n    }\n    if (padding.length !== 2) {\n      throw new ValueError(\n          `temporalPadding expects input padding pattern to be a length-2 ` +\n          `array, but received a length-${padding.length} array.`);\n    }\n\n    const pattern: Array<[number, number]> = [[0, 0], padding, [0, 0]];\n    return tfc.pad(x, pattern);\n  });\n}\n\n/**\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\n *   dimensions, respectively.\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\n * @return Padded 4D `tf.Tensor`.\n */\nexport function spatial2dPadding(\n    x: Tensor, padding?: [[number, number], [number, number]],\n    dataFormat?: DataFormat): Tensor {\n  return tidy(() => {\n    if (x.rank !== 4) {\n      throw new ValueError(\n          `temporalPadding expects input tensor to be 4-D, but received a ` +\n          `${x.rank}-D tensor.`);\n    }\n\n    if (padding == null) {\n      padding = [[1, 1], [1, 1]];\n    }\n    if (padding.length !== 2 || padding[0].length !== 2 ||\n        padding[1].length !== 2) {\n      throw new ValueError(\n          'spatial2dPadding expects `padding` to be an Array of two Arrays, ' +\n          'each of which is an Array of two integers.');\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n      throw new ValueError(\n          `Unknown data format: ${dataFormat}. ` +\n          `Supported data formats are 'channelsLast' and 'channelsFirst.`);\n    }\n\n    let pattern: Array<[number, number]>;\n    if (dataFormat === 'channelsFirst') {\n      pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n    } else {\n      pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n    }\n\n    return tfc.pad(x, pattern);\n  });\n}\n\nexport declare interface ZeroPadding2DLayerArgs extends LayerArgs {\n  /**\n   * Integer, or `Array` of 2 integers, or `Array` of 2 `Array`s, each of\n   * which is an `Array` of 2 integers.\n   * - If integer, the same symmetric padding is applied to width and height.\n   * - If `Array` of 2 integers, interpreted as two different symmetric values\n   *   for height and width:\n   *   `[symmetricHeightPad, symmetricWidthPad]`.\n   * - If `Array` of 2 `Array`s, interpreted as:\n   *   `[[topPad, bottomPad], [leftPad, rightPad]]`.\n   */\n  padding?: number|[number, number]|[[number, number], [number, number]];\n\n  /**\n   * One of `'channelsLast'` (default) and `'channelsFirst'`.\n   *\n   * The ordering of the dimensions in the inputs.\n   * `channelsLast` corresponds to inputs with shape\n   * `[batch, height, width, channels]` while `channelsFirst`\n   * corresponds to inputs with shape\n   * `[batch, channels, height, width]`.\n   */\n  dataFormat?: DataFormat;\n}\n\nexport class ZeroPadding2D extends Layer {\n  /** @nocollapse */\n  static className = 'ZeroPadding2D';\n  readonly dataFormat: DataFormat;\n  readonly padding: [[number, number], [number, number]];\n\n  constructor(args?: ZeroPadding2DLayerArgs) {\n    if (args == null) {\n      args = {};\n    }\n    super(args);\n\n    this.dataFormat =\n        args.dataFormat == null ? imageDataFormat() : args.dataFormat;\n    // TODO(cais): Maybe refactor the following logic surrounding `padding`\n    //   into a helper method.\n    if (args.padding == null) {\n      this.padding = [[1, 1], [1, 1]];\n    } else if (typeof args.padding === 'number') {\n      this.padding =\n          [[args.padding, args.padding], [args.padding, args.padding]];\n    } else {\n      args.padding = args.padding;\n      if (args.padding.length !== 2) {\n        throw new ValueError(\n            `ZeroPadding2D expects padding to be a length-2 array, but ` +\n            `received a length-${args.padding.length} array.`);\n      }\n\n      let heightPadding: [number, number];\n      let widthPadding: [number, number];\n      if (typeof args.padding[0] === 'number') {\n        heightPadding = [args.padding[0], args.padding[0]];\n        widthPadding = [args.padding[1] as number, args.padding[1] as number];\n      } else {\n        args.padding = args.padding as [[number, number], [number, number]];\n\n        if (args.padding[0].length !== 2) {\n          throw new ValueError(\n              `ZeroPadding2D expects height padding to be a length-2 array, ` +\n              `but received a length-${args.padding[0].length} array.`);\n        }\n        heightPadding = args.padding[0] as [number, number];\n\n        if (args.padding[1].length !== 2) {\n          throw new ValueError(\n              `ZeroPadding2D expects width padding to be a length-2 array, ` +\n              `but received a length-${args.padding[1].length} array.`);\n        }\n        widthPadding = args.padding[1] as [number, number];\n      }\n      this.padding = [heightPadding, widthPadding];\n    }\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n\n    let rows: number;\n    let cols: number;\n    if (this.dataFormat === 'channelsFirst') {\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n      if (inputShape[3] != null && inputShape[3] >= 0) {\n        cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      if (inputShape[1] != null && inputShape[1] >= 0) {\n        rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(\n        () => spatial2dPadding(\n            getExactlyOneTensor(inputs), this.padding, this.dataFormat));\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      padding: this.padding,\n      dataFormat: this.dataFormat,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(ZeroPadding2D);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}