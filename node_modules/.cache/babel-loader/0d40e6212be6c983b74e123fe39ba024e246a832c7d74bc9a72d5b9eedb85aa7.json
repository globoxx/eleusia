{"ast":null,"code":"import _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as util from '../util';\n/**\r\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\r\n * a large ArrayBuffer.\r\n *\r\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\r\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\r\n * weight tensors out of them. For small models, it's safe to concatenate all\r\n * the weight buffers into a single ArrayBuffer and then slice the weight\r\n * tensors out of it, but for large models, a different approach is needed.\r\n */\nexport var CompositeArrayBuffer = /*#__PURE__*/function () {\n  function CompositeArrayBuffer(buffers) {\n    _classCallCheck(this, CompositeArrayBuffer);\n    this.shards = [];\n    this.previousShardIndex = 0;\n    if (buffers == null) {\n      return;\n    }\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map(function (bufferOrTypedArray) {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n    this.bufferUniformSize = buffers[0].byteLength;\n    var start = 0;\n    for (var i = 0; i < buffers.length; i++) {\n      var buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 && buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n      // Create the shards, including their start and end points.\n      var end = start + buffer.byteLength;\n      this.shards.push({\n        buffer: buffer,\n        start: start,\n        end: end\n      });\n      start = end;\n    }\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n  _createClass(CompositeArrayBuffer, [{\n    key: \"slice\",\n    value: function slice() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteLength;\n      // If there are no shards, then the CompositeArrayBuffer was initialized\n      // with no data.\n      if (this.shards.length === 0) {\n        return new ArrayBuffer(0);\n      }\n      // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n      start = isNaN(Number(start)) ? 0 : start;\n      end = isNaN(Number(end)) ? 0 : end;\n      // Fix the bounds to within the array.\n      start = Math.max(0, start);\n      end = Math.min(this.byteLength, end);\n      if (end <= start) {\n        return new ArrayBuffer(0);\n      }\n      var startShardIndex = this.findShardForByte(start);\n      if (startShardIndex === -1) {\n        // This should not happen since the start and end indices are always\n        // within 0 and the composite array's length.\n        throw new Error(\"Could not find start shard for byte \".concat(start));\n      }\n      var size = end - start;\n      var outputBuffer = new ArrayBuffer(size);\n      var outputArray = new Uint8Array(outputBuffer);\n      var sliced = 0;\n      for (var i = startShardIndex; i < this.shards.length; i++) {\n        var shard = this.shards[i];\n        var globalStart = start + sliced;\n        var localStart = globalStart - shard.start;\n        var outputStart = sliced;\n        var globalEnd = Math.min(end, shard.end);\n        var localEnd = globalEnd - shard.start;\n        var outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);\n        outputArray.set(outputSlice, outputStart);\n        sliced += outputSlice.length;\n        if (end < shard.end) {\n          break;\n        }\n      }\n      return outputBuffer;\n    }\n    /**\r\n     * Get the index of the shard that contains the byte at `byteIndex`.\r\n     */\n  }, {\n    key: \"findShardForByte\",\n    value: function findShardForByte(byteIndex) {\n      if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {\n        return -1;\n      }\n      // If the buffers have a uniform size, compute the shard directly.\n      if (this.bufferUniformSize != null) {\n        this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n        return this.previousShardIndex;\n      }\n      // If the buffers don't have a uniform size, we need to search for the\n      // shard. That means we need a function to check where the byteIndex lies\n      // relative to a given shard.\n      function check(shard) {\n        if (byteIndex < shard.start) {\n          return -1;\n        }\n        if (byteIndex >= shard.end) {\n          return 1;\n        }\n        return 0;\n      }\n      // For efficiency, try the previous shard first.\n      if (check(this.shards[this.previousShardIndex]) === 0) {\n        return this.previousShardIndex;\n      }\n      // Otherwise, use a generic search function.\n      // This should almost never end up being used in practice since the weight\n      // entries should always be in order.\n      var index = search(this.shards, check);\n      if (index === -1) {\n        return -1;\n      }\n      this.previousShardIndex = index;\n      return this.previousShardIndex;\n    }\n  }], [{\n    key: \"join\",\n    value:\n    /**\r\n     * Concatenate a number of ArrayBuffers into one.\r\n     *\r\n     * @param buffers An array of ArrayBuffers to concatenate, or a single\r\n     *     ArrayBuffer.\r\n     * @returns Result of concatenating `buffers` in order.\r\n     */\n    function join(buffers) {\n      return new CompositeArrayBuffer(buffers).slice();\n    }\n  }]);\n  return CompositeArrayBuffer;\n}();\n/**\r\n * Search for an element of a sorted array.\r\n *\r\n * @param sortedArray The sorted array to search\r\n * @param compare A function to compare the current value against the searched\r\n *     value. Return 0 on a match, negative if the searched value is less than\r\n *     the value passed to the function, and positive if the searched value is\r\n *     greater than the value passed to the function.\r\n * @returns The index of the element, or -1 if it's not in the array.\r\n */\nexport function search(sortedArray, compare) {\n  // Binary search\n  var min = 0;\n  var max = sortedArray.length;\n  while (min <= max) {\n    var middle = Math.floor((max - min) / 2) + min;\n    var side = compare(sortedArray[middle]);\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["util","CompositeArrayBuffer","buffers","_classCallCheck","shards","previousShardIndex","Array","map","bufferOrTypedArray","isTypedArray","buffer","length","bufferUniformSize","byteLength","start","i","undefined","end","push","_createClass","key","value","slice","arguments","ArrayBuffer","isNaN","Number","Math","max","min","startShardIndex","findShardForByte","Error","concat","size","outputBuffer","outputArray","Uint8Array","sliced","shard","globalStart","localStart","outputStart","globalEnd","localEnd","outputSlice","set","byteIndex","floor","check","index","search","join","sortedArray","compare","middle","side"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\io\\composite_array_buffer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TypedArray} from '../types';\nimport * as util from '../util';\n\ntype BufferShard = {\n  start: number,\n  end: number,\n  buffer: ArrayBuffer,\n};\n\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\n\nexport class CompositeArrayBuffer {\n  private shards: BufferShard[] = [];\n  private previousShardIndex = 0;\n  private bufferUniformSize?: number;\n  public readonly byteLength: number;\n\n  /**\n   * Concatenate a number of ArrayBuffers into one.\n   *\n   * @param buffers An array of ArrayBuffers to concatenate, or a single\n   *     ArrayBuffer.\n   * @returns Result of concatenating `buffers` in order.\n   */\n  static join(buffers?: ArrayBuffer[] | ArrayBuffer) {\n    return new CompositeArrayBuffer(buffers).slice();\n  }\n\n  constructor(buffers?: ArrayBuffer | ArrayBuffer[] | TypedArray |\n    TypedArray[]) {\n    if (buffers == null) {\n      return;\n    }\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map((bufferOrTypedArray) => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 &&\n        buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({ buffer, start, end });\n      start = end;\n    }\n\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n\n  slice(start = 0, end = this.byteLength): ArrayBuffer {\n    // If there are no shards, then the CompositeArrayBuffer was initialized\n    // with no data.\n    if (this.shards.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n\n      const outputSlice = new Uint8Array(shard.buffer, localStart,\n                                         localEnd - localStart);\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  private findShardForByte(byteIndex: number): number {\n    if (this.shards.length === 0 || byteIndex < 0 ||\n      byteIndex >= this.byteLength) {\n      return -1;\n    }\n\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard: BufferShard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search<T>(sortedArray: T[], compare: (t: T) => number): number {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}