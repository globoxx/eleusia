{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, upcastType } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { complex } from '../kernels/Complex';\nimport { LEAKYRELU, LEAKYRELU_PACKED } from '../kernels/LeakyRelu';\nimport { PRELU, PRELU_PACKED } from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport { UnaryOpPackedProgram } from '../unaryop_packed_gpu';\nexport var CHECK_NAN_SNIPPET_UNARY = \"if (isnan(x)) return x;\";\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc(_ref) {\n  var opSnippet = _ref.opSnippet,\n    packedOpSnippet = _ref.packedOpSnippet,\n    cpuKernelImpl = _ref.cpuKernelImpl,\n    dtype = _ref.dtype;\n  return function (_ref2) {\n    var inputs = _ref2.inputs,\n      backend = _ref2.backend;\n    var x = inputs.x;\n    var webglBackend = backend;\n    var $dtype = dtype || x.dtype;\n    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      var xData = webglBackend.texData.get(x.dataId);\n      var outValues = cpuKernelImpl(xData.values, $dtype);\n      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n    var shouldUsePackedProgram = env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n    var program;\n    if (shouldUsePackedProgram) {\n      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n    } else {\n      program = new UnaryOpProgram(x.shape, opSnippet);\n    }\n    return webglBackend.runWebGLProgram(program, [x], $dtype);\n  };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(_ref3) {\n  var opSnippet = _ref3.opSnippet,\n    packedOpSnippet = _ref3.packedOpSnippet,\n    _ref3$checkOutOfBound = _ref3.checkOutOfBounds,\n    checkOutOfBounds = _ref3$checkOutOfBound === void 0 ? false : _ref3$checkOutOfBound,\n    _ref3$supportsComplex = _ref3.supportsComplex,\n    supportsComplex = _ref3$supportsComplex === void 0 ? false : _ref3$supportsComplex,\n    cpuKernelImpl = _ref3.cpuKernelImpl,\n    dtype = _ref3.dtype;\n  return function (_ref4) {\n    var inputs = _ref4.inputs,\n      backend = _ref4.backend;\n    var a = inputs.a,\n      b = inputs.b;\n    var webglBackend = backend;\n    if (supportsComplex && a.dtype === 'complex64') {\n      var aData = webglBackend.texData.get(a.dataId);\n      var bData = webglBackend.texData.get(b.dataId);\n      var _map = [[aData.complexTensorInfos.real, bData.complexTensorInfos.real], [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]].map(function (complexParts) {\n          var _complexParts = _slicedToArray(complexParts, 2),\n            aPart = _complexParts[0],\n            bPart = _complexParts[1];\n          var aHandle = {\n            dataId: aPart.dataId,\n            dtype: aPart.dtype,\n            shape: a.shape\n          };\n          var bHandle = {\n            dataId: bPart.dataId,\n            dtype: bPart.dtype,\n            shape: b.shape\n          };\n          var program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n          return webglBackend.runWebGLProgram(program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n        }),\n        _map2 = _slicedToArray(_map, 2),\n        real = _map2[0],\n        imag = _map2[1];\n      var complexOutput = complex({\n        inputs: {\n          real: real,\n          imag: imag\n        },\n        backend: webglBackend\n      });\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag);\n      // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n      return complexOutput;\n    }\n    var $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if ((a.dtype === 'string' || b.dtype === 'string' || webglBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {\n      var aVals = webglBackend.texData.get(a.dataId).values;\n      var bVals = webglBackend.texData.get(b.dataId).values;\n      var decodedAVals = a.dtype === 'string' ?\n      // tslint:disable-next-line: no-any\n      backend_util.fromUint8ToStringArray(aVals) : aVals;\n      var decodedBVals = a.dtype === 'string' ?\n      // tslint:disable-next-line: no-any\n      backend_util.fromUint8ToStringArray(bVals) : bVals;\n      var _cpuKernelImpl = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype),\n        _cpuKernelImpl2 = _slicedToArray(_cpuKernelImpl, 2),\n        outValues = _cpuKernelImpl2[0],\n        outShape = _cpuKernelImpl2[1];\n      var out = webglBackend.makeTensorInfo(outShape, $dtype);\n      var outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n    var shouldUsePackedProgram = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') && packedOpSnippet != null;\n    var program;\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\nexport function mapActivationToShaderProgram(activation) {\n  var packed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return PRELU_PACKED;\n    }\n    return PRELU;\n  } else if (activation === 'leakyrelu') {\n    if (packed) {\n      return LEAKYRELU_PACKED;\n    }\n    return LEAKYRELU;\n  } else if (activation === 'sigmoid') {\n    if (packed) {\n      return unary_packed_op.SIGMOID;\n    }\n    return unary_op.SIGMOID;\n  }\n  throw new Error(\"Activation \".concat(activation, \" has not been implemented for the WebGL backend.\"));\n}","map":{"version":3,"names":["backend_util","env","upcastType","BinaryOpProgram","BinaryOpPackedProgram","complex","LEAKYRELU","LEAKYRELU_PACKED","PRELU","PRELU_PACKED","unary_op","UnaryOpProgram","unary_packed_op","UnaryOpPackedProgram","CHECK_NAN_SNIPPET_UNARY","unaryKernelFunc","_ref","opSnippet","packedOpSnippet","cpuKernelImpl","dtype","_ref2","inputs","backend","x","webglBackend","$dtype","shouldExecuteOnCPU","xData","texData","get","dataId","outValues","values","makeTensorInfo","shape","shouldUsePackedProgram","getBool","program","runWebGLProgram","binaryKernelFunc","_ref3","_ref3$checkOutOfBound","checkOutOfBounds","_ref3$supportsComplex","supportsComplex","_ref4","a","b","aData","bData","_map","complexTensorInfos","real","imag","map","complexParts","_complexParts","_slicedToArray","aPart","bPart","aHandle","bHandle","_map2","complexOutput","disposeIntermediateTensorInfo","aVals","bVals","decodedAVals","fromUint8ToStringArray","decodedBVals","_cpuKernelImpl","_cpuKernelImpl2","outShape","out","outData","mapActivationToShaderProgram","activation","packed","arguments","length","undefined","LINEAR","RELU","ELU","RELU6","SIGMOID","Error","concat"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-webgl\\src\\kernel_utils\\kernel_funcs_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { backend_util, BinaryInputs, DataType, env, KernelFunc, TypedArray, UnaryInputs, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {complex} from '../kernels/Complex';\nimport {LEAKYRELU, LEAKYRELU_PACKED} from '../kernels/LeakyRelu';\nimport {PRELU, PRELU_PACKED} from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nimport {SimpleBinaryKernelImplCPU, SimpleUnaryKernelImplCPU} from './shared';\n\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\n\ntype UnaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  cpuKernelImpl?: SimpleUnaryKernelImplCPU,\n  dtype?: DataType,\n};\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc(\n    {opSnippet, packedOpSnippet, cpuKernelImpl, dtype}: UnaryKernelFuncConfig):\n    KernelFunc {\n  return ({inputs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const $dtype = dtype || x.dtype;\n    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      const xData = webglBackend.texData.get(x.dataId);\n      const outValues = cpuKernelImpl(xData.values as TypedArray, $dtype);\n      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n    } else {\n      program = new UnaryOpProgram(x.shape, opSnippet);\n    }\n\n    return webglBackend.runWebGLProgram(program, [x], $dtype);\n  };\n}\n\ntype BinaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  checkOutOfBounds?: boolean,\n  supportsComplex?: boolean,\n  cpuKernelImpl?: SimpleBinaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc({\n  opSnippet,\n  packedOpSnippet,\n  checkOutOfBounds = false,\n  supportsComplex = false,\n  cpuKernelImpl,\n  dtype\n}: BinaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n\n      const [real, imag] = [\n        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n      ].map(complexParts => {\n        const [aPart, bPart] = complexParts;\n\n        const aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        const bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n\n        const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(\n            program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      });\n\n      const complexOutput =\n          complex({inputs: {real, imag}, backend: webglBackend});\n\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag);\n\n      // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if ((a.dtype === 'string' || b.dtype === 'string' ||\n         webglBackend.shouldExecuteOnCPU([a, b])) &&\n        cpuKernelImpl != null) {\n      const aVals = webglBackend.texData.get(a.dataId).values as TypedArray;\n      const bVals = webglBackend.texData.get(b.dataId).values as TypedArray;\n\n      const decodedAVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(aVals as any as Uint8Array[]) :\n          aVals;\n      const decodedBVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(bVals as any as Uint8Array[]) :\n          bVals;\n      const [outValues, outShape] =\n          cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n\n      const out = webglBackend.makeTensorInfo(outShape, $dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n        packedOpSnippet != null;\n    let program: BinaryOpProgram|BinaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(\n          packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\n\nexport function mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false): string {\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return PRELU_PACKED;\n    }\n    return PRELU;\n  } else if (activation === 'leakyrelu') {\n    if (packed) {\n      return LEAKYRELU_PACKED;\n    }\n    return LEAKYRELU;\n  } else if (activation === 'sigmoid') {\n    if (packed) {\n      return unary_packed_op.SIGMOID;\n    }\n    return unary_op.SIGMOID;\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGL backend.`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}