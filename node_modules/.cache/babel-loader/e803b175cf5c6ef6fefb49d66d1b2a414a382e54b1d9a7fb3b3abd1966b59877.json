{"ast":null,"code":"import _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport var ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext() {\n    var weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var parseNodeNameCache = arguments.length > 4 ? arguments[4] : undefined;\n    _classCallCheck(this, ExecutionContext);\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.parseNodeNameCache = parseNodeNameCache;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n  _createClass(ExecutionContext, [{\n    key: \"newFrame\",\n    value: function newFrame(id, frameName) {\n      return {\n        id: id,\n        frameName: frameName,\n        iterationId: 0\n      };\n    }\n    /**\n     * Set the current context\n     * @param contexts: ExecutionContextInfo[] the current path of execution\n     * frames\n     */\n  }, {\n    key: \"currentContext\",\n    get: function get() {\n      return this.contexts;\n    }\n    /**\n     * Returns the current context in string format.\n     */,\n    set: function set(contexts) {\n      if (this.contexts !== contexts) {\n        this.contexts = contexts;\n        this.generateCurrentContextIds();\n      }\n    }\n  }, {\n    key: \"currentContextId\",\n    get: function get() {\n      return this._currentContextIds[0];\n    }\n    /**\n     * Returns the current context and all parent contexts in string format.\n     * This allow access to the nodes in the current and parent frames.\n     */\n  }, {\n    key: \"currentContextIds\",\n    get: function get() {\n      return this._currentContextIds;\n    }\n  }, {\n    key: \"generateCurrentContextIds\",\n    value: function generateCurrentContextIds() {\n      var names = [];\n      for (var i = 0; i < this.contexts.length - 1; i++) {\n        var contexts = this.contexts.slice(0, this.contexts.length - i);\n        names.push(this.contextIdforContexts(contexts));\n      }\n      names.push('');\n      this._currentContextIds = names;\n    }\n  }, {\n    key: \"contextIdforContexts\",\n    value: function contextIdforContexts(contexts) {\n      return contexts ? contexts.map(function (context) {\n        return context.id === 0 && context.iterationId === 0 ? '' : \"\".concat(context.frameName, \"-\").concat(context.iterationId);\n      }).join('/') : '';\n    }\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n  }, {\n    key: \"enterFrame\",\n    value: function enterFrame(frameId) {\n      if (this.contexts) {\n        this.lastId++;\n        this.contexts = this.contexts.slice();\n        this.contexts.push(this.newFrame(this.lastId, frameId));\n        this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n      }\n    }\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n  }, {\n    key: \"exitFrame\",\n    value: function exitFrame() {\n      if (this.contexts && this.contexts.length > 1) {\n        this.contexts = this.contexts.slice();\n        this.contexts.splice(-1);\n        this.currentContextIds.shift();\n      } else {\n        throw new Error('Cannot exit frame, the context is empty');\n      }\n    }\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n  }, {\n    key: \"nextIteration\",\n    value: function nextIteration() {\n      if (this.contexts && this.contexts.length > 0) {\n        this.contexts = this.contexts.slice();\n        this.lastId++;\n        var context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n        context.iterationId += 1;\n        context.id = this.lastId;\n        this.contexts.splice(-1, 1, context);\n        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n      } else {\n        throw new Error('Cannot increase frame iteration, the context is empty');\n      }\n    }\n  }, {\n    key: \"getWeight\",\n    value: function getWeight(name) {\n      return this.weightMap[name];\n    }\n  }, {\n    key: \"addTensorArray\",\n    value: function addTensorArray(tensorArray) {\n      this.tensorArrayMap[tensorArray.id] = tensorArray;\n    }\n  }, {\n    key: \"getTensorArray\",\n    value: function getTensorArray(id) {\n      return this.tensorArrayMap[id];\n    }\n  }, {\n    key: \"addTensorList\",\n    value: function addTensorList(tensorList) {\n      this.tensorListMap[tensorList.id] = tensorList;\n    }\n  }, {\n    key: \"getTensorList\",\n    value: function getTensorList(id) {\n      return this.tensorListMap[id];\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(keepIds) {\n      for (var key in this.tensorArrayMap) {\n        this.tensorArrayMap[key].clearAndClose(keepIds);\n      }\n      for (var _key in this.tensorListMap) {\n        this.tensorListMap[_key].clearAndClose(keepIds);\n      }\n    }\n  }]);\n  return ExecutionContext;\n}();","map":{"version":3,"names":["ExecutionContext","weightMap","arguments","length","undefined","tensorArrayMap","tensorListMap","functionMap","parseNodeNameCache","_classCallCheck","rootContext","id","frameName","iterationId","contexts","lastId","generateCurrentContextIds","_createClass","key","value","newFrame","get","set","_currentContextIds","names","i","slice","push","contextIdforContexts","map","context","concat","join","enterFrame","frameId","unshift","exitFrame","splice","currentContextIds","shift","Error","nextIteration","Object","assign","getWeight","name","addTensorArray","tensorArray","getTensorArray","addTensorList","tensorList","getTensorList","dispose","keepIds","clearAndClose"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\executor\\execution_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap, TensorArrayMap, TensorListMap} from '../data/types';\n\nimport {TensorArray} from './tensor_array';\nimport {TensorList} from './tensor_list';\nimport {FunctionExecutor} from './types';\n\nexport interface ExecutionContextInfo {\n  id: number;           // the unique id of the context info\n  frameName: string;    // The frame name of the loop, this comes from\n                        // the TensorFlow NodeDef.\n  iterationId: number;  // The iteration id of the loop\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  private rootContext = {id: 0, frameName: '', iterationId: 0};\n  private contexts: ExecutionContextInfo[] = [this.rootContext];\n  private lastId = 0;\n  private _currentContextIds: string[];\n\n  constructor(\n      readonly weightMap: NamedTensorsMap = {},\n      readonly tensorArrayMap: TensorArrayMap = {},\n      readonly tensorListMap: TensorListMap = {},\n      readonly functionMap: {[key: string]: FunctionExecutor} = {},\n      readonly parseNodeNameCache?: Map<string, [string, number, string?]>) {\n    this.generateCurrentContextIds();\n  }\n\n  private newFrame(id: number, frameName: string) {\n    return {id, frameName, iterationId: 0};\n  }\n\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts: ExecutionContextInfo[]) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext(): ExecutionContextInfo[] {\n    return this.contexts;\n  }\n\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId(): string {\n    return this._currentContextIds[0];\n  }\n\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds(): string[] {\n    return this._currentContextIds;\n  }\n\n  private generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  private contextIdforContexts(contexts: ExecutionContextInfo[]) {\n    return contexts ?\n        contexts\n            .map(\n                context => (context.id === 0 && context.iterationId === 0) ?\n                    '' :\n                    `${context.frameName}-${context.iterationId}`)\n            .join('/') :\n        '';\n  }\n\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId: string) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context =\n          Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(\n          0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name: string): Tensor[] {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray: TensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id: number): TensorArray {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList: TensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id: number): TensorList {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds: Set<number>) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}