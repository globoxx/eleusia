{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\nimport * as generic_utils from '../utils/generic_utils';\n// tslint:enable\n/**\r\n * Test whether a value in an array is the name of a LayersModel or Layer.\r\n * @param key The key name that the value is found under. Note that the key\r\n *   may not be at the level immediately above the value, if the value is in a\r\n *   nested array.\r\n * @param index Index of the value in the Array that it is found in.\r\n * @param value The value object.\r\n * @returns A boolean indicating whether value is a name.\r\n */\nfunction isArrayItemInputOrOutputName(key, index, value) {\n  return (key === 'inboundNodes' || key === 'outputLayers' || key === 'inputLayers') && index === 0 && typeof value === 'string';\n}\n/**\r\n * Convert a Pythonic config object to TypeScript config object.\r\n * @param pythonicConfig The config object to convert.\r\n * @param key Optional key name of the object being converted.\r\n * @returns Result of the conversion.\r\n */\nexport function convertPythonicToTs(pythonicConfig, key) {\n  if (pythonicConfig === null) {\n    return null;\n  } else if (typeof pythonicConfig === 'string') {\n    return generic_utils.toCamelCase(pythonicConfig);\n  } else if (typeof pythonicConfig === 'number' || typeof pythonicConfig === 'boolean') {\n    return pythonicConfig;\n  } else if (pythonicConfig instanceof Array) {\n    var tsArray = [];\n    var arrayLength = pythonicConfig.length;\n    for (var i = 0; i < arrayLength; ++i) {\n      var item = pythonicConfig[i];\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        tsArray.push(item);\n      } else {\n        tsArray.push(convertPythonicToTs(item, key));\n      }\n    }\n    return tsArray;\n  } else {\n    var tsDict = {};\n    for (var _i = 0, _Object$keys = Object.keys(pythonicConfig); _i < _Object$keys.length; _i++) {\n      var pythonicKey = _Object$keys[_i];\n      var pythonicValue = pythonicConfig[pythonicKey];\n      if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n        // Special case the 'name' key with a string value. Name values, such as\n        // the names of LayersModel and Layer instances, should not undergo the\n        // camel-case conversion.\n        tsDict[pythonicKey] = pythonicValue;\n      } else {\n        var tsKey = generic_utils.toCamelCase(pythonicKey);\n        tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n      }\n    }\n    return tsDict;\n  }\n}\n/**\r\n * Convert a TypeScript config object to Python config object.\r\n * @param tsConfig The config object to convert.\r\n * @param key Optional key name of the object being converted.\r\n * @returns Result of the conversion.\r\n */\nexport function convertTsToPythonic(tsConfig, key) {\n  if (tsConfig === null || tsConfig === undefined) {\n    return null;\n  } else if (typeof tsConfig === 'string') {\n    return generic_utils.toSnakeCase(tsConfig);\n  } else if (typeof tsConfig === 'number' || typeof tsConfig === 'boolean') {\n    return tsConfig;\n  } else if (tsConfig instanceof Array) {\n    var pyArray = [];\n    var arrayLength = tsConfig.length;\n    for (var i = 0; i < arrayLength; ++i) {\n      var item = tsConfig[i];\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        pyArray.push(item);\n      } else {\n        pyArray.push(convertTsToPythonic(item, key));\n      }\n    }\n    return pyArray;\n  } else {\n    var pyDict = {};\n    for (var _i2 = 0, _Object$keys2 = Object.keys(tsConfig); _i2 < _Object$keys2.length; _i2++) {\n      var tsKey = _Object$keys2[_i2];\n      var tsValue = tsConfig[tsKey];\n      var pyKey = generic_utils.toSnakeCase(tsKey);\n      if ((tsKey === 'name' || tsKey === 'className') && typeof tsValue === 'string') {\n        // Special case the 'name' key with a string value. Name values, such as\n        // the names of LayersModel and Layer instances, should not undergo the\n        // snake-case conversion.\n        pyDict[pyKey] = tsValue;\n      } else {\n        pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n      }\n    }\n    return pyDict;\n  }\n}","map":{"version":3,"names":["generic_utils","isArrayItemInputOrOutputName","key","index","value","convertPythonicToTs","pythonicConfig","toCamelCase","Array","tsArray","arrayLength","length","i","item","push","tsDict","_i","_Object$keys","Object","keys","pythonicKey","pythonicValue","tsKey","convertTsToPythonic","tsConfig","undefined","toSnakeCase","pyArray","pyDict","_i2","_Object$keys2","tsValue","pyKey"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-layers\\src\\utils\\serialization_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n// Porting note: This file doesn't exist in PyKeras.\n// Its purpose here is to centralize the boundary layer between\n// tfjs-layers's internal Config TS-Centric format and PyKeras's\n// serialized Python Config format.\n\nimport {serialization} from '@tensorflow/tfjs-core';\n\nimport {PyJsonValue} from '../keras_format/types';\nimport * as generic_utils from '../utils/generic_utils';\n// tslint:enable\n\n/**\n * Test whether a value in an array is the name of a LayersModel or Layer.\n * @param key The key name that the value is found under. Note that the key\n *   may not be at the level immediately above the value, if the value is in a\n *   nested array.\n * @param index Index of the value in the Array that it is found in.\n * @param value The value object.\n * @returns A boolean indicating whether value is a name.\n */\nfunction isArrayItemInputOrOutputName<T>(\n    key: string, index: number, value: T): boolean {\n  return (key === 'inboundNodes' || key === 'outputLayers' ||\n          key === 'inputLayers') &&\n      index === 0 && typeof value === 'string';\n}\n\n/**\n * Convert a Pythonic config object to TypeScript config object.\n * @param pythonicConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertPythonicToTs(\n    pythonicConfig: PyJsonValue, key?: string): serialization.ConfigDictValue {\n  if (pythonicConfig === null) {\n    return null;\n  } else if (typeof pythonicConfig === 'string') {\n    return generic_utils.toCamelCase(pythonicConfig);\n  } else if (\n      (typeof pythonicConfig === 'number') ||\n      (typeof pythonicConfig === 'boolean')) {\n    return pythonicConfig;\n  } else if (pythonicConfig instanceof Array) {\n    const tsArray = [];\n    const arrayLength = pythonicConfig.length;\n    for (let i = 0; i < arrayLength; ++i) {\n      const item = pythonicConfig[i];\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        tsArray.push(item);\n      } else {\n        tsArray.push(convertPythonicToTs(item, key));\n      }\n    }\n    return tsArray;\n  } else {\n    const tsDict: serialization.ConfigDict = {};\n    for (const pythonicKey of Object.keys(pythonicConfig)) {\n      const pythonicValue = pythonicConfig[pythonicKey];\n      if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n        // Special case the 'name' key with a string value. Name values, such as\n        // the names of LayersModel and Layer instances, should not undergo the\n        // camel-case conversion.\n        tsDict[pythonicKey] = pythonicValue;\n      } else {\n        const tsKey = generic_utils.toCamelCase(pythonicKey);\n        tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n      }\n    }\n    return tsDict;\n  }\n}\n\n/**\n * Convert a TypeScript config object to Python config object.\n * @param tsConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertTsToPythonic(\n    tsConfig: serialization.ConfigDictValue, key?: string): PyJsonValue {\n  if (tsConfig === null || tsConfig === undefined) {\n    return null;\n  } else if (typeof tsConfig === 'string') {\n    return generic_utils.toSnakeCase(tsConfig);\n  } else if (\n      (typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {\n    return tsConfig;\n  } else if (tsConfig instanceof Array) {\n    const pyArray = [];\n    const arrayLength = tsConfig.length;\n    for (let i = 0; i < arrayLength; ++i) {\n      const item = tsConfig[i];\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        pyArray.push(item);\n      } else {\n        pyArray.push(convertTsToPythonic(item, key));\n      }\n    }\n    return pyArray;\n  } else {\n    const pyDict: serialization.ConfigDict = {};\n    for (const tsKey of Object.keys(tsConfig)) {\n      const tsValue = tsConfig[tsKey];\n      const pyKey = generic_utils.toSnakeCase(tsKey);\n      if ((tsKey === 'name' || tsKey === 'className') &&\n          typeof tsValue === 'string') {\n        // Special case the 'name' key with a string value. Name values, such as\n        // the names of LayersModel and Layer instances, should not undergo the\n        // snake-case conversion.\n        pyDict[pyKey] = tsValue;\n      } else {\n        pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n      }\n    }\n    return pyDict;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}