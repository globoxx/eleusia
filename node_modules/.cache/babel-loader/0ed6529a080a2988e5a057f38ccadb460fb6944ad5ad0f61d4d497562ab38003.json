{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad) {\n  var dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NHWC';\n  var dilations = arguments.length > 5 ? arguments[5] : undefined;\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  var inputChannels = inputShape[3];\n  var $filterShape = [].concat(_toConsumableArray(filterShape), [inputChannels]);\n  var $dataFormat = convertConv2DDataFormat(dataFormat);\n  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n  var _parseTupleParam = parseTupleParam(filterSize),\n    _parseTupleParam2 = _slicedToArray(_parseTupleParam, 2),\n    filterHeight = _parseTupleParam2[0],\n    filterWidth = _parseTupleParam2[1];\n  var filterShape;\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'NDHWC';\n  var _parse3TupleParam = parse3TupleParam(filterSize),\n    _parse3TupleParam2 = _slicedToArray(_parse3TupleParam, 3),\n    filterDepth = _parse3TupleParam2[0],\n    filterHeight = _parse3TupleParam2[1],\n    filterWidth = _parse3TupleParam2[2];\n  var filterShape;\n  var $dataFormat;\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode) {\n  var depthwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var dataFormat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'channelsLast';\n  var batchSize = -1,\n    inHeight = -1,\n    inWidth = -1,\n    inChannels = -1;\n  if (dataFormat === 'channelsLast') {\n    var _inShape = _slicedToArray(inShape, 4);\n    batchSize = _inShape[0];\n    inHeight = _inShape[1];\n    inWidth = _inShape[2];\n    inChannels = _inShape[3];\n  } else if (dataFormat === 'channelsFirst') {\n    var _inShape2 = _slicedToArray(inShape, 4);\n    batchSize = _inShape2[0];\n    inChannels = _inShape2[1];\n    inHeight = _inShape2[2];\n    inWidth = _inShape2[3];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n  var _filterShape = _slicedToArray(filterShape, 4),\n    filterHeight = _filterShape[0],\n    filterWidth = _filterShape[1],\n    filterChannels = _filterShape[3];\n  var _parseTupleParam3 = parseTupleParam(strides),\n    _parseTupleParam4 = _slicedToArray(_parseTupleParam3, 2),\n    strideHeight = _parseTupleParam4[0],\n    strideWidth = _parseTupleParam4[1];\n  var _parseTupleParam5 = parseTupleParam(dilations),\n    _parseTupleParam6 = _slicedToArray(_parseTupleParam5, 2),\n    dilationHeight = _parseTupleParam6[0],\n    dilationWidth = _parseTupleParam6[1];\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  var _getPadAndOutInfo = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat),\n    padInfo = _getPadAndOutInfo.padInfo,\n    outHeight = _getPadAndOutInfo.outHeight,\n    outWidth = _getPadAndOutInfo.outWidth;\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    effectiveFilterHeight: effectiveFilterHeight,\n    effectiveFilterWidth: effectiveFilterWidth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad) {\n  var depthwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n  var roundingMode = arguments.length > 7 ? arguments[7] : undefined;\n  var batchSize = -1,\n    inDepth = -1,\n    inHeight = -1,\n    inWidth = -1,\n    inChannels = -1;\n  if (dataFormat === 'channelsLast') {\n    var _inShape3 = _slicedToArray(inShape, 5);\n    batchSize = _inShape3[0];\n    inDepth = _inShape3[1];\n    inHeight = _inShape3[2];\n    inWidth = _inShape3[3];\n    inChannels = _inShape3[4];\n  } else if (dataFormat === 'channelsFirst') {\n    var _inShape4 = _slicedToArray(inShape, 5);\n    batchSize = _inShape4[0];\n    inChannels = _inShape4[1];\n    inDepth = _inShape4[2];\n    inHeight = _inShape4[3];\n    inWidth = _inShape4[4];\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n  var _filterShape2 = _slicedToArray(filterShape, 5),\n    filterDepth = _filterShape2[0],\n    filterHeight = _filterShape2[1],\n    filterWidth = _filterShape2[2],\n    filterChannels = _filterShape2[4];\n  var _parse3TupleParam3 = parse3TupleParam(strides),\n    _parse3TupleParam4 = _slicedToArray(_parse3TupleParam3, 3),\n    strideDepth = _parse3TupleParam4[0],\n    strideHeight = _parse3TupleParam4[1],\n    strideWidth = _parse3TupleParam4[2];\n  var _parse3TupleParam5 = parse3TupleParam(dilations),\n    _parse3TupleParam6 = _slicedToArray(_parse3TupleParam5, 3),\n    dilationDepth = _parse3TupleParam6[0],\n    dilationHeight = _parse3TupleParam6[1],\n    dilationWidth = _parse3TupleParam6[2];\n  var effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n  var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  var _get3DPadAndOutInfo = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode),\n    padInfo = _get3DPadAndOutInfo.padInfo,\n    outDepth = _get3DPadAndOutInfo.outDepth,\n    outHeight = _get3DPadAndOutInfo.outHeight,\n    outWidth = _get3DPadAndOutInfo.outWidth;\n  var outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  var outShape;\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n  return {\n    batchSize: batchSize,\n    dataFormat: dataFormat,\n    inDepth: inDepth,\n    inHeight: inHeight,\n    inWidth: inWidth,\n    inChannels: inChannels,\n    outDepth: outDepth,\n    outHeight: outHeight,\n    outWidth: outWidth,\n    outChannels: outChannels,\n    padInfo: padInfo,\n    strideDepth: strideDepth,\n    strideHeight: strideHeight,\n    strideWidth: strideWidth,\n    filterDepth: filterDepth,\n    filterHeight: filterHeight,\n    filterWidth: filterWidth,\n    effectiveFilterDepth: effectiveFilterDepth,\n    effectiveFilterHeight: effectiveFilterHeight,\n    effectiveFilterWidth: effectiveFilterWidth,\n    dilationDepth: dilationDepth,\n    dilationHeight: dilationHeight,\n    dilationWidth: dilationWidth,\n    inShape: inShape,\n    outShape: outShape,\n    filterShape: filterShape\n  };\n}\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  var inputRows = inShape[0];\n  var inputCols = inShape[1];\n  var outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  var outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputRows, outputCols];\n}\nfunction computeOutputShape4D(inShape, filterShape, outChannels, strides, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);\n  }\n  var outShape = [0, 0, 0, outChannels];\n  for (var index = 0; index < 3; index++) {\n    if (inShape[index] + 2 * zeroPad >= filterShape[index]) {\n      outShape[index] = round((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1, roundingMode);\n    }\n  }\n  return outShape;\n}\nexport function computeDefaultPad(inputShape, fieldSize, stride) {\n  var dilation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\nfunction parseTupleParam(param) {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param;\n}\nfunction parse3TupleParam(param) {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n  var padInfo;\n  var outHeight;\n  var outWidth;\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    var padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    var top = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    var _top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    var _bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    var _left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    var _right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    var _padType = _top === 0 && _bottom === 0 && _left === 0 && _right === 0 ? 'VALID' : 'EXPLICIT';\n    padInfo = {\n      top: _top,\n      bottom: _bottom,\n      left: _left,\n      right: _right,\n      type: _padType\n    };\n    outHeight = round((inHeight - filterHeight + _top + _bottom) / strideHeight + 1, roundingMode);\n    outWidth = round((inWidth - filterWidth + _left + _right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(\"Unknown padding parameter: \".concat(pad));\n  }\n  return {\n    padInfo: padInfo,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n  var padInfo;\n  var outDepth;\n  var outHeight;\n  var outWidth;\n  if (pad === 'valid') {\n    pad = 0;\n  }\n  if (typeof pad === 'number') {\n    var padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    var outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], [filterDepth, filterHeight, filterWidth], 1, [strideDepth, strideHeight, strideWidth], pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    var padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    var front = Math.floor(padAlongDepth / 2);\n    var back = padAlongDepth - front;\n    var top = Math.floor(padAlongHeight / 2);\n    var bottom = padAlongHeight - top;\n    var left = Math.floor(padAlongWidth / 2);\n    var right = padAlongWidth - left;\n    padInfo = {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      front: front,\n      back: back,\n      type: 'SAME'\n    };\n  } else {\n    throw Error(\"Unknown padding parameter: \".concat(pad));\n  }\n  return {\n    padInfo: padInfo,\n    outDepth: outDepth,\n    outHeight: outHeight,\n    outWidth: outWidth\n  };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value, roundingMode) {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n    case 'floor':\n      return Math.floor(value);\n    default:\n      throw new Error(\"Unknown roundingMode \".concat(roundingMode));\n  }\n}\nexport function tupleValuesAreOne(param) {\n  var _parseTupleParam7 = parseTupleParam(param),\n    _parseTupleParam8 = _slicedToArray(_parseTupleParam7, 3),\n    dimA = _parseTupleParam8[0],\n    dimB = _parseTupleParam8[1],\n    dimC = _parseTupleParam8[2];\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\nexport function stridesOrDilationsArePositive(values) {\n  return parseTupleParam(values).every(function (value) {\n    return value > 0;\n  });\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat) {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(\"Unknown dataFormat \".concat(dataFormat));\n  }\n}\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\nexport function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(\"Error in \".concat(opDesc, \": pad must be an integer when using \") + \"dimRoundingMode \".concat(dimRoundingMode, \" but got pad \").concat(pad, \".\"));\n    } else if (typeof pad === 'number') {\n      util.assert(util.isInt(pad), function () {\n        return \"Error in \".concat(opDesc, \": pad must be an integer when using \") + \"dimRoundingMode \".concat(dimRoundingMode, \" but got pad \").concat(pad, \".\");\n      });\n    } else if (typeof pad === 'object') {\n      pad.forEach(function (p) {\n        p.forEach(function (v) {\n          util.assert(util.isInt(v), function () {\n            return \"Error in \".concat(opDesc, \": pad must be an integer when using \") + \"dimRoundingMode \".concat(dimRoundingMode, \" but got pad \").concat(v, \".\");\n          });\n        });\n      });\n    } else {\n      throw Error(\"Error in \".concat(opDesc, \": Unknown padding parameter: \").concat(pad));\n    }\n  }\n}","map":{"version":3,"names":["util","computeDilation2DInfo","inputShape","filterShape","strides","pad","dataFormat","arguments","length","undefined","dilations","inputChannels","$filterShape","concat","_toConsumableArray","$dataFormat","convertConv2DDataFormat","computeConv2DInfo","computePool2DInfo","inShape","filterSize","roundingMode","_parseTupleParam","parseTupleParam","_parseTupleParam2","_slicedToArray","filterHeight","filterWidth","Error","computePool3DInfo","_parse3TupleParam","parse3TupleParam","_parse3TupleParam2","filterDepth","computeConv3DInfo","depthwise","batchSize","inHeight","inWidth","inChannels","_inShape","_inShape2","_filterShape","filterChannels","_parseTupleParam3","_parseTupleParam4","strideHeight","strideWidth","_parseTupleParam5","_parseTupleParam6","dilationHeight","dilationWidth","effectiveFilterHeight","getEffectiveFilterSize","effectiveFilterWidth","_getPadAndOutInfo","getPadAndOutInfo","padInfo","outHeight","outWidth","outChannels","outShape","inDepth","_inShape3","_inShape4","_filterShape2","_parse3TupleParam3","_parse3TupleParam4","strideDepth","_parse3TupleParam5","_parse3TupleParam6","dilationDepth","effectiveFilterDepth","_get3DPadAndOutInfo","get3DPadAndOutInfo","outDepth","computeOutputShape2D","fieldSize","stride","zeroPad","computeDefaultPad","inputRows","inputCols","outputRows","round","outputCols","computeOutputShape4D","index","dilation","effectiveFieldSize","Math","floor","param","padType","top","bottom","left","right","type","ceil","padAlongHeight","max","padAlongWidth","front","back","padAlongDepth","value","trunc","tupleValuesAreOne","_parseTupleParam7","_parseTupleParam8","dimA","dimB","dimC","eitherStridesOrDilationsAreOne","stridesOrDilationsArePositive","values","every","checkPadOnDimRoundingMode","opDesc","dimRoundingMode","assert","isInt","forEach","p","v"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-core\\src\\ops\\conv_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as util from '../util';\n\ntype PadType = 'SAME'|'VALID'|'NUMBER'|'EXPLICIT';\n\n// For NHWC should be in the following form:\n//  [[0, 0], [pad_top,pad_bottom], [pad_left, pad_right], [0, 0]]\n// For NCHW should be in the following form:\n//  [[0, 0], [0, 0], [pad_top,pad_bottom], [pad_left, pad_right]]\n// Reference: https://www.tensorflow.org/api_docs/python/tf/nn/conv2d\nexport type ExplicitPadding =\n    [[number, number], [number, number], [number, number], [number, number]];\n\nexport type PadInfo = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  type: PadType\n};\n\nexport type PadInfo3D = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  front: number,\n  back: number,\n  type: PadType\n};\n\n/**\n * Information about the forward pass of a convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv2DInfo = {\n  batchSize: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideHeight: number,\n  strideWidth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo,\n  inShape: [number, number, number, number],\n  outShape: [number, number, number, number],\n  filterShape: [number, number, number, number]\n};\n\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(\n    inputShape: [number, number, number, number],\n    filterShape: [number, number, number], strides: number|[number, number],\n    pad: 'same'|'valid'|number, dataFormat: 'NHWC' = 'NHWC',\n    dilations: number|[number, number]) {\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape =\n      [...filterShape, inputChannels] as [number, number, number, number];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n\n  return computeConv2DInfo(\n      inputShape, $filterShape, strides, dilations, pad,\n      null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\n\nexport function computePool2DInfo(\n    inShape: [number, number, number, number],\n    filterSize: [number, number]|number, strides: number|[number, number],\n    dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n\n  let filterShape: [number, number, number, number];\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv2DInfo(\n      inShape, filterShape, strides, dilations, pad, roundingMode, false,\n      dataFormat);\n}\n\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(\n    inShape: [number, number, number, number, number],\n    filterSize: number|[number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC'): Conv3DInfo {\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n\n  let filterShape: [number, number, number, number, number];\n  let $dataFormat: 'channelsFirst'|'channelsLast';\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv3DInfo(\n      inShape, filterShape, strides, dilations, pad, false, $dataFormat,\n      roundingMode);\n}\n\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(\n    inShape: [number, number, number, number],\n    filterShape: [number, number, number, number],\n    strides: number|[number, number], dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil', depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterHeight, filterWidth, , filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outHeight, outWidth} = getPadAndOutInfo(\n      pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight,\n      effectiveFilterWidth, roundingMode, dataFormat);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\n/**\n * Information about the forward pass of a 3D convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv3DInfo = {\n  batchSize: number,\n  inDepth: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideDepth: number,\n  strideHeight: number,\n  strideWidth: number,\n  dilationDepth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterDepth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterDepth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo3D,\n  inShape: [number, number, number, number, number],\n  outShape: [number, number, number, number, number],\n  filterShape: [number, number, number, number, number]\n};\n\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(\n    inShape: [number, number, number, number, number],\n    filterShape: [number, number, number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast',\n    roundingMode?: 'floor'|'round'|'ceil'): Conv3DInfo {\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] =\n      [-1, -1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterDepth, filterHeight, filterWidth, , filterChannels] =\n      filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] =\n      parse3TupleParam(dilations);\n\n  const effectiveFilterDepth =\n      getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outDepth, outHeight, outWidth} = get3DPadAndOutInfo(\n      pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth,\n      effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth,\n      roundingMode);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\nfunction computeOutputShape2D(\n    inShape: [number, number], fieldSize: number, stride: number,\n    zeroPad?: number, roundingMode?: 'floor'|'round'|'ceil'): [number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n\n  const outputRows =\n      round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols =\n      round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(\n    inShape: [number, number, number, number],\n    filterShape: [number, number, number], outChannels: number,\n    strides: [number, number, number], zeroPad?: number,\n    roundingMode?: 'floor'|'round'|'ceil'): [number, number, number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);\n  }\n  const outShape: [number, number, number, number] = [0, 0, 0, outChannels];\n  for (let index = 0; index < 3; index++) {\n    if (inShape[index] + 2 * zeroPad >= filterShape[index]) {\n      outShape[index] = round(\n          (inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] +\n              1,\n          roundingMode);\n    }\n  }\n  return outShape;\n}\n\nexport function computeDefaultPad(\n    inputShape: [number, number]|[number, number, number, number],\n    fieldSize: number, stride: number, dilation = 1): number {\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor(\n      (inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param: number|number[]): [number, number, number] {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param as [number, number, number];\n}\n\nfunction parse3TupleParam(param: number|[number, number, number]):\n    [number, number, number] {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize: number, dilation: number) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(\n    pad: 'same'|'valid'|number|ExplicitPadding, inHeight: number,\n    inWidth: number, strideHeight: number, strideWidth: number,\n    filterHeight: number, filterWidth: number,\n    roundingMode: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|\n    'channelsLast'): {padInfo: PadInfo, outHeight: number, outWidth: number} {\n  let padInfo: PadInfo;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {top: pad, bottom: pad, left: pad, right: pad, type: padType};\n    const outShape = computeOutputShape2D(\n        [inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight =\n        Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth =\n        Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {top, bottom, left, right, type: 'SAME'};\n  } else if (pad === 'valid') {\n    padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: 'VALID'};\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n        'VALID' :\n        'EXPLICIT';\n    padInfo = {top, bottom, left, right, type: padType};\n    outHeight = round(\n        (inHeight - filterHeight + top + bottom) / strideHeight + 1,\n        roundingMode);\n    outWidth = round(\n        (inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outHeight, outWidth};\n}\n\nfunction get3DPadAndOutInfo(\n    pad: 'same'|'valid'|number, inDepth: number, inHeight: number,\n    inWidth: number, strideDepth: number, strideHeight: number,\n    strideWidth: number, filterDepth: number, filterHeight: number,\n    filterWidth: number, roundingMode?: 'floor'|'round'|'ceil'): {\n  padInfo: PadInfo3D,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number\n} {\n  let padInfo: PadInfo3D;\n  let outDepth: number;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (pad === 'valid') {\n    pad = 0;\n  }\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D(\n        [inDepth, inHeight, inWidth, 1],\n        [filterDepth, filterHeight, filterWidth], 1,\n        [strideDepth, strideHeight, strideWidth], pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight =\n        (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n\n    padInfo = {top, bottom, left, right, front, back, type: 'SAME'};\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outDepth, outHeight, outWidth};\n}\n\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value: number, roundingMode?: 'floor'|'round'|'ceil') {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n    case 'floor':\n      return Math.floor(value);\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\n\nexport function tupleValuesAreOne(param: number|number[]): boolean {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\n\nexport function eitherStridesOrDilationsAreOne(\n    strides: number|number[], dilations: number|number[]): boolean {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n\nexport function stridesOrDilationsArePositive(values: number|\n                                              number[]): boolean {\n  return parseTupleParam(values).every(value => value > 0);\n}\n\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat: 'NHWC'|'NCHW'):\n    'channelsLast'|'channelsFirst' {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\nexport function checkPadOnDimRoundingMode(\n    opDesc: string, pad: 'valid'|'same'|number|ExplicitPadding,\n    dimRoundingMode?: 'floor'|'round'|'ceil') {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(\n          `Error in ${opDesc}: pad must be an integer when using ` +\n          `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'number') {\n      util.assert(\n          util.isInt(pad),\n          () => `Error in ${opDesc}: pad must be an integer when using ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'object') {\n      (pad as ExplicitPadding).forEach(p => {\n        p.forEach(v => {\n          util.assert(\n              util.isInt(v),\n              () => `Error in ${opDesc}: pad must be an integer when using ` +\n                  `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n        });\n      });\n    } else {\n      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}