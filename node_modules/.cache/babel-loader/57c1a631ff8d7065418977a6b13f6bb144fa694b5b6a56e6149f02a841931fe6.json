{"ast":null,"code":"import*as tf from'@tensorflow/tfjs';const MOBILE_NET_INPUT_WIDTH=224;const MOBILE_NET_INPUT_HEIGHT=224;const CLASS_NAMES=[\"Refused\",\"Accepted\"];// Put your class names here\nconst MyModel={featureExtractor:null,model:null,loadFeatureExtractor:async()=>{const URL='https://www.kaggle.com/models/google/mobilenet-v3/TfJs/small-100-224-feature-vector/1';MyModel.featureExtractor=await tf.loadGraphModel(URL,{fromTFHub:true});// Warm up the model by passing zeros through it once.\ntf.tidy(function(){MyModel.featureExtractor.predict(tf.zeros([1,MOBILE_NET_INPUT_HEIGHT,MOBILE_NET_INPUT_WIDTH,3]));});console.log('Feature extractor loaded');},loadModel:()=>{MyModel.model=tf.sequential();MyModel.model.add(tf.layers.dense({inputShape:[1024],units:128,activation:'relu'}));MyModel.model.add(tf.layers.dense({units:CLASS_NAMES.length,activation:'softmax'}));MyModel.model.compile({optimizer:'adam',loss:CLASS_NAMES.length===2?'binaryCrossentropy':'categoricalCrossentropy',metrics:['accuracy']});console.log('Model loaded');},resetModel:()=>{MyModel.loadModel();},preprocessImage:image=>{return tf.tidy(()=>{let tensor=tf.browser.fromPixels(image).resizeBilinear([MOBILE_NET_INPUT_HEIGHT,MOBILE_NET_INPUT_WIDTH],true).div(255.0).expandDims();if(MyModel.featureExtractor){return MyModel.featureExtractor.predict(tensor).squeeze();}throw new Error(\"Feature extractor not loaded\");});},trainModel:async(images,labels)=>{return new Promise(async(resolve,reject)=>{let xs,ys;try{xs=tf.stack(images.map(image=>MyModel.preprocessImage(image)));ys=tf.oneHot(tf.tensor1d(labels,'int32'),CLASS_NAMES.length);if(MyModel.model){await MyModel.model.fit(xs,ys,{epochs:10,batchSize:5,shuffle:true});console.log('Model trained');resolve();}else{reject(new Error(\"Model not loaded\"));}}catch(error){reject(error);}finally{if(xs)xs.dispose();if(ys)ys.dispose();}});},predictImage:image=>{return new Promise((resolve,reject)=>{let imageFeatures;try{imageFeatures=MyModel.preprocessImage(image);if(MyModel.model){const predictionLabel=MyModel.model.predict(imageFeatures.expandDims()).squeeze().dataSync();resolve(predictionLabel);}else{reject(new Error(\"Model not loaded\"));}}catch(error){reject(error);}finally{if(imageFeatures)imageFeatures.dispose();}});}};export default MyModel;","map":{"version":3,"names":["tf","MOBILE_NET_INPUT_WIDTH","MOBILE_NET_INPUT_HEIGHT","CLASS_NAMES","MyModel","featureExtractor","model","loadFeatureExtractor","URL","loadGraphModel","fromTFHub","tidy","predict","zeros","console","log","loadModel","sequential","add","layers","dense","inputShape","units","activation","length","compile","optimizer","loss","metrics","resetModel","preprocessImage","image","tensor","browser","fromPixels","resizeBilinear","div","expandDims","squeeze","Error","trainModel","images","labels","Promise","resolve","reject","xs","ys","stack","map","oneHot","tensor1d","fit","epochs","batchSize","shuffle","error","dispose","predictImage","imageFeatures","predictionLabel","dataSync"],"sources":["C:/Users/vince/OneDrive/Documents/GitHub/eleusia/src/components/AIModel.tsx"],"sourcesContent":["import * as tf from '@tensorflow/tfjs';\r\n\r\nconst MOBILE_NET_INPUT_WIDTH = 224;\r\nconst MOBILE_NET_INPUT_HEIGHT = 224;\r\nconst CLASS_NAMES = [\"Refused\", \"Accepted\"]; // Put your class names here\r\n\r\nexport type ImageElement = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageData;\r\n\r\nconst MyModel = {\r\n  featureExtractor: null as tf.GraphModel | null,\r\n  model: null as tf.Sequential | null,\r\n\r\n  loadFeatureExtractor: async () => {\r\n    const URL = 'https://www.kaggle.com/models/google/mobilenet-v3/TfJs/small-100-224-feature-vector/1';\r\n    MyModel.featureExtractor = await tf.loadGraphModel(URL, {fromTFHub: true});\r\n\r\n    // Warm up the model by passing zeros through it once.\r\n    tf.tidy(function () {\r\n      MyModel.featureExtractor.predict(tf.zeros([1, MOBILE_NET_INPUT_HEIGHT, MOBILE_NET_INPUT_WIDTH, 3]));\r\n    });\r\n\r\n    console.log('Feature extractor loaded');\r\n  },\r\n\r\n  loadModel: () => {\r\n    MyModel.model = tf.sequential();\r\n    MyModel.model.add(tf.layers.dense({inputShape: [1024], units: 128, activation: 'relu'}));\r\n    MyModel.model.add(tf.layers.dense({units: CLASS_NAMES.length, activation: 'softmax'}));\r\n    MyModel.model.compile({\r\n      optimizer: 'adam',\r\n      loss: CLASS_NAMES.length === 2 ? 'binaryCrossentropy' : 'categoricalCrossentropy',\r\n      metrics: ['accuracy']\r\n    });\r\n    console.log('Model loaded');\r\n  },\r\n\r\n  resetModel: () => {\r\n    MyModel.loadModel();\r\n  },\r\n\r\n  preprocessImage: (image: ImageElement) => {\r\n    return tf.tidy(() => {\r\n      let tensor = tf.browser.fromPixels(image)\r\n        .resizeBilinear([MOBILE_NET_INPUT_HEIGHT, MOBILE_NET_INPUT_WIDTH], true)\r\n        .div(255.0)\r\n        .expandDims();\r\n      if (MyModel.featureExtractor) {\r\n        return (MyModel.featureExtractor.predict(tensor) as tf.Tensor).squeeze();\r\n      }\r\n      throw new Error(\"Feature extractor not loaded\");\r\n    });\r\n  },\r\n\r\n  trainModel: async (images: ImageElement[], labels: number[]) => {\r\n    return new Promise<void>(async (resolve, reject) => {\r\n      let xs, ys\r\n      try {\r\n        xs = tf.stack(images.map(image => MyModel.preprocessImage(image)));\r\n        ys = tf.oneHot(tf.tensor1d(labels, 'int32'), CLASS_NAMES.length);\r\n        if (MyModel.model) {\r\n          await MyModel.model.fit(xs, ys, {\r\n            epochs: 10,\r\n            batchSize: 5,\r\n            shuffle: true\r\n          });\r\n          console.log('Model trained');\r\n          resolve();\r\n        } else {\r\n          reject(new Error(\"Model not loaded\"));\r\n        }\r\n      } catch(error) {\r\n        reject(error);\r\n      } finally {\r\n        if (xs) xs.dispose();\r\n        if (ys) ys.dispose();\r\n      }\r\n    });\r\n  },\r\n\r\n  predictImage: (image: ImageElement) => {\r\n    return new Promise<Uint8Array | Float32Array | Int32Array>((resolve, reject) => {\r\n      let imageFeatures\r\n      try {\r\n        imageFeatures = MyModel.preprocessImage(image);\r\n        if (MyModel.model) {\r\n          const predictionLabel = (MyModel.model.predict(imageFeatures.expandDims()) as tf.Tensor).squeeze().dataSync();\r\n          resolve(predictionLabel);\r\n        } else {\r\n          reject(new Error(\"Model not loaded\"));\r\n        }\r\n      } catch(error) {\r\n        reject(error);\r\n      } finally {\r\n        if (imageFeatures) imageFeatures.dispose();\r\n      }\r\n    });\r\n  },\r\n};\r\n\r\nexport default MyModel;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}