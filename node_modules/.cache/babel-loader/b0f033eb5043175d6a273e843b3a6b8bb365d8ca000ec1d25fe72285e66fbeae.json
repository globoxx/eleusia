{"ast":null,"code":"import _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\n/**\r\n * TensorFlow.js Layers: Pooling Layers.\r\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\r\n * 2D pooling.\r\n * @param x\r\n * @param poolSize\r\n * @param strides strides. Defaults to [1, 1].\r\n * @param padding padding. Defaults to 'valid'.\r\n * @param dataFormat data format. Defaults to 'channelsLast'.\r\n * @param poolMode Mode of pooling. Defaults to 'max'.\r\n * @returns Result of the 2D pooling.\r\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(function () {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n    var y;\n    var paddingString = padding === 'same' ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n      // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\r\n * 3D pooling.\r\n * @param x\r\n * @param poolSize. Default to [1, 1, 1].\r\n * @param strides strides. Defaults to [1, 1, 1].\r\n * @param padding padding. Defaults to 'valid'.\r\n * @param dataFormat data format. Defaults to 'channelsLast'.\r\n * @param poolMode Mode of pooling. Defaults to 'max'.\r\n * @returns Result of the 3D pooling.\r\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(function () {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x, dataFormat);\n    var y;\n    var paddingString = padding === 'same' ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\r\n * Abstract class for different pooling 1D layers.\r\n */\nexport var Pooling1D = /*#__PURE__*/function (_Layer) {\n  _inherits(Pooling1D, _Layer);\n  var _super = _createSuper(Pooling1D);\n  /**\r\n   *\r\n   * @param args Parameters for the Pooling layer.\r\n   *\r\n   * config.poolSize defaults to 2.\r\n   */\n  function Pooling1D(args) {\n    var _this;\n    _classCallCheck(this, Pooling1D);\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    _this = _super.call(this, args);\n    if (typeof args.poolSize === 'number') {\n      _this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      _this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(\"poolSize for 1D convolutional layer must be a number or an \" + \"Array of a single number, but received \" + \"\".concat(JSON.stringify(args.poolSize)));\n    }\n    assertPositiveInteger(_this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      _this.strides = _this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        _this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        _this.strides = args.strides;\n      } else {\n        throw new ValueError(\"strides for 1D convolutional layer must be a number or an \" + \"Array of a single number, but received \" + \"\".concat(JSON.stringify(args.strides)));\n      }\n    }\n    assertPositiveInteger(_this.strides, 'strides');\n    _this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(_this.padding);\n    _this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n    return _this;\n  }\n  _createClass(Pooling1D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n      return [inputShape[0], length, inputShape[2]];\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this2 = this;\n      return tidy(function () {\n        _this2.invokeCallHook(inputs, kwargs);\n        // Add dummy last dimension.\n        inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n        var output = _this2.poolingFunction(getExactlyOneTensor(inputs), [_this2.poolSize[0], 1], [_this2.strides[0], 1], _this2.padding, 'channelsLast');\n        // Remove dummy last dimension.\n        return tfc.squeeze(output, [2]);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        poolSize: this.poolSize,\n        padding: this.padding,\n        strides: this.strides\n      };\n      var baseConfig = _get(_getPrototypeOf(Pooling1D.prototype), \"getConfig\", this).call(this);\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n  return Pooling1D;\n}(Layer);\nexport var MaxPooling1D = /*#__PURE__*/function (_Pooling1D) {\n  _inherits(MaxPooling1D, _Pooling1D);\n  var _super2 = _createSuper(MaxPooling1D);\n  function MaxPooling1D(args) {\n    _classCallCheck(this, MaxPooling1D);\n    return _super2.call(this, args);\n  }\n  _createClass(MaxPooling1D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n  }]);\n  return MaxPooling1D;\n}(Pooling1D);\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport var AveragePooling1D = /*#__PURE__*/function (_Pooling1D2) {\n  _inherits(AveragePooling1D, _Pooling1D2);\n  var _super3 = _createSuper(AveragePooling1D);\n  function AveragePooling1D(args) {\n    _classCallCheck(this, AveragePooling1D);\n    return _super3.call(this, args);\n  }\n  _createClass(AveragePooling1D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n  }]);\n  return AveragePooling1D;\n}(Pooling1D);\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\r\n * Abstract class for different pooling 2D layers.\r\n */\nexport var Pooling2D = /*#__PURE__*/function (_Layer2) {\n  _inherits(Pooling2D, _Layer2);\n  var _super4 = _createSuper(Pooling2D);\n  function Pooling2D(args) {\n    var _this3;\n    _classCallCheck(this, Pooling2D);\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    _this3 = _super4.call(this, args);\n    _this3.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      _this3.strides = _this3.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(\"If the strides property of a 2D pooling layer is an Array, \" + \"it is expected to have a length of 2, but received length \" + \"\".concat(args.strides.length, \".\"));\n      }\n      _this3.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      _this3.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(_this3.poolSize, 'poolSize');\n    assertPositiveInteger(_this3.strides, 'strides');\n    _this3.padding = args.padding == null ? 'valid' : args.padding;\n    _this3.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(_this3.dataFormat);\n    checkPaddingMode(_this3.padding);\n    _this3.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n    return _this3;\n  }\n  _createClass(Pooling2D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n      var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n      rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n      cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n      if (this.dataFormat === 'channelsFirst') {\n        return [inputShape[0], inputShape[1], rows, cols];\n      } else {\n        return [inputShape[0], rows, cols, inputShape[3]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this4 = this;\n      return tidy(function () {\n        _this4.invokeCallHook(inputs, kwargs);\n        return _this4.poolingFunction(getExactlyOneTensor(inputs), _this4.poolSize, _this4.strides, _this4.padding, _this4.dataFormat);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        poolSize: this.poolSize,\n        padding: this.padding,\n        strides: this.strides,\n        dataFormat: this.dataFormat\n      };\n      var baseConfig = _get(_getPrototypeOf(Pooling2D.prototype), \"getConfig\", this).call(this);\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n  return Pooling2D;\n}(Layer);\nexport var MaxPooling2D = /*#__PURE__*/function (_Pooling2D) {\n  _inherits(MaxPooling2D, _Pooling2D);\n  var _super5 = _createSuper(MaxPooling2D);\n  function MaxPooling2D(args) {\n    _classCallCheck(this, MaxPooling2D);\n    return _super5.call(this, args);\n  }\n  _createClass(MaxPooling2D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n  }]);\n  return MaxPooling2D;\n}(Pooling2D);\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport var AveragePooling2D = /*#__PURE__*/function (_Pooling2D2) {\n  _inherits(AveragePooling2D, _Pooling2D2);\n  var _super6 = _createSuper(AveragePooling2D);\n  function AveragePooling2D(args) {\n    _classCallCheck(this, AveragePooling2D);\n    return _super6.call(this, args);\n  }\n  _createClass(AveragePooling2D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n  }]);\n  return AveragePooling2D;\n}(Pooling2D);\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\r\n * Abstract class for different pooling 3D layers.\r\n */\nexport var Pooling3D = /*#__PURE__*/function (_Layer3) {\n  _inherits(Pooling3D, _Layer3);\n  var _super7 = _createSuper(Pooling3D);\n  function Pooling3D(args) {\n    var _this5;\n    _classCallCheck(this, Pooling3D);\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    _this5 = _super7.call(this, args);\n    _this5.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      _this5.strides = _this5.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(\"If the strides property of a 3D pooling layer is an Array, \" + \"it is expected to have a length of 3, but received length \" + \"\".concat(args.strides.length, \".\"));\n      }\n      _this5.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      _this5.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(_this5.poolSize, 'poolSize');\n    assertPositiveInteger(_this5.strides, 'strides');\n    _this5.padding = args.padding == null ? 'valid' : args.padding;\n    _this5.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(_this5.dataFormat);\n    checkPaddingMode(_this5.padding);\n    _this5.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n    return _this5;\n  }\n  _createClass(Pooling3D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = getExactlyOneShape(inputShape);\n      var depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n      var rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n      var cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n      depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n      rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n      cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n      if (this.dataFormat === 'channelsFirst') {\n        return [inputShape[0], inputShape[1], depths, rows, cols];\n      } else {\n        return [inputShape[0], depths, rows, cols, inputShape[4]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this6 = this;\n      return tidy(function () {\n        _this6.invokeCallHook(inputs, kwargs);\n        return _this6.poolingFunction(getExactlyOneTensor(inputs), _this6.poolSize, _this6.strides, _this6.padding, _this6.dataFormat);\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        poolSize: this.poolSize,\n        padding: this.padding,\n        strides: this.strides,\n        dataFormat: this.dataFormat\n      };\n      var baseConfig = _get(_getPrototypeOf(Pooling3D.prototype), \"getConfig\", this).call(this);\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n  return Pooling3D;\n}(Layer);\nexport var MaxPooling3D = /*#__PURE__*/function (_Pooling3D) {\n  _inherits(MaxPooling3D, _Pooling3D);\n  var _super8 = _createSuper(MaxPooling3D);\n  function MaxPooling3D(args) {\n    _classCallCheck(this, MaxPooling3D);\n    return _super8.call(this, args);\n  }\n  _createClass(MaxPooling3D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n  }]);\n  return MaxPooling3D;\n}(Pooling3D);\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport var AveragePooling3D = /*#__PURE__*/function (_Pooling3D2) {\n  _inherits(AveragePooling3D, _Pooling3D2);\n  var _super9 = _createSuper(AveragePooling3D);\n  function AveragePooling3D(args) {\n    _classCallCheck(this, AveragePooling3D);\n    return _super9.call(this, args);\n  }\n  _createClass(AveragePooling3D, [{\n    key: \"poolingFunction\",\n    value: function poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n      checkDataFormat(dataFormat);\n      checkPaddingMode(padding);\n      return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n  }]);\n  return AveragePooling3D;\n}(Pooling3D);\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\r\n * Abstract class for different global pooling 1D layers.\r\n */\nexport var GlobalPooling1D = /*#__PURE__*/function (_Layer4) {\n  _inherits(GlobalPooling1D, _Layer4);\n  var _super10 = _createSuper(GlobalPooling1D);\n  function GlobalPooling1D(args) {\n    var _this7;\n    _classCallCheck(this, GlobalPooling1D);\n    _this7 = _super10.call(this, args);\n    _this7.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n    return _this7;\n  }\n  _createClass(GlobalPooling1D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      return [inputShape[0], inputShape[2]];\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      throw new NotImplementedError();\n    }\n  }]);\n  return GlobalPooling1D;\n}(Layer);\nexport var GlobalAveragePooling1D = /*#__PURE__*/function (_GlobalPooling1D) {\n  _inherits(GlobalAveragePooling1D, _GlobalPooling1D);\n  var _super11 = _createSuper(GlobalAveragePooling1D);\n  function GlobalAveragePooling1D(args) {\n    _classCallCheck(this, GlobalAveragePooling1D);\n    return _super11.call(this, args || {});\n  }\n  _createClass(GlobalAveragePooling1D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        return tfc.mean(input, 1);\n      });\n    }\n  }]);\n  return GlobalAveragePooling1D;\n}(GlobalPooling1D);\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport var GlobalMaxPooling1D = /*#__PURE__*/function (_GlobalPooling1D2) {\n  _inherits(GlobalMaxPooling1D, _GlobalPooling1D2);\n  var _super12 = _createSuper(GlobalMaxPooling1D);\n  function GlobalMaxPooling1D(args) {\n    _classCallCheck(this, GlobalMaxPooling1D);\n    return _super12.call(this, args || {});\n  }\n  _createClass(GlobalMaxPooling1D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        return tfc.max(input, 1);\n      });\n    }\n  }]);\n  return GlobalMaxPooling1D;\n}(GlobalPooling1D);\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\r\n * Abstract class for different global pooling 2D layers.\r\n */\nexport var GlobalPooling2D = /*#__PURE__*/function (_Layer5) {\n  _inherits(GlobalPooling2D, _Layer5);\n  var _super13 = _createSuper(GlobalPooling2D);\n  function GlobalPooling2D(args) {\n    var _this8;\n    _classCallCheck(this, GlobalPooling2D);\n    _this8 = _super13.call(this, args);\n    _this8.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(_this8.dataFormat);\n    _this8.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n    return _this8;\n  }\n  _createClass(GlobalPooling2D, [{\n    key: \"computeOutputShape\",\n    value: function computeOutputShape(inputShape) {\n      inputShape = inputShape;\n      if (this.dataFormat === 'channelsLast') {\n        return [inputShape[0], inputShape[3]];\n      } else {\n        return [inputShape[0], inputShape[1]];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      throw new NotImplementedError();\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      var config = {\n        dataFormat: this.dataFormat\n      };\n      var baseConfig = _get(_getPrototypeOf(GlobalPooling2D.prototype), \"getConfig\", this).call(this);\n      Object.assign(config, baseConfig);\n      return config;\n    }\n  }]);\n  return GlobalPooling2D;\n}(Layer);\nexport var GlobalAveragePooling2D = /*#__PURE__*/function (_GlobalPooling2D) {\n  _inherits(GlobalAveragePooling2D, _GlobalPooling2D);\n  var _super14 = _createSuper(GlobalAveragePooling2D);\n  function GlobalAveragePooling2D() {\n    _classCallCheck(this, GlobalAveragePooling2D);\n    return _super14.apply(this, arguments);\n  }\n  _createClass(GlobalAveragePooling2D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this9 = this;\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        if (_this9.dataFormat === 'channelsLast') {\n          return tfc.mean(input, [1, 2]);\n        } else {\n          return tfc.mean(input, [2, 3]);\n        }\n      });\n    }\n  }]);\n  return GlobalAveragePooling2D;\n}(GlobalPooling2D);\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport var GlobalMaxPooling2D = /*#__PURE__*/function (_GlobalPooling2D2) {\n  _inherits(GlobalMaxPooling2D, _GlobalPooling2D2);\n  var _super15 = _createSuper(GlobalMaxPooling2D);\n  function GlobalMaxPooling2D() {\n    _classCallCheck(this, GlobalMaxPooling2D);\n    return _super15.apply(this, arguments);\n  }\n  _createClass(GlobalMaxPooling2D, [{\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      var _this10 = this;\n      return tidy(function () {\n        var input = getExactlyOneTensor(inputs);\n        if (_this10.dataFormat === 'channelsLast') {\n          return tfc.max(input, [1, 2]);\n        } else {\n          return tfc.max(input, [2, 3]);\n        }\n      });\n    }\n  }]);\n  return GlobalMaxPooling2D;\n}(GlobalPooling2D);\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"names":["tfc","serialization","tidy","imageDataFormat","K","checkDataFormat","checkPaddingMode","checkPoolMode","InputSpec","Layer","NotImplementedError","ValueError","convOutputLength","assertPositiveInteger","getExactlyOneShape","getExactlyOneTensor","preprocessConv2DInput","preprocessConv3DInput","pool2d","x","poolSize","strides","padding","dataFormat","poolMode","y","paddingString","maxPool","avgPool","transpose","pool3d","maxPool3d","avgPool3d","Pooling1D","_Layer","_inherits","_super","_createSuper","args","_this","_classCallCheck","call","Array","isArray","length","concat","JSON","stringify","inputSpec","ndim","_createClass","key","value","computeOutputShape","inputShape","inputs","kwargs","_this2","invokeCallHook","expandDims","output","poolingFunction","squeeze","getConfig","config","baseConfig","_get","_getPrototypeOf","prototype","Object","assign","MaxPooling1D","_Pooling1D","_super2","className","registerClass","AveragePooling1D","_Pooling1D2","_super3","Pooling2D","_Layer2","_super4","_this3","rows","cols","_this4","MaxPooling2D","_Pooling2D","_super5","AveragePooling2D","_Pooling2D2","_super6","Pooling3D","_Layer3","_super7","_this5","depths","_this6","MaxPooling3D","_Pooling3D","_super8","AveragePooling3D","_Pooling3D2","_super9","GlobalPooling1D","_Layer4","_super10","_this7","GlobalAveragePooling1D","_GlobalPooling1D","_super11","input","mean","GlobalMaxPooling1D","_GlobalPooling1D2","_super12","max","GlobalPooling2D","_Layer5","_super13","_this8","GlobalAveragePooling2D","_GlobalPooling2D","_super14","apply","arguments","_this9","GlobalMaxPooling2D","_GlobalPooling2D2","_super15","_this10"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-layers\\src\\layers\\pooling.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, Tensor3D, Tensor4D, Tensor5D, tidy} from '@tensorflow/tfjs-core';\n\nimport {imageDataFormat} from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport {checkDataFormat, checkPaddingMode, checkPoolMode} from '../common';\nimport {InputSpec} from '../engine/topology';\nimport {Layer, LayerArgs} from '../engine/topology';\nimport {NotImplementedError, ValueError} from '../errors';\nimport {DataFormat, PaddingMode, PoolMode, Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\nimport {convOutputLength} from '../utils/conv_utils';\nimport {assertPositiveInteger} from '../utils/generic_utils';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../utils/types_utils';\n\nimport {preprocessConv2DInput, preprocessConv3DInput} from './convolutional';\n\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param strides strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(\n    x: Tensor, poolSize: [number, number], strides?: [number, number],\n    padding?: PaddingMode, dataFormat?: DataFormat,\n    poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat);  // x is NHWC after preprocessing.\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x as Tensor4D, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n          // TODO(cais): Rank check?\n          x as Tensor3D | Tensor4D, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]);  // NHWC -> NCHW.\n    }\n    return y;\n  });\n}\n\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(\n    x: Tensor5D, poolSize: [number, number, number],\n    strides?: [number, number, number], padding?: PaddingMode,\n    dataFormat?: DataFormat, poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x as Tensor, dataFormat) as Tensor5D;\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]);  // NDHWC -> NCDHW.\n    }\n    return y;\n  });\n}\n\nexport declare interface Pooling1DLayerArgs extends LayerArgs {\n  /**\n   * Size of the window to pool over, should be an integer.\n   */\n  poolSize?: number|[number];\n  /**\n   * Period at which to sample the pooled values.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number];\n  /** How to fill in data that's not an integer multiple of poolSize. */\n  padding?: PaddingMode;\n}\n\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport abstract class Pooling1D extends Layer {\n  protected readonly poolSize: [number];\n  protected readonly strides: [number];\n  protected readonly padding: PaddingMode;\n\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args: Pooling1DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    super(args);\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (\n        Array.isArray(args.poolSize) &&\n        (args.poolSize as number[]).length === 1 &&\n        typeof (args.poolSize as number[])[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(\n          `poolSize for 1D convolutional layer must be a number or an ` +\n          `Array of a single number, but received ` +\n          `${JSON.stringify(args.poolSize)}`);\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (\n          Array.isArray(args.strides) &&\n          (args.strides as number[]).length === 1 &&\n          typeof (args.strides as number[])[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(\n            `strides for 1D convolutional layer must be a number or an ` +\n            `Array of a single number, but received ` +\n            `${JSON.stringify(args.strides)}`);\n      }\n    }\n    assertPositiveInteger(this.strides, 'strides');\n\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(\n        inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      // Add dummy last dimension.\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(\n          getExactlyOneTensor(inputs), [this.poolSize[0], 1],\n          [this.strides[0], 1], this.padding, 'channelsLast');\n      // Remove dummy last dimension.\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'MaxPooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling1D);\n\nexport class AveragePooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'AveragePooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling1D);\n\nexport declare interface Pooling2DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [vertical, horizontal].\n   * Expects an integer or an array of 2 integers.\n   *\n   * For example, `[2, 2]` will halve the input in both spatial dimensions.\n   * If only one integer is specified, the same window length\n   * will be used for both dimensions.\n   */\n  poolSize?: number|[number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 2 integers. Integer, tuple of 2 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport abstract class Pooling2D extends Layer {\n  protected readonly poolSize: [number, number];\n  protected readonly strides: [number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling2DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(\n            `If the strides property of a 2D pooling layer is an Array, ` +\n            `it is expected to have a length of 2, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows =\n        convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols =\n        convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'MaxPooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling2D);\n\nexport class AveragePooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'AveragePooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling2D);\n\nexport declare interface Pooling3DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [depth, height, width].\n   * Expects an integer or an array of 3 integers.\n   *\n   * For example, `[2, 2, 2]` will halve the input in three dimensions.\n   * If only one integer is specified, the same window length\n   * will be used for all dimensions.\n   */\n  poolSize?: number|[number, number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 3 integers. Integer, tuple of 3 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport abstract class Pooling3D extends Layer {\n  protected readonly poolSize: [number, number, number];\n  protected readonly strides: [number, number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling3DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(\n            `If the strides property of a 3D pooling layer is an Array, ` +\n            `it is expected to have a length of 3, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 5})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(\n        depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows =\n        convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols =\n        convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor;\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'MaxPooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling3D);\n\nexport class AveragePooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'AveragePooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling3D);\n\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport abstract class GlobalPooling1D extends Layer {\n  constructor(args: LayerArgs) {\n    super(args);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  override computeOutputShape(inputShape: Shape): Shape {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n}\n\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling1D';\n  constructor(args?: LayerArgs) {\n    super(args || {});\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling1D);\n\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling1D';\n  constructor(args: LayerArgs) {\n    super(args || {});\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling1D);\n\nexport declare interface GlobalPooling2DLayerArgs extends LayerArgs {\n  /**\n   * One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n   *\n   * The ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\n   * to inputs with shape `[batch, height, width, channels]` while\n   * `CHANNEL_FIRST` corresponds to inputs with shape\n   * `[batch, channels, height, width]`.\n   */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport abstract class GlobalPooling2D extends Layer {\n  protected dataFormat: DataFormat;\n  constructor(args: GlobalPooling2DLayerArgs) {\n    super(args);\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = inputShape as Shape;\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config = {dataFormat: this.dataFormat};\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling2D';\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling2D);\n\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling2D';\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling2D);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}