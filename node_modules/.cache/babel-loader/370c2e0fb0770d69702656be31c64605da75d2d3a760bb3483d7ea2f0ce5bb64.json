{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\r\n * @license\r\n * Copyright 2022 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nvar RaggedTensorToTensorOp = /*#__PURE__*/function () {\n  function RaggedTensorToTensorOp(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n    _classCallCheck(this, RaggedTensorToTensorOp);\n    this.shape = shape;\n    this.shapeShape = shapeShape;\n    this.values = values;\n    this.valuesShape = valuesShape;\n    this.valuesDType = valuesDType;\n    this.defaultValue = defaultValue;\n    this.defaultValueShape = defaultValueShape;\n    this.rowPartitionValues = rowPartitionValues;\n    this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n    this.rowPartitionTypes = backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n  _createClass(RaggedTensorToTensorOp, [{\n    key: \"getRowPartitionTypeByDimension\",\n    value: function getRowPartitionTypeByDimension(dimension) {\n      if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n        return this.rowPartitionTypes[dimension + 1];\n      } else {\n        return this.rowPartitionTypes[dimension];\n      }\n    }\n    // Returns the relationship between dimension and dimension + 1.\n  }, {\n    key: \"getRowPartitionTensor\",\n    value: function getRowPartitionTensor(dimension) {\n      if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n        return this.rowPartitionValues[dimension + 1];\n      } else {\n        return this.rowPartitionValues[dimension];\n      }\n    }\n  }, {\n    key: \"getMaxWidth\",\n    value: function getMaxWidth(dimension) {\n      var rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n      switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n        case RowPartitionType.VALUE_ROWIDS:\n          return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n        case RowPartitionType.ROW_SPLITS:\n          return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n        default:\n          throw new Error(\"Cannot handle partition type \".concat(RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]));\n      }\n    }\n  }, {\n    key: \"tensorShapeFromTensor\",\n    value: function tensorShapeFromTensor(t, tShape) {\n      var isPartial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (tShape.length === 0) {\n        if (t[0] === -1) {\n          return [];\n        }\n        throw new Error(\"The only valid scalar shape tensor is the fully unknown shape specified as -1.\");\n      }\n      // MakePartialShape/MakeShapeHelper.\n      return makeShape(t, isPartial);\n    }\n  }, {\n    key: \"calculateOutputSize\",\n    value: function calculateOutputSize(firstDim) {\n      var valueShape = this.valuesShape;\n      var defaultValueShape = this.defaultValueShape;\n      backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n      var shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n      var outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n      var result = outputShape;\n      if (result[0] < 0) {\n        result[0] = firstDim;\n      }\n      for (var i = 1; i <= this.raggedRank; ++i) {\n        if (result[i] < 0) {\n          result[i] = this.getMaxWidth(i);\n        }\n      }\n      return result;\n    }\n    /**\r\n     * The outputIndex represents the index in the output tensor\r\n     * where the first element of a particular dimension would be written.\r\n     * If it is -1, it indicates that the index is out of scope.\r\n     * Example, given firstDimension = 10, firstDimensionOutput = 6,\r\n     * and outputIndexMultiplier = 100:\r\n     * result = [0 100 200 300 400 500 -1 -1 -1 -1]\r\n     * If firstDimensionOutput = 11 instead, then:\r\n     * result = [0 100 200 300 400 500 600 700 800 900]\r\n     */\n  }, {\n    key: \"calculateFirstParentOutputIndex\",\n    value: function calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n      var minDimension = Math.min(firstDimension, firstDimensionOutput);\n      var result = [];\n      var currentOutputIndex = 0;\n      for (var i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n        result.push(currentOutputIndex);\n      }\n      for (var _i = minDimension; _i < firstDimension; ++_i) {\n        result.push(-1);\n      }\n      util.assert(result.length === firstDimension, function () {\n        return 'Final length of result must be equal to firstDimension.';\n      });\n      return result;\n    }\n  }, {\n    key: \"calculateOutputIndexRowSplit\",\n    value: function calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n      var rowSplitSize = rowSplit.length;\n      var result = [];\n      for (var i = 0; i < rowSplitSize - 1; ++i) {\n        var rowLength = rowSplit[i + 1] - rowSplit[i];\n        var realLength = Math.min(outputSize, rowLength);\n        var parentOutputIndexCurrent = parentOutputIndex[i];\n        if (parentOutputIndexCurrent === -1) {\n          realLength = 0;\n        }\n        for (var j = 0; j < realLength; ++j) {\n          result.push(parentOutputIndexCurrent);\n          parentOutputIndexCurrent += outputIndexMultiplier;\n        }\n        for (var _j = 0; _j < rowLength - realLength; ++_j) {\n          result.push(-1);\n        }\n      }\n      if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n        throw new Error('Invalid row split size.');\n      }\n      return result;\n    }\n    // Calculate the output index of the first element of a list.\n    // The parentOutputIndex is the same computation for the previous list.\n    // -1 indicates an element or list that is out of range.\n    // The outputIndexMultiplier is the number of output indices one moves\n    // forward for each column.\n    // E.g., given:\n    // valueRowIds:[0 1 2 2 2 3 5 5 6]\n    // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n    // outputIndexMultiplier: 10\n    // outputSize: 2\n    // You get:\n    // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n    // result[0] = parentOutputIndex[valueRowIds[0]]\n    // result[1] = parentOutputIndex[valueRowIds[1]]\n    // result[2] = parentOutputIndex[valueRowIds[2]]\n    // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n    // result[4] = -1 because it is the third element the size is 2.\n    // result[5] = parentOutputIndex[valueRowIds[3]]\n    // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[8] = parentOutputIndex[valueRowIds[7]]\n  }, {\n    key: \"calculateOutputIndexValueRowID\",\n    value: function calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n      var indexSize = valueRowIds.length;\n      var result = [];\n      if (indexSize === 0) {\n        return [];\n      }\n      var currentOutputColumn = 0;\n      var currentValueRowId = valueRowIds[0];\n      if (currentValueRowId >= parentOutputIndex.length) {\n        throw new Error(\"Got currentValueRowId=\".concat(currentValueRowId, \", which is not less than \").concat(parentOutputIndex.length));\n      }\n      var currentOutputIndex = parentOutputIndex[currentValueRowId];\n      result.push(currentOutputIndex);\n      for (var i = 1; i < indexSize; ++i) {\n        var nextValueRowId = valueRowIds[i];\n        if (nextValueRowId === currentValueRowId) {\n          if (currentOutputIndex >= 0) {\n            ++currentOutputColumn;\n            if (currentOutputColumn < outputSize) {\n              currentOutputIndex += outputIndexMultiplier;\n            } else {\n              currentOutputIndex = -1;\n            }\n          }\n        } else {\n          currentOutputColumn = 0;\n          currentValueRowId = nextValueRowId;\n          if (nextValueRowId >= parentOutputIndex.length) {\n            throw new Error(\"Got nextValueRowId=\".concat(nextValueRowId, \" which is not less than \").concat(parentOutputIndex.length));\n          }\n          currentOutputIndex = parentOutputIndex[nextValueRowId];\n        }\n        result.push(currentOutputIndex);\n      }\n      if (result.length !== valueRowIds.length) {\n        throw new Error('Invalid row ids.');\n      }\n      return result;\n    }\n  }, {\n    key: \"calculateOutputIndex\",\n    value: function calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n      var rowPartitionTensor = this.getRowPartitionTensor(dimension);\n      var partitionType = this.getRowPartitionTypeByDimension(dimension);\n      switch (partitionType) {\n        case RowPartitionType.VALUE_ROWIDS:\n          return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n        case RowPartitionType.ROW_SPLITS:\n          if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n            throw new Error(\"Row partition size is greater than output size: \".concat(rowPartitionTensor.length - 1, \" > \").concat(parentOutputIndex.length));\n          }\n          return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n        default:\n          throw new Error(\"Unsupported partition type: \".concat(RowPartitionType[partitionType]));\n      }\n    }\n  }, {\n    key: \"getFirstDimensionSize\",\n    value: function getFirstDimensionSize() {\n      var firstPartitionTensor = this.rowPartitionValues[0];\n      if (this.rowPartitionTypes.length === 0) {\n        throw new Error('No row_partition_types given.');\n      }\n      var firstPartitionType = this.rowPartitionTypes[0];\n      switch (firstPartitionType) {\n        case RowPartitionType.FIRST_DIM_SIZE:\n          return firstPartitionTensor[0];\n        case RowPartitionType.VALUE_ROWIDS:\n          throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n        case RowPartitionType.ROW_SPLITS:\n          return this.rowPartitionValuesShapes[0][0] - 1;\n        default:\n          throw new Error(\"Cannot handle type \".concat(RowPartitionType[firstPartitionType]));\n      }\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var firstPartitionTensor = this.rowPartitionValues[0];\n      if (firstPartitionTensor.length <= 0) {\n        throw new Error('Invalid first partition input. ' + 'Tensor requires at least one element.');\n      }\n      var firstDimension = this.getFirstDimensionSize();\n      var outputSize = this.calculateOutputSize(firstDimension);\n      var multiplier = new Array(this.raggedRank + 1);\n      multiplier[multiplier.length - 1] = 1;\n      for (var i = multiplier.length - 2; i >= 0; --i) {\n        multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n      }\n      // Full size of the tensor.\n      var outputShape = makeShape(outputSize, false);\n      var outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n      var fullSize = multiplier[0] * outputSize[0];\n      if (fullSize > 0) {\n        var outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n        for (var _i2 = 1; _i2 <= this.raggedRank; ++_i2) {\n          var newOutputIndex = this.calculateOutputIndex(_i2 - 1, outputIndex, multiplier[_i2], outputSize[_i2]);\n          outputIndex = newOutputIndex;\n        }\n        this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n      }\n      return [outputShape, outputTensor];\n    }\n  }, {\n    key: \"setOutput\",\n    value: function setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n      if (outputTensor.length === 0) {\n        return;\n      }\n      var valuesBase = this.values;\n      var outputBase = outputTensor;\n      var elementShape = outputShape.slice();\n      elementShape = elementShape.slice(raggedRank + 1);\n      var valueElementSize = util.sizeFromShape(elementShape);\n      var outputIndexSize = outputIndex.length;\n      // Broadcast the default value to value_element_size.  (We can skip this\n      // if defaultValueTensor.size == 1, since we use fill when that's true.)\n      var defaultValue = this.defaultValue;\n      if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n        var srcShape = this.defaultValueShape;\n        tidy(function () {\n          var defaultValueTensor = reshape(defaultValue, srcShape);\n          var bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n          defaultValue = bCastDefault.dataSync();\n        });\n      }\n      // Loop through the outputIndex array, finding contiguous regions that\n      // should be copied.  Once we find the end of a contiguous region, copy it\n      // and add any necessary padding (with defaultValue).\n      var srcStart = 0; // Start of contiguous region (in values)\n      var dstStart = 0; // Destination for contiguous region (in output)\n      var dstEnd = 0; // Destination for contiguous region (in output)\n      for (var srcI = 0; srcI <= outputIndexSize; ++srcI) {\n        // dstI is the destination where the value at srcI should be copied.\n        var dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n        // If we're still in a contiguous region, then update dstEnd go to the\n        // next srcI.\n        if (dstI === dstEnd) {\n          ++dstEnd;\n          continue;\n        }\n        // We found the end of contiguous region.  This can be because we found\n        // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n        // because it's out-of-bounds (dstI == -1), or the end of the tensor\n        // (dstI === -1).\n        if (dstStart < dstEnd) {\n          // Copy the contiguous region.\n          var src = valuesBase.subarray(srcStart * valueElementSize);\n          var dst = outputBase.subarray(dstStart * valueElementSize);\n          var nVals = (dstEnd - dstStart) * valueElementSize;\n          copyArray(dst, src, nVals);\n        }\n        // Add any necessary padding (w/ defaultValue).\n        if (srcI >= outputIndexSize) {\n          // We reached the end of values: pad to the end of output.\n          var outputSize = outputTensor.length;\n          dstI = Math.floor(outputSize / valueElementSize);\n        }\n        if (dstI > dstEnd) {\n          if (this.defaultValue.length === 1) {\n            outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);\n            dstEnd = dstI;\n          } else {\n            while (dstI > dstEnd) {\n              var _dst = outputBase.slice(dstEnd * valueElementSize);\n              copyArray(_dst, defaultValue, valueElementSize);\n              ++dstEnd;\n            }\n          }\n        }\n        // Update indices.\n        if (dstI < 0) {\n          // srcI should be skipped -- leave it out of the contiguous region.\n          srcStart = srcI + 1;\n          dstStart = dstEnd;\n        } else {\n          // srcI should be copied -- include it in the contiguous region.\n          srcStart = srcI;\n          dstStart = dstEnd;\n          dstEnd = dstStart + 1;\n        }\n      }\n    }\n  }], [{\n    key: \"getMaxWidthRowSplit\",\n    value: function getMaxWidthRowSplit(rowSplit) {\n      var tensorLength = rowSplit.length;\n      if (tensorLength === 0 || tensorLength === 1) {\n        return 0;\n      }\n      var maxWidth = 0;\n      for (var i = 0; i < tensorLength - 1; ++i) {\n        var currentWidth = rowSplit[i + 1] - rowSplit[i];\n        if (currentWidth > maxWidth) {\n          maxWidth = currentWidth;\n        }\n      }\n      return maxWidth;\n    }\n  }, {\n    key: \"getMaxWidthValueRowID\",\n    value: function getMaxWidthValueRowID(valueRowIds) {\n      var indexLength = valueRowIds.length;\n      if (indexLength === 0) {\n        return 0;\n      }\n      var firstEqualIndex = 0;\n      var firstEqualIndexValue = valueRowIds[0];\n      var maxWidth = 0;\n      for (var i = 1; i < indexLength; ++i) {\n        var value = valueRowIds[i];\n        if (value !== firstEqualIndexValue) {\n          firstEqualIndexValue = value;\n          maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n          firstEqualIndex = i;\n        }\n      }\n      return Math.max(indexLength - firstEqualIndex, maxWidth);\n    }\n  }]);\n  return RaggedTensorToTensorOp;\n}();\nfunction copyArray(dst, src, size) {\n  for (var i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\nfunction makeShape(shape, isPartial) {\n  var out = [];\n  var _iterator = _createForOfIteratorHelper(shape),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var dim = _step.value;\n      if (dim < 0) {\n        if (!isPartial) {\n          throw new Error(\"Dimension \".concat(dim, \" must be >= 0\"));\n        }\n        if (dim < -1) {\n          throw new Error(\"Dimension \".concat(dim, \" must be >= -1\"));\n        }\n        dim = -1;\n      }\n      out.push(dim);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return out;\n}\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n  return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();\n}","map":{"version":3,"names":["backend_util","broadcastTo","reshape","tidy","util","RowPartitionType","RaggedTensorToTensorOp","shape","shapeShape","values","valuesShape","valuesDType","defaultValue","defaultValueShape","rowPartitionValues","rowPartitionValuesShapes","rowPartitionTypeStrings","_classCallCheck","rowPartitionTypes","getRowPartitionTypesHelper","raggedRank","getRaggedRank","_createClass","key","value","getRowPartitionTypeByDimension","dimension","FIRST_DIM_SIZE","getRowPartitionTensor","getMaxWidth","rowPartitionTensor","VALUE_ROWIDS","getMaxWidthValueRowID","ROW_SPLITS","getMaxWidthRowSplit","Error","concat","tensorShapeFromTensor","t","tShape","isPartial","arguments","length","undefined","makeShape","calculateOutputSize","firstDim","valueShape","validateDefaultValueShape","outputShape","combineRaggedTensorToTensorShapes","result","i","calculateFirstParentOutputIndex","firstDimension","outputIndexMultiplier","firstDimensionOutput","minDimension","Math","min","currentOutputIndex","push","assert","calculateOutputIndexRowSplit","rowSplit","parentOutputIndex","outputSize","rowSplitSize","rowLength","realLength","parentOutputIndexCurrent","j","calculateOutputIndexValueRowID","valueRowIds","indexSize","currentOutputColumn","currentValueRowId","nextValueRowId","calculateOutputIndex","partitionType","getFirstDimensionSize","firstPartitionTensor","firstPartitionType","compute","multiplier","Array","outputTensor","getArrayFromDType","sizeFromShape","fullSize","outputIndex","newOutputIndex","setOutput","valuesBase","outputBase","elementShape","slice","valueElementSize","outputIndexSize","srcShape","defaultValueTensor","bCastDefault","dataSync","srcStart","dstStart","dstEnd","srcI","dstI","src","subarray","dst","nVals","copyArray","floor","fill","tensorLength","maxWidth","currentWidth","indexLength","firstEqualIndex","firstEqualIndexValue","max","size","out","_iterator","_createForOfIteratorHelper","_step","s","n","done","dim","err","e","f","raggedTensorToTensorImpl","shapesShape"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-backend-cpu\\src\\kernels\\RaggedTensorToTensor_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, broadcastTo, DataType, reshape, tidy, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  private readonly rowPartitionTypes: RowPartitionType[];\n  private readonly raggedRank: number;\n  constructor(\n      private shape: TypedArray, private shapeShape: number[],\n      private values: TypedArray, private valuesShape: number[],\n      private valuesDType: DataType, private defaultValue: TypedArray,\n      private defaultValueShape: number[],\n      private readonly rowPartitionValues: TypedArray[],\n      private readonly rowPartitionValuesShapes: number[][],\n      rowPartitionTypeStrings: string[]) {\n    this.rowPartitionTypes =\n        backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n\n  private getRowPartitionTypeByDimension(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n\n  // Returns the relationship between dimension and dimension + 1.\n  private getRowPartitionTensor(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n\n  private getMaxWidth(dimension: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${\n            RowPartitionType[this.getRowPartitionTypeByDimension(\n                dimension - 1)]}`);\n    }\n  }\n\n  static getMaxWidthRowSplit(rowSplit: TypedArray) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  static getMaxWidthValueRowID(valueRowIds: TypedArray) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n\n  private tensorShapeFromTensor(\n      t: TypedArray, tShape: number[], isPartial = true) {\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(\n          `The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n\n  private calculateOutputSize(firstDim: number) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(\n        this.raggedRank, shape, valueShape);\n\n    const result = outputShape;\n\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  private calculateFirstParentOutputIndex(\n      firstDimension: number, outputIndexMultiplier: number,\n      firstDimensionOutput: number) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result: number[] = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension;\n         ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(\n        result.length === firstDimension,\n        () => 'Final length of result must be equal to firstDimension.');\n\n    return result;\n  }\n\n  private calculateOutputIndexRowSplit(\n      rowSplit: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowSplitSize = rowSplit.length;\n    const result: number[] = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n\n    return result;\n  }\n\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  private calculateOutputIndexValueRowID(\n      valueRowIds: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const indexSize = valueRowIds.length;\n    const result: number[] = [];\n    if (indexSize === 0) {\n      return [];\n    }\n\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(\n          `Got currentValueRowId=${currentValueRowId}, which is not less than ${\n              parentOutputIndex.length}`);\n    }\n\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(\n              `Got nextValueRowId=${nextValueRowId} which is not less than ${\n                  parentOutputIndex.length}`);\n        }\n\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n\n    return result;\n  }\n\n  private calculateOutputIndex(\n      dimension: number, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${\n              rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      default:\n        throw new Error(\n            `Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n\n  private getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(\n            `Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n\n  compute(): [number[], TypedArray] {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error(\n          'Invalid first partition input. ' +\n          'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier: number[] = new Array(this.raggedRank + 1);\n\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape: number[] = makeShape(outputSize, false);\n    const outputTensor =\n        util.getArrayFromDType(\n            this.valuesDType, util.sizeFromShape(outputShape)) as TypedArray;\n\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(\n          firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(\n            i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n\n    return [outputShape, outputTensor];\n  }\n  setOutput(\n      raggedRank: number, outputIndex: number[], outputTensor: TypedArray,\n      outputShape: number[]) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0;  // Start of contiguous region (in values)\n    let dstStart = 0;  // Destination for contiguous region (in output)\n    let dstEnd = 0;    // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase\n              .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n              .fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\n\nfunction copyArray(dst: TypedArray, src: TypedArray, size: number) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nfunction makeShape(shape: number[]|TypedArray, isPartial: boolean) {\n  const out: number[] = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n\n  return out;\n}\n\nexport function raggedTensorToTensorImpl(\n    shape: TypedArray, shapesShape: number[], values: TypedArray,\n    valuesShape: number[], valuesDType: DataType, defaultValue: TypedArray,\n    defaultValueShape: number[], rowPartitionValues: TypedArray[],\n    rowPartitionValuesShapes: number[][],\n    rowPartitionTypes: string[]): [number[], TypedArray] {\n  return new RaggedTensorToTensorOp(\n             shape, shapesShape, values, valuesShape, valuesDType, defaultValue,\n             defaultValueShape, rowPartitionValues, rowPartitionValuesShapes,\n             rowPartitionTypes)\n      .compute();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}