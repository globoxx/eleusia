{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nexport var OperationMapper = /*#__PURE__*/function () {\n  // Loads the op mapping from the JSON file.\n  function OperationMapper() {\n    var _ref;\n    _classCallCheck(this, OperationMapper);\n    var ops = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, graph, hashTable, image, logical, matrices, normalization, reduction, sliceJoin, sparse, spectral, string, transformation];\n    var mappersJson = (_ref = []).concat.apply(_ref, _toConsumableArray(ops.map(function (op) {\n      return op.json;\n    })));\n    this.opMappers = mappersJson.reduce(function (map, mapper) {\n      map[mapper.tfOpName] = mapper;\n      return map;\n    }, {});\n  }\n  // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n  _createClass(OperationMapper, [{\n    key: \"transformGraph\",\n    value: function transformGraph(graph) {\n      var _this = this;\n      var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tfNodes = graph.node;\n      var placeholders = [];\n      var weights = [];\n      var initNodes = [];\n      var nodes = tfNodes.reduce(function (map, node) {\n        map[node.name] = _this.mapNode(node);\n        if (node.op.startsWith('Placeholder')) {\n          placeholders.push(map[node.name]);\n        } else if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        } else if (node.input == null || node.input.length === 0) {\n          initNodes.push(map[node.name]);\n        }\n        return map;\n      }, {});\n      var inputs = [];\n      var outputs = [];\n      var inputNodeNameToKey = {};\n      var outputNodeNameToKey = {};\n      if (signature != null) {\n        inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n        outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n      }\n      var allNodes = Object.keys(nodes);\n      allNodes.forEach(function (key) {\n        var node = nodes[key];\n        node.inputNames.forEach(function (name, index) {\n          var _getNodeNameAndIndex = getNodeNameAndIndex(name),\n            _getNodeNameAndIndex2 = _slicedToArray(_getNodeNameAndIndex, 3),\n            nodeName = _getNodeNameAndIndex2[0],\n            outputName = _getNodeNameAndIndex2[2];\n          var inputNode = nodes[nodeName];\n          if (inputNode.outputs != null) {\n            var outputIndex = inputNode.outputs.indexOf(outputName);\n            if (outputIndex !== -1) {\n              var inputName = \"\".concat(nodeName, \":\").concat(outputIndex);\n              // update the input name to use the mapped output index directly.\n              node.inputNames[index] = inputName;\n            }\n          }\n          node.inputs.push(inputNode);\n          inputNode.children.push(node);\n        });\n      });\n      // if signature has not outputs set, add any node that does not have\n      // outputs.\n      if (Object.keys(outputNodeNameToKey).length === 0) {\n        allNodes.forEach(function (key) {\n          var node = nodes[key];\n          if (node.children.length === 0) {\n            outputs.push(node);\n          }\n        });\n      } else {\n        Object.keys(outputNodeNameToKey).forEach(function (name) {\n          var _getNodeNameAndIndex3 = getNodeNameAndIndex(name),\n            _getNodeNameAndIndex4 = _slicedToArray(_getNodeNameAndIndex3, 1),\n            nodeName = _getNodeNameAndIndex4[0];\n          var node = nodes[nodeName];\n          if (node != null) {\n            node.signatureKey = outputNodeNameToKey[name];\n            outputs.push(node);\n          }\n        });\n      }\n      if (Object.keys(inputNodeNameToKey).length > 0) {\n        Object.keys(inputNodeNameToKey).forEach(function (name) {\n          var _getNodeNameAndIndex5 = getNodeNameAndIndex(name),\n            _getNodeNameAndIndex6 = _slicedToArray(_getNodeNameAndIndex5, 1),\n            nodeName = _getNodeNameAndIndex6[0];\n          var node = nodes[nodeName];\n          if (node) {\n            node.signatureKey = inputNodeNameToKey[name];\n            inputs.push(node);\n          }\n        });\n      } else {\n        inputs = placeholders;\n      }\n      var functions = {};\n      if (graph.library != null && graph.library.function != null) {\n        functions = graph.library.function.reduce(function (functions, func) {\n          functions[func.signature.name] = _this.mapFunction(func);\n          return functions;\n        }, {});\n      }\n      var result = {\n        nodes: nodes,\n        inputs: inputs,\n        outputs: outputs,\n        weights: weights,\n        placeholders: placeholders,\n        signature: signature,\n        functions: functions\n      };\n      if (initNodes.length > 0) {\n        result.initNodes = initNodes;\n      }\n      return result;\n    }\n  }, {\n    key: \"mapSignatureEntries\",\n    value: function mapSignatureEntries(entries) {\n      return Object.keys(entries || {}).reduce(function (prev, curr) {\n        prev[entries[curr].name] = curr;\n        return prev;\n      }, {});\n    }\n  }, {\n    key: \"mapNode\",\n    value: function mapNode(node) {\n      // Unsupported ops will cause an error at run-time (not parse time), since\n      // they may not be used by the actual execution subgraph.\n      var mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n      if (node.attr == null) {\n        node.attr = {};\n      }\n      var newNode = {\n        name: node.name,\n        op: node.op,\n        category: mapper.category,\n        inputNames: (node.input || []).map(function (input) {\n          return input.startsWith('^') ? input.slice(1) : input;\n        }),\n        inputs: [],\n        children: [],\n        inputParams: {},\n        attrParams: {},\n        rawAttrs: node.attr,\n        outputs: mapper.outputs\n      };\n      if (mapper.inputs != null) {\n        newNode.inputParams = mapper.inputs.reduce(function (map, param) {\n          map[param.name] = {\n            type: param.type,\n            inputIndexStart: param.start,\n            inputIndexEnd: param.end\n          };\n          return map;\n        }, {});\n      }\n      if (mapper.attrs != null) {\n        newNode.attrParams = mapper.attrs.reduce(function (map, param) {\n          var type = param.type;\n          var value = undefined;\n          switch (param.type) {\n            case 'string':\n              value = getStringParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'string[]':\n              value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'number':\n              value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'number[]':\n              value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'bool':\n              value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'bool[]':\n              value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'shape':\n              value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'shape[]':\n              value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'dtype':\n              value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'dtype[]':\n              value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'func':\n              value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n              if (value === undefined && !!param.tfDeprecatedName) {\n                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n              }\n              break;\n            case 'tensor':\n            case 'tensors':\n              break;\n            default:\n              throw new Error(\"Unsupported param type: \".concat(param.type, \" for op: \").concat(node.op));\n          }\n          map[param.name] = {\n            value: value,\n            type: type\n          };\n          return map;\n        }, {});\n      }\n      return newNode;\n    }\n    // map the TFunctionDef to TFJS graph object\n  }, {\n    key: \"mapFunction\",\n    value: function mapFunction(functionDef) {\n      var _this2 = this;\n      var tfNodes = functionDef.nodeDef;\n      var placeholders = [];\n      var weights = [];\n      var nodes = {};\n      if (tfNodes != null) {\n        nodes = tfNodes.reduce(function (map, node) {\n          map[node.name] = _this2.mapNode(node);\n          if (node.op === 'Const') {\n            weights.push(map[node.name]);\n          }\n          return map;\n        }, {});\n      }\n      var inputs = [];\n      var outputs = [];\n      functionDef.signature.inputArg.forEach(function (arg) {\n        var _getNodeNameAndIndex7 = getNodeNameAndIndex(arg.name),\n          _getNodeNameAndIndex8 = _slicedToArray(_getNodeNameAndIndex7, 1),\n          nodeName = _getNodeNameAndIndex8[0];\n        var node = {\n          name: nodeName,\n          op: 'Placeholder',\n          inputs: [],\n          inputNames: [],\n          category: 'graph',\n          inputParams: {},\n          attrParams: {\n            dtype: {\n              value: parseDtypeParam(arg.type),\n              type: 'dtype'\n            }\n          },\n          children: []\n        };\n        node.signatureKey = arg.name;\n        inputs.push(node);\n        nodes[nodeName] = node;\n      });\n      var allNodes = Object.keys(nodes);\n      allNodes.forEach(function (key) {\n        var node = nodes[key];\n        node.inputNames.forEach(function (name, index) {\n          var _getNodeNameAndIndex9 = getNodeNameAndIndex(name),\n            _getNodeNameAndIndex10 = _slicedToArray(_getNodeNameAndIndex9, 3),\n            nodeName = _getNodeNameAndIndex10[0],\n            outputName = _getNodeNameAndIndex10[2];\n          var inputNode = nodes[nodeName];\n          if (inputNode.outputs != null) {\n            var outputIndex = inputNode.outputs.indexOf(outputName);\n            if (outputIndex !== -1) {\n              var inputName = \"\".concat(nodeName, \":\").concat(outputIndex);\n              // update the input name to use the mapped output index directly.\n              node.inputNames[index] = inputName;\n            }\n          }\n          node.inputs.push(inputNode);\n          inputNode.children.push(node);\n        });\n      });\n      var returnNodeMap = functionDef.ret;\n      functionDef.signature.outputArg.forEach(function (output) {\n        var _getNodeNameAndIndex11 = getNodeNameAndIndex(returnNodeMap[output.name]),\n          _getNodeNameAndIndex12 = _slicedToArray(_getNodeNameAndIndex11, 2),\n          nodeName = _getNodeNameAndIndex12[0],\n          index = _getNodeNameAndIndex12[1];\n        var node = nodes[nodeName];\n        if (node != null) {\n          node.defaultOutput = index;\n          outputs.push(node);\n        }\n      });\n      var signature = this.mapArgsToSignature(functionDef);\n      return {\n        nodes: nodes,\n        inputs: inputs,\n        outputs: outputs,\n        weights: weights,\n        placeholders: placeholders,\n        signature: signature\n      };\n    }\n  }, {\n    key: \"mapArgsToSignature\",\n    value: function mapArgsToSignature(functionDef) {\n      var _this3 = this;\n      return {\n        methodName: functionDef.signature.name,\n        inputs: functionDef.signature.inputArg.reduce(function (map, arg) {\n          map[arg.name] = _this3.mapArgToTensorInfo(arg);\n          return map;\n        }, {}),\n        outputs: functionDef.signature.outputArg.reduce(function (map, arg) {\n          map[arg.name] = _this3.mapArgToTensorInfo(arg, functionDef.ret);\n          return map;\n        }, {})\n      };\n    }\n  }, {\n    key: \"mapArgToTensorInfo\",\n    value: function mapArgToTensorInfo(arg, nameMap) {\n      var name = arg.name;\n      if (nameMap != null) {\n        name = nameMap[name];\n      }\n      return {\n        name: name,\n        dtype: arg.type\n      };\n    }\n  }], [{\n    key: \"Instance\",\n    get:\n    // Singleton instance for the mapper\n    function get() {\n      return this._instance || (this._instance = new this());\n    }\n  }]);\n  return OperationMapper;\n}();\nexport function decodeBase64(text) {\n  var global = env().global;\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error('Unable to decode base64 in this environment. ' + 'Missing built-in atob() or Buffer()');\n  }\n}\nexport function parseStringParam(s, keepCase) {\n  var value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def) {\n  var keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var param = attrs[name];\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n  return def;\n}\nexport function getBoolParam(attrs, name, def) {\n  var param = attrs[name];\n  return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n  var param = attrs[name] || {};\n  var value = param['i'] != null ? param['i'] : param['f'] != null ? param['f'] : def;\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n  if (typeof value === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value];\n  }\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\nexport function getFuncParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param && param.func) {\n    return param.func.name;\n  }\n  return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n  return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(function (v) {\n      return parseDtypeParam(v);\n    });\n  }\n  return def;\n}\nexport function parseTensorShapeParam(shape) {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n  if (shape.dim != null) {\n    return shape.dim.map(function (dim) {\n      return typeof dim.size === 'number' ? dim.size : parseInt(dim.size, 10);\n    });\n  }\n  return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n  return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(function (v) {\n      return typeof v === 'number' ? v : parseInt(v, 10);\n    });\n  }\n  return def;\n}\nexport function getStringArrayParam(attrs, name, def) {\n  var keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var param = attrs[name];\n  if (param && param.list && param.list.s) {\n    return param.list.s.map(function (v) {\n      return parseStringParam(v, keepCase);\n    });\n  }\n  return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map(function (v) {\n      return parseTensorShapeParam(v);\n    });\n  }\n  return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n  var param = attrs[name];\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n  return def;\n}","map":{"version":3,"names":["env","tensorflow","getRegisteredOp","getNodeNameAndIndex","arithmetic","basicMath","control","convolution","creation","dynamic","evaluation","graph","hashTable","image","logical","matrices","normalization","reduction","sliceJoin","sparse","spectral","string","transformation","OperationMapper","_ref","_classCallCheck","ops","mappersJson","concat","apply","_toConsumableArray","map","op","json","opMappers","reduce","mapper","tfOpName","_createClass","key","value","transformGraph","_this","signature","arguments","length","undefined","tfNodes","node","placeholders","weights","initNodes","nodes","name","mapNode","startsWith","push","input","inputs","outputs","inputNodeNameToKey","outputNodeNameToKey","mapSignatureEntries","allNodes","Object","keys","forEach","inputNames","index","_getNodeNameAndIndex","_getNodeNameAndIndex2","_slicedToArray","nodeName","outputName","inputNode","outputIndex","indexOf","inputName","children","_getNodeNameAndIndex3","_getNodeNameAndIndex4","signatureKey","_getNodeNameAndIndex5","_getNodeNameAndIndex6","functions","library","function","func","mapFunction","result","entries","prev","curr","attr","newNode","category","slice","inputParams","attrParams","rawAttrs","param","type","inputIndexStart","start","inputIndexEnd","end","attrs","getStringParam","tfName","defaultValue","tfDeprecatedName","getStringArrayParam","getNumberParam","getNumericArrayParam","getBoolParam","getBoolArrayParam","getTensorShapeParam","getTensorShapeArrayParam","getDtypeParam","getDtypeArrayParam","getFuncParam","Error","functionDef","_this2","nodeDef","inputArg","arg","_getNodeNameAndIndex7","_getNodeNameAndIndex8","dtype","parseDtypeParam","_getNodeNameAndIndex9","_getNodeNameAndIndex10","returnNodeMap","ret","outputArg","output","_getNodeNameAndIndex11","_getNodeNameAndIndex12","defaultOutput","mapArgsToSignature","_this3","methodName","mapArgToTensorInfo","nameMap","get","_instance","decodeBase64","text","global","atob","Buffer","toString","parseStringParam","s","keepCase","Array","isArray","String","fromCharCode","toLowerCase","def","b","parseInt","DataType","DT_FLOAT","DT_HALF","DT_INT32","DT_INT64","DT_INT8","DT_UINT8","DT_BOOL","DT_DOUBLE","DT_STRING","list","v","parseTensorShapeParam","shape","unknownRank","dim","size","f","i"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\operations\\operation_mapper.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, env} from '@tensorflow/tfjs-core';\n\nimport * as tensorflow from '../data/compiled_api';\n\nimport {getRegisteredOp} from './custom_op/register';\nimport {getNodeNameAndIndex} from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nimport {Graph, InputParamValue, Node, OpMapper, ParamValue} from './types';\n\nexport class OperationMapper {\n  private static _instance: OperationMapper;\n\n  private opMappers: {[key: string]: OpMapper};\n\n  // Singleton instance for the mapper\n  public static get Instance() {\n    return this._instance || (this._instance = new this());\n  }\n\n  // Loads the op mapping from the JSON file.\n  private constructor() {\n    const ops = [\n      arithmetic, basicMath, control, convolution, creation, dynamic,\n      evaluation, graph, hashTable, image, logical, matrices, normalization,\n      reduction, sliceJoin, sparse, spectral, string, transformation\n    ];\n    const mappersJson: OpMapper[] = [].concat(...ops.map(op => op.json));\n\n    this.opMappers = mappersJson.reduce<{[key: string]: OpMapper}>(\n        (map, mapper: OpMapper) => {\n          map[mapper.tfOpName] = mapper;\n          return map;\n        },\n        {});\n  }\n\n  // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n  transformGraph(\n      graph: tensorflow.IGraphDef,\n      signature: tensorflow.ISignatureDef = {}): Graph {\n    const tfNodes = graph.node;\n    const placeholders: Node[] = [];\n    const weights: Node[] = [];\n    const initNodes: Node[] = [];\n    const nodes = tfNodes.reduce<{[key: string]: Node}>((map, node) => {\n      map[node.name] = this.mapNode(node);\n      if (node.op.startsWith('Placeholder')) {\n        placeholders.push(map[node.name]);\n      } else if (node.op === 'Const') {\n        weights.push(map[node.name]);\n      } else if (node.input == null || node.input.length === 0) {\n        initNodes.push(map[node.name]);\n      }\n      return map;\n    }, {});\n\n    let inputs: Node[] = [];\n    const outputs: Node[] = [];\n    let inputNodeNameToKey: {[key: string]: string} = {};\n    let outputNodeNameToKey: {[key: string]: string} = {};\n    if (signature != null) {\n      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n    }\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName, , outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n\n    // if signature has not outputs set, add any node that does not have\n    // outputs.\n    if (Object.keys(outputNodeNameToKey).length === 0) {\n      allNodes.forEach(key => {\n        const node = nodes[key];\n        if (node.children.length === 0) {\n          outputs.push(node);\n        }\n      });\n    } else {\n      Object.keys(outputNodeNameToKey).forEach(name => {\n        const [nodeName, ] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node != null) {\n          node.signatureKey = outputNodeNameToKey[name];\n          outputs.push(node);\n        }\n      });\n    }\n\n    if (Object.keys(inputNodeNameToKey).length > 0) {\n      Object.keys(inputNodeNameToKey).forEach(name => {\n        const [nodeName, ] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node) {\n          node.signatureKey = inputNodeNameToKey[name];\n          inputs.push(node);\n        }\n      });\n    } else {\n      inputs = placeholders;\n    }\n\n    let functions = {};\n    if (graph.library != null && graph.library.function != null) {\n      functions = graph.library.function.reduce((functions, func) => {\n        functions[func.signature.name] = this.mapFunction(func);\n        return functions;\n      }, {} as {[key: string]: Graph});\n    }\n\n    const result: Graph =\n        {nodes, inputs, outputs, weights, placeholders, signature, functions};\n\n    if (initNodes.length > 0) {\n      result.initNodes = initNodes;\n    }\n\n    return result;\n  }\n\n  private mapSignatureEntries(entries: {[k: string]: tensorflow.ITensorInfo}) {\n    return Object.keys(entries || {})\n        .reduce<{[key: string]: string}>((prev, curr) => {\n          prev[entries[curr].name] = curr;\n          return prev;\n        }, {});\n  }\n\n  private mapNode(node: tensorflow.INodeDef): Node {\n    // Unsupported ops will cause an error at run-time (not parse time), since\n    // they may not be used by the actual execution subgraph.\n    const mapper =\n        getRegisteredOp(node.op) || this.opMappers[node.op] || {} as OpMapper;\n    if (node.attr == null) {\n      node.attr = {};\n    }\n\n    const newNode: Node = {\n      name: node.name,\n      op: node.op,\n      category: mapper.category,\n      inputNames:\n          (node.input ||\n           []).map(input => input.startsWith('^') ? input.slice(1) : input),\n      inputs: [],\n      children: [],\n      inputParams: {},\n      attrParams: {},\n      rawAttrs: node.attr,\n      outputs: mapper.outputs\n    };\n\n    if (mapper.inputs != null) {\n      newNode.inputParams =\n          mapper.inputs.reduce<{[key: string]: InputParamValue}>(\n              (map, param) => {\n                map[param.name] = {\n                  type: param.type,\n                  inputIndexStart: param.start,\n                  inputIndexEnd: param.end\n                };\n                return map;\n              },\n              {});\n    }\n    if (mapper.attrs != null) {\n      newNode.attrParams =\n          mapper.attrs.reduce<{[key: string]: ParamValue}>((map, param) => {\n            const type = param.type;\n            let value = undefined;\n            switch (param.type) {\n              case 'string':\n                value = getStringParam(\n                    node.attr, param.tfName, param.defaultValue as string);\n\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getStringParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string);\n                }\n                break;\n              case 'string[]':\n                value = getStringArrayParam(\n                    node.attr, param.tfName, param.defaultValue as string[]);\n\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getStringArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string[]);\n                }\n                break;\n              case 'number':\n                value = getNumberParam(\n                    node.attr, param.tfName,\n                    (param.defaultValue || 0) as number);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getNumberParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number);\n                }\n                break;\n              case 'number[]':\n                value = getNumericArrayParam(\n                    node.attr, param.tfName, param.defaultValue as number[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getNumericArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[]);\n                }\n                break;\n              case 'bool':\n                value = getBoolParam(\n                    node.attr, param.tfName, param.defaultValue as boolean);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getBoolParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as boolean);\n                }\n                break;\n              case 'bool[]':\n                value = getBoolArrayParam(\n                    node.attr, param.tfName, param.defaultValue as boolean[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getBoolArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as boolean[]);\n                }\n                break;\n              case 'shape':\n                value = getTensorShapeParam(\n                    node.attr, param.tfName, param.defaultValue as number[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getTensorShapeParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[]);\n                }\n                break;\n              case 'shape[]':\n                value = getTensorShapeArrayParam(\n                    node.attr, param.tfName, param.defaultValue as number[][]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getTensorShapeArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[][]);\n                }\n                break;\n              case 'dtype':\n                value = getDtypeParam(\n                    node.attr, param.tfName, param.defaultValue as DataType);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getDtypeParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as DataType);\n                }\n                break;\n              case 'dtype[]':\n                value = getDtypeArrayParam(\n                    node.attr, param.tfName, param.defaultValue as DataType[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getDtypeArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as DataType[]);\n                }\n                break;\n              case 'func':\n                value = getFuncParam(\n                    node.attr, param.tfName, param.defaultValue as string);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getFuncParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string);\n                }\n                break;\n              case 'tensor':\n              case 'tensors':\n                break;\n              default:\n                throw new Error(\n                    `Unsupported param type: ${param.type} for op: ${node.op}`);\n            }\n            map[param.name] = {value, type};\n            return map;\n          }, {});\n    }\n    return newNode;\n  }\n\n  // map the TFunctionDef to TFJS graph object\n  private mapFunction(functionDef: tensorflow.IFunctionDef): Graph {\n    const tfNodes = functionDef.nodeDef;\n    const placeholders: Node[] = [];\n    const weights: Node[] = [];\n    let nodes: {[key: string]: Node} = {};\n    if (tfNodes != null) {\n      nodes = tfNodes.reduce<{[key: string]: Node}>((map, node) => {\n        map[node.name] = this.mapNode(node);\n        if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        }\n        return map;\n      }, {});\n    }\n    const inputs: Node[] = [];\n    const outputs: Node[] = [];\n\n    functionDef.signature.inputArg.forEach(arg => {\n      const [nodeName, ] = getNodeNameAndIndex(arg.name);\n      const node: Node = {\n        name: nodeName,\n        op: 'Placeholder',\n        inputs: [],\n        inputNames: [],\n        category: 'graph',\n        inputParams: {},\n        attrParams: {dtype: {value: parseDtypeParam(arg.type), type: 'dtype'}},\n        children: []\n      };\n      node.signatureKey = arg.name;\n      inputs.push(node);\n      nodes[nodeName] = node;\n    });\n\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName, , outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n\n    const returnNodeMap = functionDef.ret;\n\n    functionDef.signature.outputArg.forEach(output => {\n      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n      const node = nodes[nodeName];\n      if (node != null) {\n        node.defaultOutput = index;\n        outputs.push(node);\n      }\n    });\n\n    const signature = this.mapArgsToSignature(functionDef);\n    return {nodes, inputs, outputs, weights, placeholders, signature};\n  }\n\n  private mapArgsToSignature(functionDef: tensorflow.IFunctionDef):\n      tensorflow.ISignatureDef {\n    return {\n      methodName: functionDef.signature.name,\n      inputs: functionDef.signature.inputArg.reduce(\n          (map, arg) => {\n            map[arg.name] = this.mapArgToTensorInfo(arg);\n            return map;\n          },\n          {} as {[key: string]: tensorflow.ITensorInfo}),\n      outputs: functionDef.signature.outputArg.reduce(\n          (map, arg) => {\n            map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n            return map;\n          },\n          {} as {[key: string]: tensorflow.ITensorInfo}),\n    };\n  }\n\n  private mapArgToTensorInfo(\n      arg: tensorflow.OpDef.IArgDef,\n      nameMap?: {[key: string]: string}): tensorflow.ITensorInfo {\n    let name = arg.name;\n    if (nameMap != null) {\n      name = nameMap[name];\n    }\n    return {name, dtype: arg.type};\n  }\n}\n\nexport function decodeBase64(text: string): string {\n  const global = env().global;\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error(\n        'Unable to decode base64 in this environment. ' +\n        'Missing built-in atob() or Buffer()');\n  }\n}\n\nexport function parseStringParam(s: []|string, keepCase: boolean): string {\n  const value =\n      Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\n\nexport function getStringParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string, def: string,\n    keepCase = false): string {\n  const param = attrs[name];\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n  return def;\n}\n\nexport function getBoolParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: boolean): boolean {\n  const param = attrs[name];\n  return param ? param.b : def;\n}\n\nexport function getNumberParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number): number {\n  const param = attrs[name] || {};\n  const value =\n      param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n  return (typeof value === 'number') ? value : parseInt(value, 10);\n}\n\nexport function parseDtypeParam(value: string|tensorflow.DataType): DataType {\n  if (typeof (value) === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value as any];\n  }\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\n\nexport function getFuncParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: string): string {\n  const param = attrs[name];\n  if (param && param.func) {\n    return param.func.name;\n  }\n  return def;\n}\n\nexport function getDtypeParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: DataType): DataType {\n  const param = attrs[name];\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n  return def;\n}\n\nexport function getDtypeArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: DataType[]): DataType[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(v => parseDtypeParam(v));\n  }\n  return def;\n}\n\nexport function parseTensorShapeParam(shape: tensorflow.ITensorShape): number[]|\n    undefined {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n  if (shape.dim != null) {\n    return shape.dim.map(\n        dim =>\n            (typeof dim.size === 'number') ? dim.size : parseInt(dim.size, 10));\n  }\n  return [];\n}\n\nexport function getTensorShapeParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def?: number[]): number[]|undefined {\n  const param = attrs[name];\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n  return def;\n}\n\nexport function getNumericArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number[]): number[] {\n  const param = attrs[name];\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f :\n                                                   param.list.i) ||\n            [])\n        .map(v => (typeof v === 'number') ? v : parseInt(v, 10));\n  }\n  return def;\n}\n\nexport function getStringArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string, def: string[],\n    keepCase = false): string[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.s) {\n    return param.list.s.map((v) => {\n      return parseStringParam(v, keepCase);\n    });\n  }\n  return def;\n}\n\nexport function getTensorShapeArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number[][]): number[][] {\n  const param = attrs[name];\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map((v) => {\n      return parseTensorShapeParam(v);\n    });\n  }\n  return def;\n}\n\nexport function getBoolArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: boolean[]): boolean[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n  return def;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}