{"ast":null,"code":"import _slicedToArray from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getPadding, getParamValue } from './utils';\nfunction fusedConvAndDepthWiseParams(node, tensorMap, context) {\n  var _getParamValue = getParamValue('fusedOps', node, tensorMap, context),\n    _getParamValue2 = _slicedToArray(_getParamValue, 2),\n    extraOp = _getParamValue2[0],\n    activationFunc = _getParamValue2[1];\n  var isBiasAdd = extraOp === 'biasadd';\n  var noBiasAdd = !isBiasAdd;\n  var isPrelu = activationFunc === 'prelu';\n  var isBatchNorm = extraOp === 'fusedbatchnorm';\n  var numArgs = getParamValue('numArgs', node, tensorMap, context);\n  if (isBiasAdd) {\n    if (isPrelu && numArgs !== 2) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' + 'must have two extra arguments: bias and alpha.');\n    }\n    if (!isPrelu && isBiasAdd && numArgs !== 1) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd must have ' + 'one extra argument: bias.');\n    }\n  }\n  if (isBatchNorm) {\n    throw new Error('FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported');\n  }\n  var stride = getParamValue('strides', node, tensorMap, context);\n  var pad = getPadding(node, tensorMap, context);\n  var dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n  var dilations = getParamValue('dilations', node, tensorMap, context);\n  var _getParamValue3 = getParamValue('args', node, tensorMap, context),\n    _getParamValue4 = _slicedToArray(_getParamValue3, 2),\n    biasArg = _getParamValue4[0],\n    preluArg = _getParamValue4[1];\n  if (noBiasAdd) {\n    preluArg = biasArg;\n    biasArg = undefined;\n  }\n  var leakyreluAlpha = getParamValue('leakyreluAlpha', node, tensorMap, context);\n  return {\n    stride: stride,\n    pad: pad,\n    dataFormat: dataFormat,\n    dilations: dilations,\n    biasArg: biasArg,\n    preluArg: preluArg,\n    activationFunc: activationFunc,\n    leakyreluAlpha: leakyreluAlpha\n  };\n}\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  var ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n  switch (node.op) {\n    case 'Conv1D':\n      {\n        var stride = getParamValue('stride', node, tensorMap, context);\n        var pad = getParamValue('pad', node, tensorMap, context);\n        var dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        var dilation = getParamValue('dilation', node, tensorMap, context);\n        return [ops.conv1d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n      }\n    case 'Conv2D':\n      {\n        var _stride = getParamValue('strides', node, tensorMap, context);\n        var _pad = getPadding(node, tensorMap, context);\n        var _dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        var dilations = getParamValue('dilations', node, tensorMap, context);\n        return [ops.conv2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [_stride[1], _stride[2]], _pad, _dataFormat, [dilations[1], dilations[2]])];\n      }\n    case '_FusedConv2D':\n      {\n        var _fusedConvAndDepthWis = fusedConvAndDepthWiseParams(node, tensorMap, context),\n          _stride2 = _fusedConvAndDepthWis.stride,\n          _pad2 = _fusedConvAndDepthWis.pad,\n          _dataFormat2 = _fusedConvAndDepthWis.dataFormat,\n          _dilations = _fusedConvAndDepthWis.dilations,\n          biasArg = _fusedConvAndDepthWis.biasArg,\n          preluArg = _fusedConvAndDepthWis.preluArg,\n          activationFunc = _fusedConvAndDepthWis.activationFunc,\n          leakyreluAlpha = _fusedConvAndDepthWis.leakyreluAlpha;\n        return [ops.fused.conv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [_stride2[1], _stride2[2]],\n          pad: _pad2,\n          dataFormat: _dataFormat2,\n          dilations: [_dilations[1], _dilations[2]],\n          bias: biasArg,\n          activation: activationFunc,\n          preluActivationWeights: preluArg,\n          leakyreluAlpha: leakyreluAlpha\n        })];\n      }\n    case 'FusedDepthwiseConv2dNative':\n      {\n        var _fusedConvAndDepthWis2 = fusedConvAndDepthWiseParams(node, tensorMap, context),\n          _stride3 = _fusedConvAndDepthWis2.stride,\n          _pad3 = _fusedConvAndDepthWis2.pad,\n          _dataFormat3 = _fusedConvAndDepthWis2.dataFormat,\n          _dilations2 = _fusedConvAndDepthWis2.dilations,\n          _biasArg = _fusedConvAndDepthWis2.biasArg,\n          _preluArg = _fusedConvAndDepthWis2.preluArg,\n          _activationFunc = _fusedConvAndDepthWis2.activationFunc,\n          _leakyreluAlpha = _fusedConvAndDepthWis2.leakyreluAlpha;\n        return [ops.fused.depthwiseConv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [_stride3[1], _stride3[2]],\n          pad: _pad3,\n          dataFormat: _dataFormat3,\n          dilations: [_dilations2[1], _dilations2[2]],\n          bias: _biasArg,\n          activation: _activationFunc,\n          preluActivationWeights: _preluArg,\n          leakyreluAlpha: _leakyreluAlpha\n        })];\n      }\n    case 'Conv2DBackpropInput':\n    case 'Conv2dTranspose':\n      {\n        var shape = getParamValue('outputShape', node, tensorMap, context);\n        var _stride4 = getParamValue('strides', node, tensorMap, context);\n        var _pad4 = getPadding(node, tensorMap, context);\n        return [ops.conv2dTranspose(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), shape, [_stride4[1], _stride4[2]], _pad4)];\n      }\n    case 'DepthwiseConv2dNative':\n    case 'DepthwiseConv2d':\n      {\n        var _stride5 = getParamValue('strides', node, tensorMap, context);\n        var _pad5 = getPadding(node, tensorMap, context);\n        var _dilations3 = getParamValue('dilations', node, tensorMap, context);\n        var _dataFormat4 = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        return [ops.depthwiseConv2d(getParamValue('input', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [_stride5[1], _stride5[2]], _pad5, _dataFormat4, [_dilations3[1], _dilations3[2]])];\n      }\n    case 'Conv3D':\n      {\n        var _stride6 = getParamValue('strides', node, tensorMap, context);\n        var _pad6 = getParamValue('pad', node, tensorMap, context);\n        var _dataFormat5 = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        var _dilations4 = getParamValue('dilations', node, tensorMap, context);\n        return [ops.conv3d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [_stride6[1], _stride6[2], _stride6[3]], _pad6, _dataFormat5, [_dilations4[1], _dilations4[2], _dilations4[3]])];\n      }\n    case 'AvgPool':\n      {\n        var _stride7 = getParamValue('strides', node, tensorMap, context);\n        var _pad7 = getParamValue('pad', node, tensorMap, context);\n        var kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.avgPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [_stride7[1], _stride7[2]], _pad7)];\n      }\n    case 'MaxPool':\n      {\n        var _stride8 = getParamValue('strides', node, tensorMap, context);\n        var _pad8 = getParamValue('pad', node, tensorMap, context);\n        var _kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.maxPool(getParamValue('x', node, tensorMap, context), [_kernelSize[1], _kernelSize[2]], [_stride8[1], _stride8[2]], _pad8)];\n      }\n    case 'MaxPoolWithArgmax':\n      {\n        var _stride9 = getParamValue('strides', node, tensorMap, context);\n        var _pad9 = getParamValue('pad', node, tensorMap, context);\n        var _kernelSize2 = getParamValue('kernelSize', node, tensorMap, context);\n        var includeBatchInIndex = getParamValue('includeBatchInIndex', node, tensorMap, context);\n        var _ops$maxPoolWithArgma = ops.maxPoolWithArgmax(getParamValue('x', node, tensorMap, context), [_kernelSize2[1], _kernelSize2[2]], [_stride9[1], _stride9[2]], _pad9, includeBatchInIndex),\n          result = _ops$maxPoolWithArgma.result,\n          indexes = _ops$maxPoolWithArgma.indexes;\n        return [result, indexes];\n      }\n    case 'AvgPool3D':\n      {\n        var _stride10 = getParamValue('strides', node, tensorMap, context);\n        var _pad10 = getParamValue('pad', node, tensorMap, context);\n        var _kernelSize3 = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.avgPool3d(getParamValue('x', node, tensorMap, context), [_kernelSize3[1], _kernelSize3[2], _kernelSize3[3]], [_stride10[1], _stride10[2], _stride10[3]], _pad10)];\n      }\n    case 'MaxPool3D':\n      {\n        var _stride11 = getParamValue('strides', node, tensorMap, context);\n        var _pad11 = getParamValue('pad', node, tensorMap, context);\n        var _kernelSize4 = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.maxPool3d(getParamValue('x', node, tensorMap, context), [_kernelSize4[1], _kernelSize4[2], _kernelSize4[3]], [_stride11[1], _stride11[2], _stride11[3]], _pad11)];\n      }\n    case 'Dilation2D':\n      {\n        var strides = getParamValue('strides', node, tensorMap, context);\n        var _pad12 = getParamValue('pad', node, tensorMap, context);\n        var _dilations5 = getParamValue('dilations', node, tensorMap, context);\n        // strides: [1, stride_height, stride_width, 1].\n        var strideHeight = strides[1];\n        var strideWidth = strides[2];\n        // dilations: [1, dilation_height, dilation_width, 1].\n        var dilationHeight = _dilations5[1];\n        var dilationWidth = _dilations5[2];\n        return [ops.dilation2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [strideHeight, strideWidth], _pad12, [dilationHeight, dilationWidth], 'NHWC' /* dataFormat */)];\n      }\n\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'convolution';","map":{"version":3,"names":["tfOps","getPadding","getParamValue","fusedConvAndDepthWiseParams","node","tensorMap","context","_getParamValue","_getParamValue2","_slicedToArray","extraOp","activationFunc","isBiasAdd","noBiasAdd","isPrelu","isBatchNorm","numArgs","Error","stride","pad","dataFormat","toUpperCase","dilations","_getParamValue3","_getParamValue4","biasArg","preluArg","undefined","leakyreluAlpha","executeOp","ops","arguments","length","op","dilation","conv1d","conv2d","_fusedConvAndDepthWis","fused","x","filter","strides","bias","activation","preluActivationWeights","_fusedConvAndDepthWis2","depthwiseConv2d","shape","conv2dTranspose","conv3d","kernelSize","avgPool","maxPool","includeBatchInIndex","_ops$maxPoolWithArgma","maxPoolWithArgmax","result","indexes","avgPool3d","maxPool3d","strideHeight","strideWidth","dilationHeight","dilationWidth","dilation2d","TypeError","concat","CATEGORY"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-converter\\src\\operations\\executors\\convolution_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Rank, Tensor, Tensor3D, Tensor4D, Tensor5D} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getPadding, getParamValue} from './utils';\n\nfunction fusedConvAndDepthWiseParams(\n    node: Node, tensorMap: NamedTensorsMap, context: ExecutionContext) {\n  const [extraOp, activationFunc] =\n      (getParamValue('fusedOps', node, tensorMap, context) as string[]);\n\n  const isBiasAdd = extraOp === 'biasadd';\n  const noBiasAdd = !isBiasAdd;\n  const isPrelu = activationFunc === 'prelu';\n  const isBatchNorm = extraOp === 'fusedbatchnorm';\n\n  const numArgs =\n      (getParamValue('numArgs', node, tensorMap, context) as number);\n  if (isBiasAdd) {\n    if (isPrelu && numArgs !== 2) {\n      throw new Error(\n          'FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' +\n          'must have two extra arguments: bias and alpha.');\n    }\n    if (!isPrelu && isBiasAdd && numArgs !== 1) {\n      throw new Error(\n          'FusedConv2d and DepthwiseConv2d with BiasAdd must have ' +\n          'one extra argument: bias.');\n    }\n  }\n  if (isBatchNorm) {\n    throw new Error(\n        'FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported');\n  }\n  const stride = getParamValue('strides', node, tensorMap, context) as number[];\n  const pad = getPadding(node, tensorMap, context);\n  const dataFormat =\n      (getParamValue('dataFormat', node, tensorMap, context) as string)\n          .toUpperCase();\n  const dilations =\n      getParamValue('dilations', node, tensorMap, context) as number[];\n  let [biasArg, preluArg] =\n      getParamValue('args', node, tensorMap, context) as Tensor[];\n  if (noBiasAdd) {\n    preluArg = biasArg;\n    biasArg = undefined;\n  }\n  const leakyreluAlpha =\n      getParamValue('leakyreluAlpha', node, tensorMap, context) as number;\n\n  return {\n    stride,\n    pad,\n    dataFormat,\n    dilations,\n    biasArg,\n    preluArg,\n    activationFunc,\n    leakyreluAlpha\n  };\n}\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext, ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'Conv1D': {\n          const stride =\n              getParamValue('stride', node, tensorMap, context) as number;\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n          const dilation =\n              getParamValue('dilation', node, tensorMap, context) as number;\n          return [ops.conv1d(\n              getParamValue('x', node, tensorMap, context) as Tensor3D,\n              getParamValue('filter', node, tensorMap, context) as Tensor3D,\n              stride, pad as 'valid' | 'same', dataFormat as 'NWC' | 'NCW',\n              dilation)];\n        }\n        case 'Conv2D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getPadding(node, tensorMap, context);\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n          return [ops.conv2d(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor4D,\n              [stride[1], stride[2]], pad as 'valid' | 'same',\n              dataFormat as 'NHWC' | 'NCHW', [dilations[1], dilations[2]])];\n        }\n        case '_FusedConv2D': {\n          const {\n            stride,\n            pad,\n            dataFormat,\n            dilations,\n            biasArg,\n            preluArg,\n            activationFunc,\n            leakyreluAlpha\n          } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n\n          return [ops.fused.conv2d({\n            x: getParamValue('x', node, tensorMap, context) as Tensor3D |\n                Tensor4D,\n            filter: getParamValue('filter', node, tensorMap, context) as\n                Tensor4D,\n            strides: [stride[1], stride[2]],\n            pad: pad as 'valid' | 'same',\n            dataFormat: dataFormat as 'NHWC' | 'NCHW',\n            dilations: [dilations[1], dilations[2]],\n            bias: biasArg,\n            activation: activationFunc as tfOps.fused.Activation,\n            preluActivationWeights: preluArg,\n            leakyreluAlpha\n          })];\n        }\n\n        case 'FusedDepthwiseConv2dNative': {\n          const {\n            stride,\n            pad,\n            dataFormat,\n            dilations,\n            biasArg,\n            preluArg,\n            activationFunc,\n            leakyreluAlpha,\n          } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n\n          return [ops.fused.depthwiseConv2d({\n            x: getParamValue('x', node, tensorMap, context) as Tensor3D |\n                Tensor4D,\n            filter: getParamValue('filter', node, tensorMap, context) as\n                Tensor4D,\n            strides: [stride[1], stride[2]],\n            pad: pad as 'valid' | 'same',\n            dataFormat: dataFormat as 'NHWC' | 'NCHW',\n            dilations: [dilations[1], dilations[2]],\n            bias: biasArg,\n            activation: activationFunc as tfOps.fused.Activation,\n            preluActivationWeights: preluArg,\n            leakyreluAlpha\n          })];\n        }\n        case 'Conv2DBackpropInput':\n        case 'Conv2dTranspose': {\n          const shape = getParamValue(\n                            'outputShape', node, tensorMap,\n                            context) as [number, number, number] |\n              [number, number, number, number];\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getPadding(node, tensorMap, context);\n          return [ops.conv2dTranspose(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor4D,\n              shape, [stride[1], stride[2]], pad as 'valid' | 'same')];\n        }\n        case 'DepthwiseConv2dNative':\n        case 'DepthwiseConv2d': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getPadding(node, tensorMap, context);\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n\n          return [ops.depthwiseConv2d(\n              getParamValue('input', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor4D,\n              [stride[1], stride[2]], pad as 'valid' | 'same',\n              dataFormat as 'NHWC' | 'NCHW', [dilations[1], dilations[2]])];\n        }\n        case 'Conv3D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n          return [ops.conv3d(\n              getParamValue('x', node, tensorMap, context) as Tensor4D |\n                  Tensor<Rank.R5>,\n              getParamValue('filter', node, tensorMap, context) as\n                  Tensor<Rank.R5>,\n              [stride[1], stride[2], stride[3]], pad as 'valid' | 'same',\n              dataFormat as 'NDHWC' | 'NCDHW',\n              [dilations[1], dilations[2], dilations[3]])];\n        }\n        case 'AvgPool': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.avgPool(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              [kernelSize[1], kernelSize[2]], [stride[1], stride[2]],\n              pad as 'valid' | 'same')];\n        }\n        case 'MaxPool': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.maxPool(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              [kernelSize[1], kernelSize[2]], [stride[1], stride[2]],\n              pad as 'valid' | 'same')];\n        }\n        case 'MaxPoolWithArgmax': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n          const includeBatchInIndex =\n              getParamValue('includeBatchInIndex', node, tensorMap, context) as\n              boolean;\n          const {result, indexes} = ops.maxPoolWithArgmax(\n              getParamValue('x', node, tensorMap, context) as Tensor4D,\n              [kernelSize[1], kernelSize[2]], [stride[1], stride[2]],\n              pad as 'valid' | 'same', includeBatchInIndex);\n          return [result, indexes];\n        }\n        case 'AvgPool3D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.avgPool3d(\n              getParamValue('x', node, tensorMap, context) as Tensor5D,\n              [kernelSize[1], kernelSize[2], kernelSize[3]],\n              [stride[1], stride[2], stride[3]], pad as 'valid' | 'same')];\n        }\n\n        case 'MaxPool3D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.maxPool3d(\n              getParamValue('x', node, tensorMap, context) as Tensor5D,\n              [kernelSize[1], kernelSize[2], kernelSize[3]],\n              [stride[1], stride[2], stride[3]], pad as 'valid' | 'same')];\n        }\n\n        case 'Dilation2D': {\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n\n          // strides: [1, stride_height, stride_width, 1].\n          const strideHeight = strides[1];\n          const strideWidth = strides[2];\n\n          // dilations: [1, dilation_height, dilation_width, 1].\n          const dilationHeight = dilations[1];\n          const dilationWidth = dilations[2];\n\n          return [ops.dilation2d(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor3D,\n              [strideHeight, strideWidth], pad as 'valid' | 'same',\n              [dilationHeight, dilationWidth], 'NHWC' /* dataFormat */)];\n        }\n\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'convolution';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}