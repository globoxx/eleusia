{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/vince/OneDrive/Documents/GitHub/eleusia/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * =============================================================================\r\n */\nimport { LazyIterator, OneToManyIterator } from './lazy_iterator';\nexport var StringIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(StringIterator, _LazyIterator);\n  var _super = _createSuper(StringIterator);\n  function StringIterator() {\n    _classCallCheck(this, StringIterator);\n    return _super.apply(this, arguments);\n  }\n  _createClass(StringIterator, [{\n    key: \"split\",\n    value:\n    /**\r\n     * Splits a string stream on a given separator.\r\n     *\r\n     * It is assumed that the incoming chunk boundaries have no semantic meaning,\r\n     * so conceptually the incoming stream is treated simply as the concatenation\r\n     * of its elements.\r\n     *\r\n     * The outgoing stream provides chunks corresponding to the results of the\r\n     * standard string split() operation (even if such a chunk spanned incoming\r\n     * chunks).  The separators are not included.\r\n     *\r\n     * A typical usage is to split a text file (represented as a stream with\r\n     * arbitrary chunk boundaries) into lines.\r\n     *\r\n     * @param upstream A readable stream of strings that can be treated as\r\n     *   concatenated.\r\n     * @param separator A character to split on.\r\n     */\n    function split(separator) {\n      return new SplitIterator(this, separator);\n    }\n  }]);\n  return StringIterator;\n}(LazyIterator);\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on StringIterator.  Unfortunately they can't be placed in separate files, due\n// to resulting trouble with circular imports.\n// ============================================================================\n// We wanted multiple inheritance, e.g.\n//   class SplitIterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\nvar SplitIterator = /*#__PURE__*/function (_StringIterator) {\n  _inherits(SplitIterator, _StringIterator);\n  var _super2 = _createSuper(SplitIterator);\n  function SplitIterator(upstream, separator) {\n    var _this;\n    _classCallCheck(this, SplitIterator);\n    _this = _super2.call(this);\n    _this.upstream = upstream;\n    _this.impl = new SplitIteratorImpl(upstream, separator);\n    return _this;\n  }\n  _createClass(SplitIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.impl.summary();\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.impl.next());\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function next() {\n        return _next.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return SplitIterator;\n}(StringIterator);\nvar SplitIteratorImpl = /*#__PURE__*/function (_OneToManyIterator) {\n  _inherits(SplitIteratorImpl, _OneToManyIterator);\n  var _super3 = _createSuper(SplitIteratorImpl);\n  function SplitIteratorImpl(upstream, separator) {\n    var _this2;\n    _classCallCheck(this, SplitIteratorImpl);\n    _this2 = _super3.call(this);\n    _this2.upstream = upstream;\n    _this2.separator = separator;\n    // A partial string at the end of an upstream chunk\n    _this2.carryover = '';\n    return _this2;\n  }\n  _createClass(SplitIteratorImpl, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Split('\").concat(this.separator, \"')\");\n    }\n  }, {\n    key: \"pump\",\n    value: function () {\n      var _pump = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var chunkResult, lines, _iterator, _step, line;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.upstream.next();\n            case 2:\n              chunkResult = _context2.sent;\n              if (!chunkResult.done) {\n                _context2.next = 9;\n                break;\n              }\n              if (!(this.carryover === '')) {\n                _context2.next = 6;\n                break;\n              }\n              return _context2.abrupt(\"return\", false);\n            case 6:\n              // Pretend that the pump succeeded in order to emit the small last batch.\n              // The next pump() call will actually fail.\n              this.outputQueue.push(this.carryover);\n              this.carryover = '';\n              return _context2.abrupt(\"return\", true);\n            case 9:\n              lines = chunkResult.value.split(this.separator); // Note the behavior: \" ab \".split(' ') === ['', 'ab', '']\n              // Thus the carryover may be '' if the separator falls on a chunk\n              // boundary; this produces the correct result.\n              lines[0] = this.carryover + lines[0];\n              _iterator = _createForOfIteratorHelper(lines.slice(0, -1));\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  line = _step.value;\n                  this.outputQueue.push(line);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              this.carryover = lines[lines.length - 1];\n              return _context2.abrupt(\"return\", true);\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function pump() {\n        return _pump.apply(this, arguments);\n      }\n      return pump;\n    }()\n  }]);\n  return SplitIteratorImpl;\n}(OneToManyIterator);","map":{"version":3,"names":["LazyIterator","OneToManyIterator","StringIterator","_LazyIterator","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","split","separator","SplitIterator","_StringIterator","_super2","upstream","_this","call","impl","SplitIteratorImpl","summary","_next","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","stop","_OneToManyIterator","_super3","_this2","carryover","concat","_pump","_callee2","chunkResult","lines","_iterator","_step","line","_callee2$","_context2","sent","done","outputQueue","push","_createForOfIteratorHelper","slice","s","n","err","e","f","length","pump"],"sources":["C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\tfjs-data\\src\\iterators\\string_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {LazyIterator, OneToManyIterator} from './lazy_iterator';\n\nexport abstract class StringIterator extends LazyIterator<string> {\n  /**\n   * Splits a string stream on a given separator.\n   *\n   * It is assumed that the incoming chunk boundaries have no semantic meaning,\n   * so conceptually the incoming stream is treated simply as the concatenation\n   * of its elements.\n   *\n   * The outgoing stream provides chunks corresponding to the results of the\n   * standard string split() operation (even if such a chunk spanned incoming\n   * chunks).  The separators are not included.\n   *\n   * A typical usage is to split a text file (represented as a stream with\n   * arbitrary chunk boundaries) into lines.\n   *\n   * @param upstream A readable stream of strings that can be treated as\n   *   concatenated.\n   * @param separator A character to split on.\n   */\n  split(separator: string): StringIterator {\n    return new SplitIterator(this, separator);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on StringIterator.  Unfortunately they can't be placed in separate files, due\n// to resulting trouble with circular imports.\n// ============================================================================\n\n// We wanted multiple inheritance, e.g.\n//   class SplitIterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\n\nclass SplitIterator extends StringIterator {\n  private impl: SplitIteratorImpl;\n\n  constructor(protected upstream: LazyIterator<string>, separator: string) {\n    super();\n    this.impl = new SplitIteratorImpl(upstream, separator);\n  }\n\n  summary() {\n    return this.impl.summary();\n  }\n\n  async next() {\n    return this.impl.next();\n  }\n}\n\nclass SplitIteratorImpl extends OneToManyIterator<string> {\n  // A partial string at the end of an upstream chunk\n  carryover = '';\n\n  constructor(\n      protected upstream: LazyIterator<string>, protected separator: string) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Split('${this.separator}')`;\n  }\n\n  async pump(): Promise<boolean> {\n    const chunkResult = await this.upstream.next();\n    if (chunkResult.done) {\n      if (this.carryover === '') {\n        return false;\n      }\n\n      // Pretend that the pump succeeded in order to emit the small last batch.\n      // The next pump() call will actually fail.\n      this.outputQueue.push(this.carryover);\n      this.carryover = '';\n      return true;\n    }\n    const lines = chunkResult.value.split(this.separator) as string[];\n    // Note the behavior: \" ab \".split(' ') === ['', 'ab', '']\n    // Thus the carryover may be '' if the separator falls on a chunk\n    // boundary; this produces the correct result.\n\n    lines[0] = this.carryover + lines[0];\n    for (const line of lines.slice(0, -1)) {\n      this.outputQueue.push(line);\n    }\n    this.carryover = lines[lines.length - 1];\n\n    return true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}