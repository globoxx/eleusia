[{"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\index.tsx":"1","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\App.tsx":"2","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\GameBoard.tsx":"3","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Home.tsx":"4","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\UsersTable.tsx":"5","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ImagesContainer.tsx":"6","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Timer.tsx":"7","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\TransferImage.tsx":"8","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\HelpTooltip.tsx":"9","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\RulesModal.tsx":"10","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\PointsModal.tsx":"11","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\EndOfGameModal.tsx":"12","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ScoreChart.tsx":"13","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\AIModel.tsx":"14"},{"size":281,"mtime":1679154289792,"results":"15","hashOfConfig":"16"},{"size":2115,"mtime":1714553230314,"results":"17","hashOfConfig":"16"},{"size":13870,"mtime":1714554584377,"results":"18","hashOfConfig":"16"},{"size":12595,"mtime":1714558240014,"results":"19","hashOfConfig":"16"},{"size":2340,"mtime":1705438681725,"results":"20","hashOfConfig":"16"},{"size":811,"mtime":1685958580889,"results":"21","hashOfConfig":"16"},{"size":1907,"mtime":1680807404567,"results":"22","hashOfConfig":"16"},{"size":5681,"mtime":1684860074858,"results":"23","hashOfConfig":"16"},{"size":357,"mtime":1683833471082,"results":"24","hashOfConfig":"16"},{"size":4557,"mtime":1714556853517,"results":"25","hashOfConfig":"16"},{"size":1999,"mtime":1714553895475,"results":"26","hashOfConfig":"16"},{"size":2427,"mtime":1714665454288,"results":"27","hashOfConfig":"16"},{"size":8256,"mtime":1714561393807,"results":"28","hashOfConfig":"16"},{"size":3323,"mtime":1712663311593,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"19mbejs",{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42"},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","suppressedMessages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","suppressedMessages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\index.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\App.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\GameBoard.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Home.tsx",["74"],[],"import React, { useCallback, useEffect, useState } from 'react'\r\nimport { TextField, Button, Grid, Accordion, AccordionSummary, AccordionDetails, MenuItem, Select, ImageList, ImageListItem, Box, Typography, Stack, IconButton, Tooltip, Switch, FormControlLabel } from '@mui/material'\r\nimport { Socket } from 'socket.io-client'\r\nimport { ExpandMoreOutlined, FileDownloadOutlined } from '@mui/icons-material'\r\nimport TransferImage from './TransferImage'\r\nimport HelpTooltip from './HelpTooltip'\r\nimport MenuBookIcon from '@mui/icons-material/MenuBook';\r\nimport RulesModal from './Modals/RulesModal'\r\n\r\nfunction Home({ socket, callbackPseudoChange, callbackRoomChange, callbackJoinRoom }: { socket: Socket, callbackPseudoChange: (e: React.ChangeEvent<HTMLInputElement>) => void, callbackRoomChange: (e: React.ChangeEvent<HTMLInputElement>) => void, callbackJoinRoom: (room: string) => void }) {\r\n    const [rooms, setRooms] = useState<string[]>([])\r\n    const [pseudo, setPseudo] = useState('')\r\n    const [room, setRoom] = useState('')\r\n\r\n    const [allImages, setAllImages] = useState<{ [folder: string]: string[] }>({})\r\n    const [left, setLeft] = useState<string[]>([])\r\n    const [right, setRight] = useState<string[]>([])\r\n\r\n    const [newRoom, setNewRoom] = useState('')\r\n    const [newRoomRoundDuration, setNewRoomRoundDuration] = useState('')\r\n    const [newRoomImageSet, setNewRoomImageSet] = useState('')\r\n    const [newRoomRule, setNewRoomRule] = useState('')\r\n    const [labelsSwitchChecked, setLabelsSwitchChecked] = useState(false)\r\n    const [AISwitchChecked, setAISwitchChecked] = useState(false)\r\n\r\n    const [isRulesModalOpen, setIsRulesModalOpen] = useState(false)\r\n\r\n    const selectedImages = newRoomImageSet && allImages[newRoomImageSet] ? allImages[newRoomImageSet] : []\r\n\r\n    const handlePseudoChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        callbackPseudoChange(e)\r\n        setPseudo(e.target.value)\r\n    }\r\n    const handleRoomChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        callbackRoomChange(e)\r\n        setRoom(e.target.value)\r\n    }\r\n\r\n    const handleLabelsSwitchChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        setLabelsSwitchChecked(event.target.checked)\r\n    }\r\n\r\n    const handleAISwitchChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        setAISwitchChecked(event.target.checked)\r\n    }\r\n\r\n    const callbackLabels = useCallback((newLeft: string[], newRight: string[]) => {\r\n        setLeft(newLeft)\r\n        setRight(newRight)\r\n    }, [])\r\n\r\n    const handleClickJoinRoom = () => {\r\n        if (pseudo && room) {\r\n            if (rooms.includes(room)) {\r\n                socket.emit('joinRoom', room, pseudo)\r\n                callbackJoinRoom(room)\r\n            } else {\r\n                alert('Cette room n\\'existe pas ou a déjà commencé.')\r\n            }\r\n        } else {\r\n            alert('Choisissez un pseudo et un numéro de room à rejoindre.')\r\n        }\r\n    }\r\n    const handleClickCreateRoom = () => {\r\n        socket.emit('createRoom', pseudo, newRoom, parseInt(newRoomRoundDuration), newRoomImageSet, newRoomRule, labelsSwitchChecked, AISwitchChecked, left, right)\r\n        callbackJoinRoom(newRoom)\r\n    }\r\n\r\n    const downloadImages = (newRoomImageSet: string) => {\r\n        fetch('/images_to_download/' + newRoomImageSet + '.zip').then(response => {\r\n            response.blob().then(blob => {\r\n                // Creating new object of PDF file\r\n                const fileURL = window.URL.createObjectURL(blob)\r\n                // Setting various property values\r\n                let alink = document.createElement('a')\r\n                alink.href = fileURL\r\n                alink.download = 'images.zip'\r\n                alink.click()\r\n            })\r\n        })\r\n    }\r\n\r\n    useEffect(() => {\r\n        socket.on('updateRooms', (rooms: string[]) => {\r\n            setRooms(rooms)\r\n        })\r\n\r\n        socket.on('updateImages', (allImages: { [folder: string]: string[] }) => {\r\n            setAllImages(allImages)\r\n        })\r\n\r\n        socket.on('roomAlreadyExists', () => {\r\n            alert('Ce numéro de room existe déjà.')\r\n        })\r\n\r\n        socket.on('pseudoAlreadyExists', () => {\r\n            alert('Ce pseudo existe déjà dans cette room.')\r\n        })\r\n    }, [socket])\r\n\r\n    return (\r\n        <>\r\n        <Grid container justifyContent=\"center\" spacing={5}>\r\n            <Grid item textAlign=\"center\" xs={12}>\r\n                <Button variant=\"contained\" color=\"success\" endIcon={<MenuBookIcon />} onClick={() => setIsRulesModalOpen(true)} style={{ position: \"absolute\", left: 20 }}>\r\n                    Règles du jeu\r\n                </Button>\r\n                <Typography variant=\"h3\">ELEUS-IA</Typography>\r\n                <Typography variant=\"h5\">Dans la peau d'une intelligence artificielle</Typography>\r\n            </Grid>\r\n            <Grid item textAlign=\"center\" xs={12}>\r\n                <TextField required label=\"Pseudo\" value={pseudo} onChange={handlePseudoChange} variant=\"outlined\" />\r\n            </Grid>\r\n            <Grid item xs={6}>\r\n                <Accordion>\r\n                    <AccordionSummary expandIcon={<ExpandMoreOutlined />} sx={{ backgroundColor: 'lightblue' }}>\r\n                        <Stack direction=\"row\" alignItems=\"center\">\r\n                            <Typography variant=\"h6\">Rejoindre une room</Typography>\r\n                            <HelpTooltip title=\"Si vous ne connaissez pas le numéro de la room, demandez à son créateur de vous le communiquer.\" />\r\n                        </Stack>\r\n                    </AccordionSummary>\r\n                    <AccordionDetails>\r\n                        <Stack spacing={2}>\r\n                            <TextField label=\"Room code\" value={room} onChange={handleRoomChange} variant=\"outlined\" />\r\n                            <Button variant=\"contained\" disabled={pseudo.length === 0 || room.length === 0} onClick={handleClickJoinRoom}>Rejoindre la room !</Button>\r\n                        </Stack>\r\n                    </AccordionDetails>\r\n                </Accordion>\r\n            </Grid>\r\n            <Grid item xs={6}>\r\n                <Accordion>\r\n                    <AccordionSummary expandIcon={<ExpandMoreOutlined />} sx={{ backgroundColor: 'lightblue' }}>\r\n                        <Stack direction=\"row\" alignItems=\"center\">\r\n                            <Typography variant=\"h6\">Créer une nouvelle room</Typography>\r\n                            <HelpTooltip title=\"Vous serez le maître de la room créée. Vous pourrez choisir le jeu de données, les labels ainsi que la configuration de la partie.\" />\r\n                        </Stack>\r\n                    </AccordionSummary>\r\n                    <AccordionDetails>\r\n                        <Stack spacing={2}>\r\n                            <TextField required label=\"Room code\" value={newRoom} onChange={(e) => setNewRoom(e.target.value)} variant=\"outlined\" fullWidth />\r\n                            <Select\r\n                                value={newRoomRoundDuration}\r\n                                displayEmpty\r\n                                fullWidth\r\n                                onChange={(e) => setNewRoomRoundDuration(e.target.value)}\r\n                            >\r\n                                <MenuItem value={''} selected>Sélectionne le temps offert pour chaque prédiction</MenuItem>\r\n                                <MenuItem value={'10'}>Très court (10 secondes)</MenuItem>\r\n                                <MenuItem value={'15'}>Court (15 secondes)</MenuItem>\r\n                                <MenuItem value={'20'}>Moyen (20 secondes)</MenuItem>\r\n                                <MenuItem value={'30'}>Long (30 secondes)</MenuItem>\r\n                            </Select>\r\n                            <Stack direction=\"row\" justifyContent=\"space-between\" spacing={2}>\r\n                                <Select\r\n                                    value={newRoomImageSet}\r\n                                    displayEmpty\r\n                                    fullWidth\r\n                                    onChange={(e) => setNewRoomImageSet(e.target.value)}\r\n                                >\r\n                                    <MenuItem value={''} selected>Sélectionne un ensemble d'images</MenuItem>\r\n                                    <MenuItem value={'cards'}>Cartes</MenuItem>\r\n                                    <MenuItem value={'shapes'}>Formes</MenuItem>\r\n                                    <MenuItem value={'faces'}>Visages</MenuItem>\r\n                                    <MenuItem value={'cars'}>Voitures</MenuItem>\r\n                                    <MenuItem value={'animals'}>Animaux</MenuItem>\r\n                                    <MenuItem value={'abstract'}>Art abstrait</MenuItem>\r\n                                    <MenuItem value={'objects'}>Objets</MenuItem>\r\n                                    <MenuItem value={'words'}>Mots</MenuItem>\r\n                                </Select>\r\n                                <Tooltip title=\"Télécharger\">\r\n                                    <IconButton color=\"primary\" onClick={() => downloadImages(newRoomImageSet)} disabled={newRoomImageSet.length === 0}><FileDownloadOutlined /></IconButton>\r\n                                </Tooltip>\r\n                            </Stack>\r\n                            {newRoomImageSet &&\r\n                                <Box sx={{ maxHeight: 200, overflow: 'auto' }}>\r\n                                    <ImageList variant=\"masonry\" cols={8}>\r\n                                        {selectedImages.slice(0, 50).map((item: string) => (\r\n                                            <ImageListItem key={item}>\r\n                                                <img\r\n                                                    src={`${item}?w=50&fit=crop&auto=format`}\r\n                                                    srcSet={`${item}?w=50&fit=crop&auto=format&dpr=2 2x`}\r\n                                                    alt={item}\r\n                                                    loading=\"lazy\" />\r\n                                            </ImageListItem>\r\n                                        ))}\r\n                                    </ImageList>\r\n                                </Box>\r\n                            }\r\n                            <Stack direction=\"row\" alignItems=\"center\">\r\n                                <FormControlLabel control={<Switch checked={labelsSwitchChecked} onChange={handleLabelsSwitchChange} inputProps={{ 'aria-label': 'controlled' }} />} label=\"Préparer les labels à l'avance\" />\r\n                                <HelpTooltip title=\"Cocher cette option permet de définir les labels à l'avance. Cela vous permet de ne pas avoir à catégoriser les images en cours de partie.\" />\r\n                            </Stack>\r\n                            <TransferImage key={newRoomImageSet} visible={labelsSwitchChecked} imagesList={selectedImages} callback={callbackLabels} />\r\n                            <Stack direction=\"row\" alignItems=\"center\">\r\n                                <FormControlLabel control={<Switch checked={AISwitchChecked} onChange={handleAISwitchChange} inputProps={{ 'aria-label': 'controlled' }} />} label=\"Ajouter une IA comme joueur (beta)\" />\r\n                                <HelpTooltip title=\"Cocher cette option va ajouter une IA à la liste des joueurs. Elle va s'entraîner à chaque image et faire ses prédictions comme tout autre joueur. Le modèle est un MobileNet-V3-small pré-entrainé identique à celui de Teachable Machine de Google.\" />\r\n                            </Stack>\r\n                            <TextField required label=\"Règle d'acceptation\" multiline value={newRoomRule} onChange={(e) => setNewRoomRule(e.target.value)} variant=\"outlined\" fullWidth />\r\n                            <Button sx={{ marginTop: 2 }} variant=\"contained\" disabled={pseudo.length == 0 || newRoom.length === 0 || newRoomImageSet.length === 0 || newRoomRoundDuration.length === 0 || newRoomRule.length === 0 || (labelsSwitchChecked && (left.length === 0 || right.length === 0))} onClick={handleClickCreateRoom}>{labelsSwitchChecked ? 'Préparer la room !' : 'Créer la room et superviser !'}</Button>\r\n                        </Stack>\r\n                    </AccordionDetails>\r\n                </Accordion>\r\n            </Grid>\r\n        </Grid>\r\n        <RulesModal open={isRulesModalOpen} handleClose={() => setIsRulesModalOpen(false)} />\r\n        </>\r\n    )\r\n}\r\n\r\nexport default Home","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\UsersTable.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ImagesContainer.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Timer.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\TransferImage.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\HelpTooltip.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\RulesModal.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\PointsModal.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\EndOfGameModal.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ScoreChart.tsx",["75"],[],"import React, { useEffect, useState } from 'react'\r\nimport {CategoryScale, Chart, Chart as ChartJS, Legend, LineElement, LinearScale, PointElement, Title, Tooltip} from 'chart.js'\r\nimport { Line } from 'react-chartjs-2'\r\nimport { FormControlLabel, Switch } from '@mui/material'\r\n\r\nChartJS.register(\r\n    CategoryScale,\r\n    LinearScale,\r\n    PointElement,\r\n    LineElement,\r\n    Title,\r\n    Tooltip,\r\n    Legend\r\n)\r\n\r\nfunction cumulativeSum(numbers: number[]) {\r\n    let cumulativeSum = 0\r\n    const cumulativeSums = [0]\r\n  \r\n    for (let i = 0; i < numbers.length; i++) {\r\n      cumulativeSum += numbers[i]\r\n      cumulativeSums.push(cumulativeSum)\r\n    }\r\n  \r\n    return cumulativeSums\r\n}\r\n\r\nfunction generateRange(a: number, b: number) {\r\n    const range: number[] = []\r\n    for (let i = a; i <= b; i++) {\r\n      range.push(i)\r\n    }\r\n    return range\r\n}\r\n\r\nconst COLORS = [\r\n  'rgba(255, 99, 132, 0.5)',\r\n  'rgba(54, 162, 235, 0.5)',\r\n  'rgba(255, 206, 86, 0.5)',\r\n  'rgba(75, 192, 192, 0.5)',\r\n  'rgba(153, 102, 255, 0.5)',\r\n  'rgba(255, 159, 64, 0.5)',\r\n  'rgba(255, 99, 132, 0.5)',\r\n  'rgba(54, 162, 235, 0.5)',\r\n]\r\n\r\n\r\nexport default function ScoreChart({scores, pseudo, isCreator, allImages, allLabels}: {scores: {[pseudo: string]: number[]}, pseudo: string, isCreator: boolean, allImages: string[], allLabels: string[]}){\r\n    const [cummulative, setCummulative] = useState(false)\r\n    const [initialScores, setInitialScores] = useState(scores) // Copie les scores dans l'état lors du montage\r\n\r\n    useEffect(() => {\r\n        setInitialScores(scores) // Met à jour initialScores seulement lors du montage\r\n    }, []) // Passer un tableau vide comme dépendance rend l'effet exécutable seulement lors du montage\r\n\r\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        setCummulative(event.target.checked)\r\n    }\r\n\r\n    const nb_predictions = Object.values(initialScores)[0].length\r\n    const labels = cummulative ? generateRange(0, nb_predictions) : generateRange(1, nb_predictions)\r\n\r\n    const data = {\r\n        labels: labels,\r\n        datasets: Object.keys(initialScores).map((player, index) => ({\r\n            label: player,\r\n            data: cummulative ? cumulativeSum(Object.values(initialScores[player])) : Object.values(initialScores[player]),\r\n            backgroundColor: COLORS[index % COLORS.length],\r\n            borderColor: COLORS[index % COLORS.length].replace('0.5', '1'),\r\n            hidden: !isCreator && player !== pseudo,\r\n        })),\r\n    }\r\n\r\n    // Options de la chart\r\n    const options = {\r\n        responsive: true,\r\n        plugins: {\r\n            legend: {\r\n              position: 'top' as const,\r\n            },\r\n            title: {\r\n              display: true,\r\n              text: cummulative ? 'Evolution du score total' : 'Evolution de la qualité des prédictions',\r\n            },\r\n            tooltip: {\r\n              enabled: false,\r\n              external: (context) => externalTooltipHandler(context, allImages, allLabels, cummulative),\r\n            },\r\n        },\r\n        scales: {\r\n            x: {\r\n              title: {\r\n                display: true,\r\n                text: 'Prédiction',\r\n              },\r\n            },\r\n            y: {\r\n              title: {\r\n                display: true,\r\n                text: 'Score',\r\n              },\r\n            }\r\n        },\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <FormControlLabel control={<Switch checked={cummulative} onChange={handleChange} inputProps={{ 'aria-label': 'controlled' }} />} label=\"Afficher score total\" />\r\n            <Line data={data} options={options} />\r\n        </>\r\n    )\r\n  }\r\n\r\n  const getImageForDataPoint = (images: string[], dataIndex: number) => {\r\n    if (0 <= dataIndex && dataIndex < images.length) {\r\n      return images[dataIndex]\r\n    }\r\n    return null\r\n  }\r\n  const getLabelForDataPoint = (labels: string[], dataIndex: number) => {\r\n    if (0 <= dataIndex && dataIndex < labels.length) {\r\n      return labels[dataIndex]\r\n    }\r\n    return null\r\n  }\r\n\r\n  const getOrCreateTooltip = (chart: Chart<'line'>): HTMLDivElement => {\r\n    let tooltipEl = chart.canvas.parentNode.querySelector('div');\r\n  \r\n    if (!tooltipEl) {\r\n      tooltipEl = document.createElement('div');\r\n      tooltipEl.style.background = 'rgba(0, 0, 0, 0.7)';\r\n      tooltipEl.style.borderRadius = '3px';\r\n      tooltipEl.style.color = 'white';\r\n      tooltipEl.style.opacity = '1';\r\n      tooltipEl.style.pointerEvents = 'none';\r\n      tooltipEl.style.position = 'absolute';\r\n      tooltipEl.style.transform = 'translate(-50%, 0)';\r\n      tooltipEl.style.transition = 'all .1s ease';\r\n  \r\n      const table = document.createElement('table');\r\n      table.style.margin = '0px';\r\n  \r\n      tooltipEl.appendChild(table);\r\n      chart.canvas.parentNode.appendChild(tooltipEl);\r\n    }\r\n  \r\n    return tooltipEl;\r\n  };\r\n  \r\n  const externalTooltipHandler = (context, images: string[], labels: string[], cummulative: boolean) => {\r\n    // Tooltip Element\r\n    const {chart, tooltip} = context;\r\n    const tooltipEl = getOrCreateTooltip(chart);\r\n  \r\n    // Hide if no tooltip\r\n    if (tooltip.opacity === 0) {\r\n      tooltipEl.style.opacity = '0';\r\n      return;\r\n    }\r\n  \r\n    // Set Text\r\n    if (tooltip.body) {\r\n      const titleLines = tooltip.title || [];\r\n      const bodyLines = tooltip.body.map(b => b.lines);\r\n\r\n      // Get the first data point under the tooltip\r\n      const firstPoint = tooltip.dataPoints[0];\r\n      let dataIndex = firstPoint.dataIndex;\r\n      if (cummulative) {\r\n        dataIndex -= 1\r\n      }\r\n\r\n      // Use datasetIndex and dataIndex to get the appropriate image\r\n      const imageSrc = getImageForDataPoint(images, dataIndex);\r\n      const label = getLabelForDataPoint(labels, dataIndex)\r\n  \r\n      const tableHead = document.createElement('thead');\r\n  \r\n      titleLines.forEach(title => {\r\n        const tr = document.createElement('tr');\r\n        tr.style.borderWidth = '0';\r\n  \r\n        const th = document.createElement('th');\r\n        th.style.borderWidth = '0';\r\n        const text = document.createTextNode(title);\r\n  \r\n        th.appendChild(text);\r\n        tr.appendChild(th);\r\n        tableHead.appendChild(tr);\r\n      });\r\n  \r\n      const tableBody = document.createElement('tbody');\r\n      bodyLines.forEach((body, i) => {\r\n        // Add image only for one point even when multiple points are under the cursor (logic to be improved in the future here)\r\n        if (i === 0) {\r\n          const img = document.createElement('img');\r\n          img.src = imageSrc\r\n          img.style.height = '200px';\r\n          img.style.marginRight = '10px';\r\n          img.style.backgroundColor = 'white';\r\n\r\n          const textAboveImage = document.createTextNode('Label: ' + label);\r\n    \r\n          const tr = document.createElement('tr');\r\n          tr.style.backgroundColor = 'inherit';\r\n          tr.style.borderWidth = '0';\r\n    \r\n          const td = document.createElement('td');\r\n          td.style.borderWidth = '0';\r\n          td.style.textAlign = 'center';\r\n    \r\n          const text = document.createTextNode(body);\r\n    \r\n          if (imageSrc && label) {\r\n            td.appendChild(textAboveImage)\r\n            td.appendChild(document.createElement(\"br\"))\r\n            td.appendChild(img)\r\n            td.appendChild(document.createElement(\"br\"))\r\n          }\r\n          td.appendChild(text);\r\n          tr.appendChild(td);\r\n          tableBody.appendChild(tr);\r\n        }\r\n      });\r\n  \r\n      const tableRoot = tooltipEl.querySelector('table');\r\n  \r\n      // Remove old children\r\n      while (tableRoot.firstChild) {\r\n        tableRoot.firstChild.remove();\r\n      }\r\n  \r\n      // Add new children\r\n      tableRoot.appendChild(tableHead);\r\n      tableRoot.appendChild(tableBody);\r\n    }\r\n  \r\n    const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;\r\n  \r\n    // Display, position, and set styles for font\r\n    tooltipEl.style.opacity = '1';\r\n    tooltipEl.style.left = positionX + tooltip.caretX + 'px';\r\n    tooltipEl.style.top = positionY +tooltip.caretY + 'px';\r\n    tooltipEl.style.font = tooltip.options.bodyFont.string;\r\n    tooltipEl.style.padding = tooltip.options.padding + 'px ' + tooltip.options.padding + 'px';\r\n  };","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\AIModel.tsx",[],[],{"ruleId":"76","severity":1,"message":"77","line":199,"column":103,"nodeType":"78","messageId":"79","endLine":199,"endColumn":105},{"ruleId":"80","severity":1,"message":"81","line":54,"column":8,"nodeType":"82","endLine":54,"endColumn":10,"suggestions":"83"},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'scores'. Either include it or remove the dependency array. If 'setInitialScores' needs the current value of 'scores', you can also switch to useReducer instead of useState and read 'scores' in the reducer.","ArrayExpression",["84"],{"desc":"85","fix":"86"},"Update the dependencies array to be: [scores]",{"range":"87","text":"88"},[1624,1626],"[scores]"]