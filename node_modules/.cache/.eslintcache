[{"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\index.tsx":"1","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\App.tsx":"2","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\GameBoard.tsx":"3","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Home.tsx":"4","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\UsersTable.tsx":"5","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ImagesContainer.tsx":"6","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Timer.tsx":"7","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\TransferImage.tsx":"8","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\HelpTooltip.tsx":"9","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\RulesModal.tsx":"10","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\PointsModal.tsx":"11","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\EndOfGameModal.tsx":"12","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ScoreChart.tsx":"13","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\AIModel.tsx":"14"},{"size":281,"mtime":1679154289792,"results":"15","hashOfConfig":"16"},{"size":2115,"mtime":1714553230314,"results":"17","hashOfConfig":"16"},{"size":13759,"mtime":1686033332385,"results":"18","hashOfConfig":"16"},{"size":12624,"mtime":1685971906819,"results":"19","hashOfConfig":"16"},{"size":2340,"mtime":1705438681725,"results":"20","hashOfConfig":"16"},{"size":811,"mtime":1685958580889,"results":"21","hashOfConfig":"16"},{"size":1907,"mtime":1680807404567,"results":"22","hashOfConfig":"16"},{"size":5681,"mtime":1684860074858,"results":"23","hashOfConfig":"16"},{"size":357,"mtime":1683833471082,"results":"24","hashOfConfig":"16"},{"size":4389,"mtime":1714553937575,"results":"25","hashOfConfig":"16"},{"size":1999,"mtime":1714553895475,"results":"26","hashOfConfig":"16"},{"size":2004,"mtime":1685954746418,"results":"27","hashOfConfig":"16"},{"size":8099,"mtime":1686037535399,"results":"28","hashOfConfig":"16"},{"size":3323,"mtime":1712663311593,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"19mbejs",{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","suppressedMessages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","suppressedMessages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","suppressedMessages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","suppressedMessages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69"},{"filePath":"70","messages":"71","suppressedMessages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\index.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\App.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\GameBoard.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Home.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\UsersTable.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ImagesContainer.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Timer.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\TransferImage.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\HelpTooltip.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\RulesModal.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\PointsModal.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\Modals\\EndOfGameModal.tsx",[],[],"C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\ScoreChart.tsx",["73"],[],"import React, { useEffect, useState } from 'react'\r\nimport {CategoryScale, Chart, Chart as ChartJS, Legend, LineElement, LinearScale, PointElement, Title, Tooltip} from 'chart.js'\r\nimport { Line } from 'react-chartjs-2'\r\nimport { FormControlLabel, Switch } from '@mui/material'\r\n\r\nChartJS.register(\r\n    CategoryScale,\r\n    LinearScale,\r\n    PointElement,\r\n    LineElement,\r\n    Title,\r\n    Tooltip,\r\n    Legend\r\n)\r\n\r\nfunction cumulativeSum(numbers: number[]) {\r\n    let cumulativeSum = 0\r\n    const cumulativeSums = [0]\r\n  \r\n    for (let i = 0; i < numbers.length; i++) {\r\n      cumulativeSum += numbers[i]\r\n      cumulativeSums.push(cumulativeSum)\r\n    }\r\n  \r\n    return cumulativeSums\r\n}\r\n\r\nfunction generateRange(a: number, b: number) {\r\n    const range: number[] = []\r\n    for (let i = a; i <= b; i++) {\r\n      range.push(i)\r\n    }\r\n    return range\r\n}\r\n\r\nconst COLORS = [\r\n  'rgba(255, 99, 132, 0.5)',\r\n  'rgba(54, 162, 235, 0.5)',\r\n  'rgba(255, 206, 86, 0.5)',\r\n  'rgba(75, 192, 192, 0.5)',\r\n  'rgba(153, 102, 255, 0.5)',\r\n  'rgba(255, 159, 64, 0.5)',\r\n  'rgba(255, 99, 132, 0.5)',\r\n  'rgba(54, 162, 235, 0.5)',\r\n]\r\n\r\n\r\nexport default function ScoreChart({scores, pseudo, isCreator, allImages, allLabels}: {scores: {[pseudo: string]: number[]}, pseudo: string, isCreator: boolean, allImages: string[], allLabels: string[]}){\r\n    const [cummulative, setCummulative] = useState(false)\r\n    const [initialScores, setInitialScores] = useState(scores) // Copie les scores dans l'état lors du montage\r\n\r\n    useEffect(() => {\r\n        setInitialScores(scores) // Met à jour initialScores seulement lors du montage\r\n    }, []) // Passer un tableau vide comme dépendance rend l'effet exécutable seulement lors du montage\r\n\r\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        setCummulative(event.target.checked)\r\n    }\r\n\r\n    const nb_predictions = Object.values(initialScores)[0].length\r\n    const labels = cummulative ? generateRange(0, nb_predictions) : generateRange(1, nb_predictions)\r\n\r\n    const data = {\r\n        labels: labels,\r\n        datasets: Object.keys(initialScores).map((player, index) => ({\r\n            label: player,\r\n            data: cummulative ? cumulativeSum(Object.values(initialScores[player])) : Object.values(initialScores[player]),\r\n            backgroundColor: COLORS[index % COLORS.length],\r\n            borderColor: COLORS[index % COLORS.length].replace('0.5', '1'),\r\n            hidden: !isCreator && player !== pseudo,\r\n        })),\r\n    }\r\n\r\n    // Options de la chart\r\n    const options = {\r\n        responsive: true,\r\n        plugins: {\r\n            legend: {\r\n              position: 'top' as const,\r\n            },\r\n            title: {\r\n              display: true,\r\n              text: cummulative ? 'Evolution du score total' : 'Evolution de la qualité des prédictions',\r\n            },\r\n            tooltip: {\r\n              enabled: false,\r\n              external: (context) => externalTooltipHandler(context, allImages, allLabels, cummulative),\r\n            },\r\n        },\r\n        scales: {\r\n            x: {\r\n              title: {\r\n                display: true,\r\n                text: 'Prédiction',\r\n              },\r\n            },\r\n            y: {\r\n              title: {\r\n                display: true,\r\n                text: 'Score',\r\n              },\r\n            }\r\n        },\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <FormControlLabel control={<Switch checked={cummulative} onChange={handleChange} inputProps={{ 'aria-label': 'controlled' }} />} label=\"Afficher score total\" />\r\n            <Line data={data} options={options} />\r\n        </>\r\n    )\r\n  }\r\n\r\n  const getImageForDataPoint = (images: string[], dataIndex: number) => {\r\n    if (0 <= dataIndex && dataIndex < images.length) {\r\n      return images[dataIndex]\r\n    }\r\n    return null\r\n  }\r\n  const getLabelForDataPoint = (labels: string[], dataIndex: number) => {\r\n    if (0 <= dataIndex && dataIndex < labels.length) {\r\n      return labels[dataIndex]\r\n    }\r\n    return null\r\n  }\r\n\r\n  const getOrCreateTooltip = (chart: Chart<'line'>): HTMLDivElement => {\r\n    let tooltipEl = chart.canvas.parentNode.querySelector('div');\r\n  \r\n    if (!tooltipEl) {\r\n      tooltipEl = document.createElement('div');\r\n      tooltipEl.style.background = 'rgba(0, 0, 0, 0.7)';\r\n      tooltipEl.style.borderRadius = '3px';\r\n      tooltipEl.style.color = 'white';\r\n      tooltipEl.style.opacity = '1';\r\n      tooltipEl.style.pointerEvents = 'none';\r\n      tooltipEl.style.position = 'absolute';\r\n      tooltipEl.style.transform = 'translate(-50%, 0)';\r\n      tooltipEl.style.transition = 'all .1s ease';\r\n  \r\n      const table = document.createElement('table');\r\n      table.style.margin = '0px';\r\n  \r\n      tooltipEl.appendChild(table);\r\n      chart.canvas.parentNode.appendChild(tooltipEl);\r\n    }\r\n  \r\n    return tooltipEl;\r\n  };\r\n  \r\n  const externalTooltipHandler = (context, images: string[], labels: string[], cummulative: boolean) => {\r\n    // Tooltip Element\r\n    const {chart, tooltip} = context;\r\n    const tooltipEl = getOrCreateTooltip(chart);\r\n  \r\n    // Hide if no tooltip\r\n    if (tooltip.opacity === 0) {\r\n      tooltipEl.style.opacity = '0';\r\n      return;\r\n    }\r\n  \r\n    // Set Text\r\n    if (tooltip.body) {\r\n      const titleLines = tooltip.title || [];\r\n      const bodyLines = tooltip.body.map(b => b.lines);\r\n\r\n      // Get the first data point under the tooltip\r\n      const firstPoint = tooltip.dataPoints[0];\r\n      let dataIndex = firstPoint.dataIndex;\r\n      if (cummulative) {\r\n        dataIndex -= 1\r\n      }\r\n\r\n      // Use datasetIndex and dataIndex to get the appropriate image\r\n      const imageSrc = getImageForDataPoint(images, dataIndex);\r\n      const label = getLabelForDataPoint(labels, dataIndex)\r\n  \r\n      const tableHead = document.createElement('thead');\r\n  \r\n      titleLines.forEach(title => {\r\n        const tr = document.createElement('tr');\r\n        tr.style.borderWidth = '0';\r\n  \r\n        const th = document.createElement('th');\r\n        th.style.borderWidth = '0';\r\n        const text = document.createTextNode(title);\r\n  \r\n        th.appendChild(text);\r\n        tr.appendChild(th);\r\n        tableHead.appendChild(tr);\r\n      });\r\n  \r\n      const tableBody = document.createElement('tbody');\r\n      bodyLines.forEach((body, i) => {\r\n        // Add image only for one point even when multiple points are under the cursor (logic to be improved in the future here)\r\n        if (i === 0) {\r\n          const img = document.createElement('img');\r\n          img.src = imageSrc\r\n          img.style.height = '200px';\r\n          img.style.marginRight = '10px';\r\n          img.style.backgroundColor = 'white';\r\n\r\n          const textAboveImage = document.createTextNode('Label: ' + label);\r\n    \r\n          const tr = document.createElement('tr');\r\n          tr.style.backgroundColor = 'inherit';\r\n          tr.style.borderWidth = '0';\r\n    \r\n          const td = document.createElement('td');\r\n          td.style.borderWidth = '0';\r\n    \r\n          const text = document.createTextNode(body);\r\n    \r\n          if (imageSrc && label) {\r\n            td.appendChild(textAboveImage)\r\n            td.appendChild(img);\r\n          }\r\n          td.appendChild(text);\r\n          tr.appendChild(td);\r\n          tableBody.appendChild(tr);\r\n        }\r\n      });\r\n  \r\n      const tableRoot = tooltipEl.querySelector('table');\r\n  \r\n      // Remove old children\r\n      while (tableRoot.firstChild) {\r\n        tableRoot.firstChild.remove();\r\n      }\r\n  \r\n      // Add new children\r\n      tableRoot.appendChild(tableHead);\r\n      tableRoot.appendChild(tableBody);\r\n    }\r\n  \r\n    const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;\r\n  \r\n    // Display, position, and set styles for font\r\n    tooltipEl.style.opacity = '1';\r\n    tooltipEl.style.left = positionX + tooltip.caretX + 'px';\r\n    tooltipEl.style.top = positionY +tooltip.caretY + 'px';\r\n    tooltipEl.style.font = tooltip.options.bodyFont.string;\r\n    tooltipEl.style.padding = tooltip.options.padding + 'px ' + tooltip.options.padding + 'px';\r\n  };","C:\\Users\\vince\\OneDrive\\Documents\\GitHub\\eleusia\\src\\components\\AIModel.tsx",[],[],{"ruleId":"74","severity":1,"message":"75","line":54,"column":8,"nodeType":"76","endLine":54,"endColumn":10,"suggestions":"77"},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'scores'. Either include it or remove the dependency array. If 'setInitialScores' needs the current value of 'scores', you can also switch to useReducer instead of useState and read 'scores' in the reducer.","ArrayExpression",["78"],{"desc":"79","fix":"80"},"Update the dependencies array to be: [scores]",{"range":"81","text":"82"},[1624,1626],"[scores]"]